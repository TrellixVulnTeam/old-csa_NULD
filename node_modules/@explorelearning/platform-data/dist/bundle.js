var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __assign = Object.assign;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, {get: all[name2], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: true})), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (result) => {
      return result.done ? resolve(result.value) : Promise.resolve(result.value).then(fulfilled, rejected);
    };
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// ../authenticator/node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function bind(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      return fn.apply(thisArg, args);
    };
  };
});

// ../authenticator/node_modules/axios/lib/utils.js
var require_utils = __commonJS((exports2, module2) => {
  "use strict";
  var bind = require_bind();
  var toString = Object.prototype.toString;
  function isArray(val) {
    return toString.call(val) === "[object Array]";
  }
  function isUndefined(val) {
    return typeof val === "undefined";
  }
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
  }
  function isArrayBuffer(val) {
    return toString.call(val) === "[object ArrayBuffer]";
  }
  function isFormData(val) {
    return typeof FormData !== "undefined" && val instanceof FormData;
  }
  function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && val.buffer instanceof ArrayBuffer;
    }
    return result;
  }
  function isString(val) {
    return typeof val === "string";
  }
  function isNumber(val) {
    return typeof val === "number";
  }
  function isObject(val) {
    return val !== null && typeof val === "object";
  }
  function isPlainObject(val) {
    if (toString.call(val) !== "[object Object]") {
      return false;
    }
    var prototype = Object.getPrototypeOf(val);
    return prototype === null || prototype === Object.prototype;
  }
  function isDate(val) {
    return toString.call(val) === "[object Date]";
  }
  function isFile(val) {
    return toString.call(val) === "[object File]";
  }
  function isBlob(val) {
    return toString.call(val) === "[object Blob]";
  }
  function isFunction(val) {
    return toString.call(val) === "[object Function]";
  }
  function isStream(val) {
    return isObject(val) && isFunction(val.pipe);
  }
  function isURLSearchParams(val) {
    return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
  }
  function trim(str) {
    return str.replace(/^\s*/, "").replace(/\s*$/, "");
  }
  function isStandardBrowserEnv() {
    if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
      return false;
    }
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function forEach(obj, fn) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }
  function merge() {
    var result = {};
    function assignValue(val, key) {
      if (isPlainObject(result[key]) && isPlainObject(val)) {
        result[key] = merge(result[key], val);
      } else if (isPlainObject(val)) {
        result[key] = merge({}, val);
      } else if (isArray(val)) {
        result[key] = val.slice();
      } else {
        result[key] = val;
      }
    }
    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }
  function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
      if (thisArg && typeof val === "function") {
        a[key] = bind(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }
  function stripBOM(content) {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  }
  module2.exports = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isObject,
    isPlainObject,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isFunction,
    isStream,
    isURLSearchParams,
    isStandardBrowserEnv,
    forEach,
    merge,
    extend,
    trim,
    stripBOM
  };
});

// ../authenticator/node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  module2.exports = function buildURL(url, params, paramsSerializer) {
    if (!params) {
      return url;
    }
    var serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];
      utils.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === "undefined") {
          return;
        }
        if (utils.isArray(val)) {
          key = key + "[]";
        } else {
          val = [val];
        }
        utils.forEach(val, function parseValue(v) {
          if (utils.isDate(v)) {
            v = v.toISOString();
          } else if (utils.isObject(v)) {
            v = JSON.stringify(v);
          }
          parts.push(encode(key) + "=" + encode(v));
        });
      });
      serializedParams = parts.join("&");
    }
    if (serializedParams) {
      var hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  };
});

// ../authenticator/node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  function InterceptorManager() {
    this.handlers = [];
  }
  InterceptorManager.prototype.use = function use(fulfilled, rejected) {
    this.handlers.push({
      fulfilled,
      rejected
    });
    return this.handlers.length - 1;
  };
  InterceptorManager.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };
  InterceptorManager.prototype.forEach = function forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };
  module2.exports = InterceptorManager;
});

// ../authenticator/node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  module2.exports = function transformData(data, headers, fns) {
    utils.forEach(fns, function transform(fn) {
      data = fn(data, headers);
    });
    return data;
  };
});

// ../authenticator/node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function isCancel(value) {
    return !!(value && value.__CANCEL__);
  };
});

// ../authenticator/node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  module2.exports = function normalizeHeaderName(headers, normalizedName) {
    utils.forEach(headers, function processHeader(value, name2) {
      if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name2];
      }
    });
  };
});

// ../authenticator/node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function enhanceError(error, config, code, request, response) {
    error.config = config;
    if (code) {
      error.code = code;
    }
    error.request = request;
    error.response = response;
    error.isAxiosError = true;
    error.toJSON = function toJSON() {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: this.config,
        code: this.code
      };
    };
    return error;
  };
});

// ../authenticator/node_modules/axios/lib/core/createError.js
var require_createError = __commonJS((exports2, module2) => {
  "use strict";
  var enhanceError = require_enhanceError();
  module2.exports = function createError(message, config, code, request, response) {
    var error = new Error(message);
    return enhanceError(error, config, code, request, response);
  };
});

// ../authenticator/node_modules/axios/lib/core/settle.js
var require_settle = __commonJS((exports2, module2) => {
  "use strict";
  var createError = require_createError();
  module2.exports = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
    }
  };
});

// ../authenticator/node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
    return {
      write: function write(name2, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name2 + "=" + encodeURIComponent(value));
        if (utils.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read(name2) {
        var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name2) {
        this.write(name2, "", Date.now() - 864e5);
      }
    };
  }() : function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read() {
        return null;
      },
      remove: function remove() {
      }
    };
  }();
});

// ../authenticator/node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function isAbsoluteURL(url) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
  };
});

// ../authenticator/node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  };
});

// ../authenticator/node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS((exports2, module2) => {
  "use strict";
  var isAbsoluteURL = require_isAbsoluteURL();
  var combineURLs = require_combineURLs();
  module2.exports = function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  };
});

// ../authenticator/node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  module2.exports = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;
    if (!headers) {
      return parsed;
    }
    utils.forEach(headers.split("\n"), function parser(line) {
      i = line.indexOf(":");
      key = utils.trim(line.substr(0, i)).toLowerCase();
      val = utils.trim(line.substr(i + 1));
      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === "set-cookie") {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
});

// ../authenticator/node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    function resolveURL(url) {
      var href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }();
});

// ../authenticator/node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  var settle = require_settle();
  var cookies = require_cookies();
  var buildURL = require_buildURL();
  var buildFullPath = require_buildFullPath();
  var parseHeaders = require_parseHeaders();
  var isURLSameOrigin = require_isURLSameOrigin();
  var createError = require_createError();
  module2.exports = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;
      if (utils.isFormData(requestData)) {
        delete requestHeaders["Content-Type"];
      }
      var request = new XMLHttpRequest();
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath(config.baseURL, config.url);
      request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
      request.timeout = config.timeout;
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
        var responseData = !config.responseType || config.responseType === "text" ? request.responseText : request.response;
        var response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle(resolve, reject, response);
        request = null;
      };
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(createError("Request aborted", config, "ECONNABORTED", request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(createError("Network Error", config, null, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(createError(timeoutErrorMessage, config, "ECONNABORTED", request));
        request = null;
      };
      if (utils.isStandardBrowserEnv()) {
        var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request) {
        utils.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
            delete requestHeaders[key];
          } else {
            request.setRequestHeader(key, val);
          }
        });
      }
      if (!utils.isUndefined(config.withCredentials)) {
        request.withCredentials = !!config.withCredentials;
      }
      if (config.responseType) {
        try {
          request.responseType = config.responseType;
        } catch (e) {
          if (config.responseType !== "json") {
            throw e;
          }
        }
      }
      if (typeof config.onDownloadProgress === "function") {
        request.addEventListener("progress", config.onDownloadProgress);
      }
      if (typeof config.onUploadProgress === "function" && request.upload) {
        request.upload.addEventListener("progress", config.onUploadProgress);
      }
      if (config.cancelToken) {
        config.cancelToken.promise.then(function onCanceled(cancel) {
          if (!request) {
            return;
          }
          request.abort();
          reject(cancel);
          request = null;
        });
      }
      if (!requestData) {
        requestData = null;
      }
      request.send(requestData);
    });
  };
});

// ../../node_modules/ms/index.js
var require_ms = __commonJS((exports2, module2) => {
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name2) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name2 + (isPlural ? "s" : "");
  }
});

// ../../node_modules/debug/src/common.js
var require_common = __commonJS((exports2, module2) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date());
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name2) {
      if (name2[name2.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name2)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module2.exports = setup;
});

// ../../node_modules/debug/src/browser.js
var require_browser = __commonJS((exports2, module2) => {
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports2.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports2.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module2.exports = require_common()(exports2);
  var {formatters} = module2.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// ../../node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// ../../node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports2, module2) => {
  "use strict";
  var os = require("os");
  var tty = require("tty");
  var hasFlag = require_has_flag();
  var {env} = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  module2.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
});

// ../../node_modules/debug/src/node.js
var require_node = __commonJS((exports2, module2) => {
  var tty = require("tty");
  var util = require("util");
  exports2.init = init;
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports2.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const {namespace: name2, useColors: useColors2} = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name2} [0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
    } else {
      args[0] = getDate() + name2 + " " + args[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.format(...args) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports2.inspectOpts);
    for (let i = 0; i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  module2.exports = require_common()(exports2);
  var {formatters} = module2.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// ../../node_modules/debug/src/index.js
var require_src = __commonJS((exports2, module2) => {
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    module2.exports = require_browser();
  } else {
    module2.exports = require_node();
  }
});

// ../authenticator/node_modules/follow-redirects/debug.js
var require_debug = __commonJS((exports2, module2) => {
  var debug;
  module2.exports = function() {
    if (!debug) {
      try {
        debug = require_src()("follow-redirects");
      } catch (error) {
        debug = function() {
        };
      }
    }
    debug.apply(null, arguments);
  };
});

// ../authenticator/node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS((exports2, module2) => {
  var url = require("url");
  var URL = url.URL;
  var http = require("http");
  var https = require("https");
  var Writable = require("stream").Writable;
  var assert = require("assert");
  var debug = require_debug();
  var eventHandlers = Object.create(null);
  ["abort", "aborted", "connect", "error", "socket", "timeout"].forEach(function(event) {
    eventHandlers[event] = function(arg1, arg2, arg3) {
      this._redirectable.emit(event, arg1, arg2, arg3);
    };
  });
  var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "");
  var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded");
  var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
  var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  function RedirectableRequest(options, responseCallback) {
    Writable.call(this);
    this._sanitizeOptions(options);
    this._options = options;
    this._ended = false;
    this._ending = false;
    this._redirectCount = 0;
    this._redirects = [];
    this._requestBodyLength = 0;
    this._requestBodyBuffers = [];
    if (responseCallback) {
      this.on("response", responseCallback);
    }
    var self2 = this;
    this._onNativeResponse = function(response) {
      self2._processResponse(response);
    };
    this._performRequest();
  }
  RedirectableRequest.prototype = Object.create(Writable.prototype);
  RedirectableRequest.prototype.write = function(data, encoding, callback) {
    if (this._ending) {
      throw new WriteAfterEndError();
    }
    if (!(typeof data === "string" || typeof data === "object" && "length" in data)) {
      throw new TypeError("data should be a string, Buffer or Uint8Array");
    }
    if (typeof encoding === "function") {
      callback = encoding;
      encoding = null;
    }
    if (data.length === 0) {
      if (callback) {
        callback();
      }
      return;
    }
    if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
      this._requestBodyLength += data.length;
      this._requestBodyBuffers.push({data, encoding});
      this._currentRequest.write(data, encoding, callback);
    } else {
      this.emit("error", new MaxBodyLengthExceededError());
      this.abort();
    }
  };
  RedirectableRequest.prototype.end = function(data, encoding, callback) {
    if (typeof data === "function") {
      callback = data;
      data = encoding = null;
    } else if (typeof encoding === "function") {
      callback = encoding;
      encoding = null;
    }
    if (!data) {
      this._ended = this._ending = true;
      this._currentRequest.end(null, null, callback);
    } else {
      var self2 = this;
      var currentRequest = this._currentRequest;
      this.write(data, encoding, function() {
        self2._ended = true;
        currentRequest.end(null, null, callback);
      });
      this._ending = true;
    }
  };
  RedirectableRequest.prototype.setHeader = function(name2, value) {
    this._options.headers[name2] = value;
    this._currentRequest.setHeader(name2, value);
  };
  RedirectableRequest.prototype.removeHeader = function(name2) {
    delete this._options.headers[name2];
    this._currentRequest.removeHeader(name2);
  };
  RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
    if (callback) {
      this.once("timeout", callback);
    }
    if (this.socket) {
      startTimer(this, msecs);
    } else {
      var self2 = this;
      this._currentRequest.once("socket", function() {
        startTimer(self2, msecs);
      });
    }
    this.once("response", clearTimer);
    this.once("error", clearTimer);
    return this;
  };
  function startTimer(request, msecs) {
    clearTimeout(request._timeout);
    request._timeout = setTimeout(function() {
      request.emit("timeout");
    }, msecs);
  }
  function clearTimer() {
    clearTimeout(this._timeout);
  }
  [
    "abort",
    "flushHeaders",
    "getHeader",
    "setNoDelay",
    "setSocketKeepAlive"
  ].forEach(function(method) {
    RedirectableRequest.prototype[method] = function(a, b) {
      return this._currentRequest[method](a, b);
    };
  });
  ["aborted", "connection", "socket"].forEach(function(property) {
    Object.defineProperty(RedirectableRequest.prototype, property, {
      get: function() {
        return this._currentRequest[property];
      }
    });
  });
  RedirectableRequest.prototype._sanitizeOptions = function(options) {
    if (!options.headers) {
      options.headers = {};
    }
    if (options.host) {
      if (!options.hostname) {
        options.hostname = options.host;
      }
      delete options.host;
    }
    if (!options.pathname && options.path) {
      var searchPos = options.path.indexOf("?");
      if (searchPos < 0) {
        options.pathname = options.path;
      } else {
        options.pathname = options.path.substring(0, searchPos);
        options.search = options.path.substring(searchPos);
      }
    }
  };
  RedirectableRequest.prototype._performRequest = function() {
    var protocol = this._options.protocol;
    var nativeProtocol = this._options.nativeProtocols[protocol];
    if (!nativeProtocol) {
      this.emit("error", new TypeError("Unsupported protocol " + protocol));
      return;
    }
    if (this._options.agents) {
      var scheme = protocol.substr(0, protocol.length - 1);
      this._options.agent = this._options.agents[scheme];
    }
    var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
    this._currentUrl = url.format(this._options);
    request._redirectable = this;
    for (var event in eventHandlers) {
      if (event) {
        request.on(event, eventHandlers[event]);
      }
    }
    if (this._isRedirect) {
      var i = 0;
      var self2 = this;
      var buffers = this._requestBodyBuffers;
      (function writeNext(error) {
        if (request === self2._currentRequest) {
          if (error) {
            self2.emit("error", error);
          } else if (i < buffers.length) {
            var buffer = buffers[i++];
            if (!request.finished) {
              request.write(buffer.data, buffer.encoding, writeNext);
            }
          } else if (self2._ended) {
            request.end();
          }
        }
      })();
    }
  };
  RedirectableRequest.prototype._processResponse = function(response) {
    var statusCode = response.statusCode;
    if (this._options.trackRedirects) {
      this._redirects.push({
        url: this._currentUrl,
        headers: response.headers,
        statusCode
      });
    }
    var location2 = response.headers.location;
    if (location2 && this._options.followRedirects !== false && statusCode >= 300 && statusCode < 400) {
      this._currentRequest.removeAllListeners();
      this._currentRequest.on("error", noop);
      this._currentRequest.abort();
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        this.emit("error", new TooManyRedirectsError());
        return;
      }
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var previousHostName = removeMatchingHeaders(/^host$/i, this._options.headers) || url.parse(this._currentUrl).hostname;
      var redirectUrl = url.resolve(this._currentUrl, location2);
      debug("redirecting to", redirectUrl);
      this._isRedirect = true;
      var redirectUrlParts = url.parse(redirectUrl);
      Object.assign(this._options, redirectUrlParts);
      if (redirectUrlParts.hostname !== previousHostName) {
        removeMatchingHeaders(/^authorization$/i, this._options.headers);
      }
      if (typeof this._options.beforeRedirect === "function") {
        var responseDetails = {headers: response.headers};
        try {
          this._options.beforeRedirect.call(null, this._options, responseDetails);
        } catch (err) {
          this.emit("error", err);
          return;
        }
        this._sanitizeOptions(this._options);
      }
      try {
        this._performRequest();
      } catch (cause) {
        var error = new RedirectionError("Redirected request failed: " + cause.message);
        error.cause = cause;
        this.emit("error", error);
      }
    } else {
      response.responseUrl = this._currentUrl;
      response.redirects = this._redirects;
      this.emit("response", response);
      this._requestBodyBuffers = [];
    }
  };
  function wrap(protocols) {
    var exports3 = {
      maxRedirects: 21,
      maxBodyLength: 10 * 1024 * 1024
    };
    var nativeProtocols = {};
    Object.keys(protocols).forEach(function(scheme) {
      var protocol = scheme + ":";
      var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
      var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
      function request(input, options, callback) {
        if (typeof input === "string") {
          var urlStr = input;
          try {
            input = urlToOptions(new URL(urlStr));
          } catch (err) {
            input = url.parse(urlStr);
          }
        } else if (URL && input instanceof URL) {
          input = urlToOptions(input);
        } else {
          callback = options;
          options = input;
          input = {protocol};
        }
        if (typeof options === "function") {
          callback = options;
          options = null;
        }
        options = Object.assign({
          maxRedirects: exports3.maxRedirects,
          maxBodyLength: exports3.maxBodyLength
        }, input, options);
        options.nativeProtocols = nativeProtocols;
        assert.equal(options.protocol, protocol, "protocol mismatch");
        debug("options", options);
        return new RedirectableRequest(options, callback);
      }
      function get(input, options, callback) {
        var wrappedRequest = wrappedProtocol.request(input, options, callback);
        wrappedRequest.end();
        return wrappedRequest;
      }
      Object.defineProperties(wrappedProtocol, {
        request: {value: request, configurable: true, enumerable: true, writable: true},
        get: {value: get, configurable: true, enumerable: true, writable: true}
      });
    });
    return exports3;
  }
  function noop() {
  }
  function urlToOptions(urlObject) {
    var options = {
      protocol: urlObject.protocol,
      hostname: urlObject.hostname.startsWith("[") ? urlObject.hostname.slice(1, -1) : urlObject.hostname,
      hash: urlObject.hash,
      search: urlObject.search,
      pathname: urlObject.pathname,
      path: urlObject.pathname + urlObject.search,
      href: urlObject.href
    };
    if (urlObject.port !== "") {
      options.port = Number(urlObject.port);
    }
    return options;
  }
  function removeMatchingHeaders(regex, headers) {
    var lastValue;
    for (var header in headers) {
      if (regex.test(header)) {
        lastValue = headers[header];
        delete headers[header];
      }
    }
    return lastValue;
  }
  function createErrorType(code, defaultMessage) {
    function CustomError(message) {
      Error.captureStackTrace(this, this.constructor);
      this.message = message || defaultMessage;
    }
    CustomError.prototype = new Error();
    CustomError.prototype.constructor = CustomError;
    CustomError.prototype.name = "Error [" + code + "]";
    CustomError.prototype.code = code;
    return CustomError;
  }
  module2.exports = wrap({http, https});
  module2.exports.wrap = wrap;
});

// ../authenticator/node_modules/axios/package.json
var require_package = __commonJS((exports2, module2) => {
  module2.exports = {
    name: "axios",
    version: "0.21.1",
    description: "Promise based HTTP client for the browser and node.js",
    main: "index.js",
    scripts: {
      test: "grunt test && bundlesize",
      start: "node ./sandbox/server.js",
      build: "NODE_ENV=production grunt build",
      preversion: "npm test",
      version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
      postversion: "git push && git push --tags",
      examples: "node ./examples/server.js",
      coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
      fix: "eslint --fix lib/**/*.js"
    },
    repository: {
      type: "git",
      url: "https://github.com/axios/axios.git"
    },
    keywords: [
      "xhr",
      "http",
      "ajax",
      "promise",
      "node"
    ],
    author: "Matt Zabriskie",
    license: "MIT",
    bugs: {
      url: "https://github.com/axios/axios/issues"
    },
    homepage: "https://github.com/axios/axios",
    devDependencies: {
      bundlesize: "^0.17.0",
      coveralls: "^3.0.0",
      "es6-promise": "^4.2.4",
      grunt: "^1.0.2",
      "grunt-banner": "^0.6.0",
      "grunt-cli": "^1.2.0",
      "grunt-contrib-clean": "^1.1.0",
      "grunt-contrib-watch": "^1.0.0",
      "grunt-eslint": "^20.1.0",
      "grunt-karma": "^2.0.0",
      "grunt-mocha-test": "^0.13.3",
      "grunt-ts": "^6.0.0-beta.19",
      "grunt-webpack": "^1.0.18",
      "istanbul-instrumenter-loader": "^1.0.0",
      "jasmine-core": "^2.4.1",
      karma: "^1.3.0",
      "karma-chrome-launcher": "^2.2.0",
      "karma-coverage": "^1.1.1",
      "karma-firefox-launcher": "^1.1.0",
      "karma-jasmine": "^1.1.1",
      "karma-jasmine-ajax": "^0.1.13",
      "karma-opera-launcher": "^1.0.0",
      "karma-safari-launcher": "^1.0.0",
      "karma-sauce-launcher": "^1.2.0",
      "karma-sinon": "^1.0.5",
      "karma-sourcemap-loader": "^0.3.7",
      "karma-webpack": "^1.7.0",
      "load-grunt-tasks": "^3.5.2",
      minimist: "^1.2.0",
      mocha: "^5.2.0",
      sinon: "^4.5.0",
      typescript: "^2.8.1",
      "url-search-params": "^0.10.0",
      webpack: "^1.13.1",
      "webpack-dev-server": "^1.14.1"
    },
    browser: {
      "./lib/adapters/http.js": "./lib/adapters/xhr.js"
    },
    jsdelivr: "dist/axios.min.js",
    unpkg: "dist/axios.min.js",
    typings: "./index.d.ts",
    dependencies: {
      "follow-redirects": "^1.10.0"
    },
    bundlesize: [
      {
        path: "./dist/axios.min.js",
        threshold: "5kB"
      }
    ]
  };
});

// ../authenticator/node_modules/axios/lib/adapters/http.js
var require_http = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  var settle = require_settle();
  var buildFullPath = require_buildFullPath();
  var buildURL = require_buildURL();
  var http = require("http");
  var https = require("https");
  var httpFollow = require_follow_redirects().http;
  var httpsFollow = require_follow_redirects().https;
  var url = require("url");
  var zlib = require("zlib");
  var pkg = require_package();
  var createError = require_createError();
  var enhanceError = require_enhanceError();
  var isHttps = /https:?/;
  function setProxy(options, proxy, location2) {
    options.hostname = proxy.host;
    options.host = proxy.host;
    options.port = proxy.port;
    options.path = location2;
    if (proxy.auth) {
      var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    options.beforeRedirect = function beforeRedirect(redirection) {
      redirection.headers.host = redirection.host;
      setProxy(redirection, proxy, redirection.href);
    };
  }
  module2.exports = function httpAdapter(config) {
    return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
      var resolve = function resolve2(value) {
        resolvePromise(value);
      };
      var reject = function reject2(value) {
        rejectPromise(value);
      };
      var data = config.data;
      var headers = config.headers;
      if (!headers["User-Agent"] && !headers["user-agent"]) {
        headers["User-Agent"] = "axios/" + pkg.version;
      }
      if (data && !utils.isStream(data)) {
        if (Buffer.isBuffer(data)) {
        } else if (utils.isArrayBuffer(data)) {
          data = Buffer.from(new Uint8Array(data));
        } else if (utils.isString(data)) {
          data = Buffer.from(data, "utf-8");
        } else {
          return reject(createError("Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream", config));
        }
        headers["Content-Length"] = data.length;
      }
      var auth = void 0;
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password || "";
        auth = username + ":" + password;
      }
      var fullPath = buildFullPath(config.baseURL, config.url);
      var parsed = url.parse(fullPath);
      var protocol = parsed.protocol || "http:";
      if (!auth && parsed.auth) {
        var urlAuth = parsed.auth.split(":");
        var urlUsername = urlAuth[0] || "";
        var urlPassword = urlAuth[1] || "";
        auth = urlUsername + ":" + urlPassword;
      }
      if (auth) {
        delete headers.Authorization;
      }
      var isHttpsRequest = isHttps.test(protocol);
      var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
      var options = {
        path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ""),
        method: config.method.toUpperCase(),
        headers,
        agent,
        agents: {http: config.httpAgent, https: config.httpsAgent},
        auth
      };
      if (config.socketPath) {
        options.socketPath = config.socketPath;
      } else {
        options.hostname = parsed.hostname;
        options.port = parsed.port;
      }
      var proxy = config.proxy;
      if (!proxy && proxy !== false) {
        var proxyEnv = protocol.slice(0, -1) + "_proxy";
        var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
        if (proxyUrl) {
          var parsedProxyUrl = url.parse(proxyUrl);
          var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
          var shouldProxy = true;
          if (noProxyEnv) {
            var noProxy = noProxyEnv.split(",").map(function trim(s) {
              return s.trim();
            });
            shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
              if (!proxyElement) {
                return false;
              }
              if (proxyElement === "*") {
                return true;
              }
              if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                return true;
              }
              return parsed.hostname === proxyElement;
            });
          }
          if (shouldProxy) {
            proxy = {
              host: parsedProxyUrl.hostname,
              port: parsedProxyUrl.port,
              protocol: parsedProxyUrl.protocol
            };
            if (parsedProxyUrl.auth) {
              var proxyUrlAuth = parsedProxyUrl.auth.split(":");
              proxy.auth = {
                username: proxyUrlAuth[0],
                password: proxyUrlAuth[1]
              };
            }
          }
        }
      }
      if (proxy) {
        options.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
        setProxy(options, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
      }
      var transport;
      var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
      if (config.transport) {
        transport = config.transport;
      } else if (config.maxRedirects === 0) {
        transport = isHttpsProxy ? https : http;
      } else {
        if (config.maxRedirects) {
          options.maxRedirects = config.maxRedirects;
        }
        transport = isHttpsProxy ? httpsFollow : httpFollow;
      }
      if (config.maxBodyLength > -1) {
        options.maxBodyLength = config.maxBodyLength;
      }
      var req = transport.request(options, function handleResponse(res) {
        if (req.aborted)
          return;
        var stream = res;
        var lastRequest = res.req || req;
        if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config.decompress !== false) {
          switch (res.headers["content-encoding"]) {
            case "gzip":
            case "compress":
            case "deflate":
              stream = stream.pipe(zlib.createUnzip());
              delete res.headers["content-encoding"];
              break;
          }
        }
        var response = {
          status: res.statusCode,
          statusText: res.statusMessage,
          headers: res.headers,
          config,
          request: lastRequest
        };
        if (config.responseType === "stream") {
          response.data = stream;
          settle(resolve, reject, response);
        } else {
          var responseBuffer = [];
          stream.on("data", function handleStreamData(chunk) {
            responseBuffer.push(chunk);
            if (config.maxContentLength > -1 && Buffer.concat(responseBuffer).length > config.maxContentLength) {
              stream.destroy();
              reject(createError("maxContentLength size of " + config.maxContentLength + " exceeded", config, null, lastRequest));
            }
          });
          stream.on("error", function handleStreamError(err) {
            if (req.aborted)
              return;
            reject(enhanceError(err, config, null, lastRequest));
          });
          stream.on("end", function handleStreamEnd() {
            var responseData = Buffer.concat(responseBuffer);
            if (config.responseType !== "arraybuffer") {
              responseData = responseData.toString(config.responseEncoding);
              if (!config.responseEncoding || config.responseEncoding === "utf8") {
                responseData = utils.stripBOM(responseData);
              }
            }
            response.data = responseData;
            settle(resolve, reject, response);
          });
        }
      });
      req.on("error", function handleRequestError(err) {
        if (req.aborted && err.code !== "ERR_FR_TOO_MANY_REDIRECTS")
          return;
        reject(enhanceError(err, config, null, req));
      });
      if (config.timeout) {
        req.setTimeout(config.timeout, function handleRequestTimeout() {
          req.abort();
          reject(createError("timeout of " + config.timeout + "ms exceeded", config, "ECONNABORTED", req));
        });
      }
      if (config.cancelToken) {
        config.cancelToken.promise.then(function onCanceled(cancel) {
          if (req.aborted)
            return;
          req.abort();
          reject(cancel);
        });
      }
      if (utils.isStream(data)) {
        data.on("error", function handleStreamError(err) {
          reject(enhanceError(err, config, null, req));
        }).pipe(req);
      } else {
        req.end(data);
      }
    });
  };
});

// ../authenticator/node_modules/axios/lib/defaults.js
var require_defaults = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  var normalizeHeaderName = require_normalizeHeaderName();
  var DEFAULT_CONTENT_TYPE = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  function setContentTypeIfUnset(headers, value) {
    if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
      headers["Content-Type"] = value;
    }
  }
  function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== "undefined") {
      adapter = require_xhr();
    } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
      adapter = require_http();
    }
    return adapter;
  }
  var defaults = {
    adapter: getDefaultAdapter(),
    transformRequest: [function transformRequest(data, headers) {
      normalizeHeaderName(headers, "Accept");
      normalizeHeaderName(headers, "Content-Type");
      if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
        return data;
      }
      if (utils.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils.isURLSearchParams(data)) {
        setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
        return data.toString();
      }
      if (utils.isObject(data)) {
        setContentTypeIfUnset(headers, "application/json;charset=utf-8");
        return JSON.stringify(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      if (typeof data === "string") {
        try {
          data = JSON.parse(data);
        } catch (e) {
        }
      }
      return data;
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    }
  };
  defaults.headers = {
    common: {
      Accept: "application/json, text/plain, */*"
    }
  };
  utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
    defaults.headers[method] = {};
  });
  utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
  });
  module2.exports = defaults;
});

// ../authenticator/node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  var transformData = require_transformData();
  var isCancel = require_isCancel();
  var defaults = require_defaults();
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
  }
  module2.exports = function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = config.headers || {};
    config.data = transformData(config.data, config.headers, config.transformRequest);
    config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
    utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
      delete config.headers[method];
    });
    var adapter = config.adapter || defaults.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData(response.data, response.headers, config.transformResponse);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
        }
      }
      return Promise.reject(reason);
    });
  };
});

// ../authenticator/node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  module2.exports = function mergeConfig(config1, config2) {
    config2 = config2 || {};
    var config = {};
    var valueFromConfig2Keys = ["url", "method", "data"];
    var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
    var defaultToConfig2Keys = [
      "baseURL",
      "transformRequest",
      "transformResponse",
      "paramsSerializer",
      "timeout",
      "timeoutMessage",
      "withCredentials",
      "adapter",
      "responseType",
      "xsrfCookieName",
      "xsrfHeaderName",
      "onUploadProgress",
      "onDownloadProgress",
      "decompress",
      "maxContentLength",
      "maxBodyLength",
      "maxRedirects",
      "transport",
      "httpAgent",
      "httpsAgent",
      "cancelToken",
      "socketPath",
      "responseEncoding"
    ];
    var directMergeKeys = ["validateStatus"];
    function getMergedValue(target, source) {
      if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
        return utils.merge(target, source);
      } else if (utils.isPlainObject(source)) {
        return utils.merge({}, source);
      } else if (utils.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(prop) {
      if (!utils.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (!utils.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    }
    utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
      if (!utils.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(void 0, config2[prop]);
      }
    });
    utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
    utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
      if (!utils.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(void 0, config2[prop]);
      } else if (!utils.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    });
    utils.forEach(directMergeKeys, function merge(prop) {
      if (prop in config2) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (prop in config1) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    });
    var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
    var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });
    utils.forEach(otherKeys, mergeDeepProperties);
    return config;
  };
});

// ../authenticator/node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  var buildURL = require_buildURL();
  var InterceptorManager = require_InterceptorManager();
  var dispatchRequest = require_dispatchRequest();
  var mergeConfig = require_mergeConfig();
  function Axios(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  Axios.prototype.request = function request(config) {
    if (typeof config === "string") {
      config = arguments[1] || {};
      config.url = arguments[0];
    } else {
      config = config || {};
    }
    config = mergeConfig(this.defaults, config);
    if (config.method) {
      config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
      config.method = this.defaults.method.toLowerCase();
    } else {
      config.method = "get";
    }
    var chain = [dispatchRequest, void 0];
    var promise = Promise.resolve(config);
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      chain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      chain.push(interceptor.fulfilled, interceptor.rejected);
    });
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  };
  Axios.prototype.getUri = function getUri(config) {
    config = mergeConfig(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
  };
  utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });
  utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    Axios.prototype[method] = function(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        url,
        data
      }));
    };
  });
  module2.exports = Axios;
});

// ../authenticator/node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS((exports2, module2) => {
  "use strict";
  function Cancel(message) {
    this.message = message;
  }
  Cancel.prototype.toString = function toString() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  };
  Cancel.prototype.__CANCEL__ = true;
  module2.exports = Cancel;
});

// ../authenticator/node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS((exports2, module2) => {
  "use strict";
  var Cancel = require_Cancel();
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token = this;
    executor(function cancel(message) {
      if (token.reason) {
        return;
      }
      token.reason = new Cancel(message);
      resolvePromise(token.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  };
  module2.exports = CancelToken;
});

// ../authenticator/node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };
});

// ../authenticator/node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function isAxiosError(payload) {
    return typeof payload === "object" && payload.isAxiosError === true;
  };
});

// ../authenticator/node_modules/axios/lib/axios.js
var require_axios = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  var bind = require_bind();
  var Axios = require_Axios();
  var mergeConfig = require_mergeConfig();
  var defaults = require_defaults();
  function createInstance(defaultConfig) {
    var context = new Axios(defaultConfig);
    var instance = bind(Axios.prototype.request, context);
    utils.extend(instance, Axios.prototype, context);
    utils.extend(instance, context);
    return instance;
  }
  var axios = createInstance(defaults);
  axios.Axios = Axios;
  axios.create = function create(instanceConfig) {
    return createInstance(mergeConfig(axios.defaults, instanceConfig));
  };
  axios.Cancel = require_Cancel();
  axios.CancelToken = require_CancelToken();
  axios.isCancel = require_isCancel();
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = require_spread();
  axios.isAxiosError = require_isAxiosError();
  module2.exports = axios;
  module2.exports.default = axios;
});

// ../authenticator/node_modules/axios/index.js
var require_axios2 = __commonJS((exports2, module2) => {
  module2.exports = require_axios();
});

// ../utils/dist/bundle.js
var require_bundle = __commonJS((exports2) => {
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __markAsModule2 = (target) => __defProp2(target, "__esModule", {value: true});
  var __commonJS2 = (callback, module22) => () => {
    if (!module22) {
      module22 = {exports: {}};
      callback(module22.exports, module22);
    }
    return module22.exports;
  };
  var __export2 = (target, all) => {
    for (var name22 in all)
      __defProp2(target, name22, {get: all[name22], enumerable: true});
  };
  var __exportStar2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames2(module22))
        if (!__hasOwnProp2.call(target, key) && key !== "default")
          __defProp2(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc2(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule2 = (module22) => {
    if (module22 && module22.__esModule)
      return module22;
    return __exportStar2(__markAsModule2(__defProp2(module22 != null ? __create2(__getProtoOf2(module22)) : {}, "default", {value: module22, enumerable: true})), module22);
  };
  var require_bundle4 = __commonJS2((exports22) => {
    var __defProp22 = Object.defineProperty;
    var __markAsModule22 = (target) => __defProp22(target, "__esModule", {value: true});
    var __export22 = (target, all) => {
      for (var name222 in all)
        __defProp22(target, name222, {get: all[name222], enumerable: true});
    };
    __markAsModule22(exports22);
    __export22(exports22, {
      createLogger: () => createLogger,
      versionTag: () => versionTag2
    });
    var name22 = "@explorelearning/logger";
    var version22 = "1.10.15";
    var description22 = "Fancy logging in the browser console";
    var main22 = "dist/bundle.js";
    var types22 = "dist/types/index.d.ts";
    var files2 = [
      "/dist"
    ];
    var scripts22 = {
      build: "node ../../helpers/build.js",
      "build:types": "npx tsc",
      test: "npx jest"
    };
    var repository2 = {
      type: "git",
      url: "git+https://github.com/ExploreLearning/el-web.git"
    };
    var author22 = "Brian McMillen <brian.mcmillen@explorelearning.com>";
    var license22 = "ISC";
    var bugs2 = {
      url: "https://github.com/ExploreLearning/el-web/issues"
    };
    var homepage2 = "https://github.com/ExploreLearning/el-web#readme";
    var package_default22 = {
      name: name22,
      version: version22,
      description: description22,
      main: main22,
      types: types22,
      files: files2,
      scripts: scripts22,
      repository: repository2,
      author: author22,
      license: license22,
      bugs: bugs2,
      homepage: homepage2
    };
    function log(...params) {
      if (localStorage.getItem("debug") === "true")
        console.info(...params);
    }
    if (!window.ELLogger) {
      window.ELLogger = {
        versionTagMap: {}
      };
      window.addEventListener("load", () => {
        const {versionTagMap} = window.ELLogger;
        Object.keys(versionTagMap).forEach((name222) => {
          logVersionTag({name: name222, version: versionTagMap[name222]});
        });
      });
    }
    versionTag2(package_default22);
    function logVersionTag({name: name222, version: version222}) {
      log(`%c${name222}%cv${version222}`, "color: #fbf1c7; background: #458588; padding: 2px 4px; border-radius: 3px 0 0 3px;", "color: #fbf1c7; background: #d65d0e; padding: 2px 4px; border-radius: 0 3px 3px 0");
    }
    function versionTag2({name: name222, version: version222}) {
      window.ELLogger.versionTagMap[name222] = version222;
    }
    function createLogger(name222) {
      return (...params) => {
        log(`${name222}:
`, ...params);
      };
    }
  });
  var require_bundle22 = __commonJS2((exports22) => {
    var __defProp22 = Object.defineProperty;
    var __markAsModule22 = (target) => __defProp22(target, "__esModule", {value: true});
    var __export22 = (target, all) => {
      for (var name22 in all)
        __defProp22(target, name22, {get: all[name22], enumerable: true});
    };
    __markAsModule22(exports22);
    __export22(exports22, {
      default: () => src_default2
    });
    var CancelHook = class {
      constructor() {
        this.signal = new Promise((res, rej) => this.cancel = rej);
      }
    };
    function cancellable(fnc, delay) {
      const hook = new CancelHook();
      const promise = new Promise((res) => {
        const timeout = setTimeout(() => {
          res(fnc());
        }, delay);
        hook.signal.catch(() => {
          res();
          clearTimeout(timeout);
        });
      });
      return {promise, cancel: hook.cancel};
    }
    var src_default2 = cancellable;
  });
  var require_lodash = __commonJS2((exports22, module22) => {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports22 == "object" && exports22 && !exports22.nodeType && exports22;
    var freeModule = freeExports && typeof module22 == "object" && module22 && !module22.nodeType && module22;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        hash: new Hash(),
        map: new (Map || ListCache)(),
        string: new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function cloneDeep2(value) {
      return baseClone(value, true, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module22.exports = cloneDeep2;
  });
  __markAsModule2(exports2);
  __export2(exports2, {
    cancellable: () => import_cancellable.default,
    capitalize: () => capitalize_default,
    copy: () => copy_default,
    debounce: () => debounce_default,
    mapByProp: () => mapByProp_default,
    setIfThere: () => setIfThere_default,
    valueFromPath: () => valueFromPath_default
  });
  var import_logger2 = __toModule2(require_bundle4());
  var name2 = "@explorelearning/utils";
  var version2 = "1.10.16";
  var description2 = "Common utility functions for ExploreLearning web apps";
  var main2 = "dist/bundle.js";
  var types2 = "dist/types/index.d.ts";
  var scripts2 = {
    build: "node ../../helpers/build.js",
    "build:types": "npx tsc",
    test: "npx jest"
  };
  var author2 = "Brian McMillen <brian.mcmillen@explorelearning.com>";
  var license2 = "ISC";
  var dependencies = {
    "@explorelearning/cancellable": "^1.10.7",
    "lodash.clonedeep": "^4.5.0"
  };
  var devDependencies2 = {
    "@explorelearning/logger": "^1.10.15"
  };
  var peerDependencies2 = {
    "@explorelearning/logger": "^1.10.15"
  };
  var gitHead2 = "e9274d4a4daf282707704109f9055fed7831778c";
  var package_default2 = {
    name: name2,
    version: version2,
    description: description2,
    main: main2,
    types: types2,
    scripts: scripts2,
    author: author2,
    license: license2,
    dependencies,
    devDependencies: devDependencies2,
    peerDependencies: peerDependencies2,
    gitHead: gitHead2
  };
  var import_cancellable = __toModule2(require_bundle22());
  function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
  }
  var capitalize_default = capitalize;
  var import_lodash = __toModule2(require_lodash());
  function copy2(obj) {
    return import_lodash.default(obj);
  }
  var copy_default = copy2;
  function debounce(func, delay) {
    let timeout;
    return function(...args) {
      clearTimeout(timeout);
      return new Promise((resolve) => {
        timeout = setTimeout(() => resolve(func.apply(this, args)), delay);
      });
    };
  }
  var debounce_default = debounce;
  function setIfThere(obj, prop, value) {
    if (typeof value !== "undefined") {
      obj[prop] = value;
      return true;
    } else {
      return false;
    }
  }
  var setIfThere_default = setIfThere;
  function valueFromPath({
    source,
    path = [],
    delimiter = "."
  } = {}) {
    const items = Array.isArray(path) ? path : path.split(delimiter);
    return source && typeof source === "object" ? items.reduce((acc, key) => acc ? acc[key] : void 0, source) : void 0;
  }
  var valueFromPath_default = valueFromPath;
  function mapToProp(arr, prop) {
    return arr.reduce((acc, item) => {
      acc[item[prop]] = item;
      return acc;
    }, {});
  }
  var mapByProp_default = mapToProp;
  import_logger2.versionTag(package_default2);
});

// ../authenticator/dist/bundle.js
var require_bundle2 = __commonJS((exports2) => {
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __assign2 = Object.assign;
  var __markAsModule2 = (target) => __defProp2(target, "__esModule", {value: true});
  var __commonJS2 = (callback, module22) => () => {
    if (!module22) {
      module22 = {exports: {}};
      callback(module22.exports, module22);
    }
    return module22.exports;
  };
  var __export2 = (target, all) => {
    for (var name22 in all)
      __defProp2(target, name22, {get: all[name22], enumerable: true});
  };
  var __exportStar2 = (target, module22, desc) => {
    if (module22 && typeof module22 === "object" || typeof module22 === "function") {
      for (let key of __getOwnPropNames2(module22))
        if (!__hasOwnProp2.call(target, key) && key !== "default")
          __defProp2(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc2(module22, key)) || desc.enumerable});
    }
    return target;
  };
  var __toModule2 = (module22) => {
    if (module22 && module22.__esModule)
      return module22;
    return __exportStar2(__markAsModule2(__defProp2(module22 != null ? __create2(__getProtoOf2(module22)) : {}, "default", {value: module22, enumerable: true})), module22);
  };
  var __async2 = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (result) => {
        return result.done ? resolve(result.value) : Promise.resolve(result.value).then(fulfilled, rejected);
      };
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var require_bundle4 = __commonJS2((exports22) => {
    var __create22 = Object.create;
    var __defProp22 = Object.defineProperty;
    var __getProtoOf22 = Object.getPrototypeOf;
    var __hasOwnProp22 = Object.prototype.hasOwnProperty;
    var __getOwnPropNames22 = Object.getOwnPropertyNames;
    var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
    var __markAsModule22 = (target) => __defProp22(target, "__esModule", {value: true});
    var __commonJS22 = (callback, module22) => () => {
      if (!module22) {
        module22 = {exports: {}};
        callback(module22.exports, module22);
      }
      return module22.exports;
    };
    var __export22 = (target, all) => {
      for (var name222 in all)
        __defProp22(target, name222, {get: all[name222], enumerable: true});
    };
    var __exportStar22 = (target, module22, desc) => {
      if (module22 && typeof module22 === "object" || typeof module22 === "function") {
        for (let key of __getOwnPropNames22(module22))
          if (!__hasOwnProp22.call(target, key) && key !== "default")
            __defProp22(target, key, {get: () => module22[key], enumerable: !(desc = __getOwnPropDesc22(module22, key)) || desc.enumerable});
      }
      return target;
    };
    var __toModule22 = (module22) => {
      if (module22 && module22.__esModule)
        return module22;
      return __exportStar22(__markAsModule22(__defProp22(module22 != null ? __create22(__getProtoOf22(module22)) : {}, "default", {value: module22, enumerable: true})), module22);
    };
    var require_bundle32 = __commonJS22((exports222) => {
      var __defProp222 = Object.defineProperty;
      var __markAsModule222 = (target) => __defProp222(target, "__esModule", {value: true});
      var __export222 = (target, all) => {
        for (var name2222 in all)
          __defProp222(target, name2222, {get: all[name2222], enumerable: true});
      };
      __markAsModule222(exports222);
      __export222(exports222, {
        createLogger: () => createLogger2,
        versionTag: () => versionTag2
      });
      var name222 = "@explorelearning/logger";
      var version222 = "1.10.15";
      var description222 = "Fancy logging in the browser console";
      var main222 = "dist/bundle.js";
      var types222 = "dist/types/index.d.ts";
      var files222 = [
        "/dist"
      ];
      var scripts222 = {
        build: "node ../../helpers/build.js",
        "build:types": "npx tsc",
        test: "npx jest"
      };
      var repository222 = {
        type: "git",
        url: "git+https://github.com/ExploreLearning/el-web.git"
      };
      var author222 = "Brian McMillen <brian.mcmillen@explorelearning.com>";
      var license222 = "ISC";
      var bugs222 = {
        url: "https://github.com/ExploreLearning/el-web/issues"
      };
      var homepage222 = "https://github.com/ExploreLearning/el-web#readme";
      var package_default222 = {
        name: name222,
        version: version222,
        description: description222,
        main: main222,
        types: types222,
        files: files222,
        scripts: scripts222,
        repository: repository222,
        author: author222,
        license: license222,
        bugs: bugs222,
        homepage: homepage222
      };
      function log2(...params) {
        if (localStorage.getItem("debug") === "true")
          console.info(...params);
      }
      if (!window.ELLogger) {
        window.ELLogger = {
          versionTagMap: {}
        };
        window.addEventListener("load", () => {
          const {versionTagMap} = window.ELLogger;
          Object.keys(versionTagMap).forEach((name2222) => {
            logVersionTag({name: name2222, version: versionTagMap[name2222]});
          });
        });
      }
      versionTag2(package_default222);
      function logVersionTag({name: name2222, version: version2222}) {
        log2(`%c${name2222}%cv${version2222}`, "color: #fbf1c7; background: #458588; padding: 2px 4px; border-radius: 3px 0 0 3px;", "color: #fbf1c7; background: #d65d0e; padding: 2px 4px; border-radius: 0 3px 3px 0");
      }
      function versionTag2({name: name2222, version: version2222}) {
        window.ELLogger.versionTagMap[name2222] = version2222;
      }
      function createLogger2(name2222) {
        return (...params) => {
          log2(`${name2222}:
`, ...params);
        };
      }
    });
    __markAsModule22(exports22);
    __export22(exports22, {
      default: () => src_default22
    });
    var import_logger22 = __toModule22(require_bundle32());
    var name22 = "@explorelearning/urls";
    var version22 = "1.10.15";
    var description22 = "Vue plugin for referencing common urls relative to the current domain name";
    var main22 = "dist/bundle.js";
    var types22 = "dist/types/index.d.ts";
    var files22 = [
      "/dist"
    ];
    var scripts22 = {
      build: "node ../../helpers/build.js && npm run markdown",
      "build:types": "npx tsc",
      markdown: "node ./helpers/generateMarkdown.js",
      test: "npx jest"
    };
    var repository22 = {
      type: "git",
      url: "git+https://github.com/ExploreLearning/el-web.git"
    };
    var author22 = "Brian McMillen <brian.mcmillen@explorelearning.com>";
    var license22 = "ISC";
    var bugs22 = {
      url: "https://github.com/ExploreLearning/el-web/issues"
    };
    var devDependencies22 = {
      "@explorelearning/logger": "^1.10.15"
    };
    var peerDependencies22 = {
      "@explorelearning/logger": "^0.0.1"
    };
    var homepage22 = "https://github.com/ExploreLearning/el-web#readme";
    var gitHead22 = "2be1f9dd4fc5e52d0baa2aa16fe56337b0b509aa";
    var package_default22 = {
      name: name22,
      version: version22,
      description: description22,
      main: main22,
      types: types22,
      files: files22,
      scripts: scripts22,
      repository: repository22,
      author: author22,
      license: license22,
      bugs: bugs22,
      devDependencies: devDependencies22,
      peerDependencies: peerDependencies22,
      homepage: homepage22,
      gitHead: gitHead22
    };
    import_logger22.versionTag(package_default22);
    function getBaseUrl() {
      const {host} = window.location;
      const parts = host.split(".");
      const name222 = parts[parts.length - 2];
      return {
        elclouddev: "elclouddev.net",
        elcloudstage: "elcloudstage.net",
        explorelearning: "explorelearning.com"
      }[name222] || "elclouddev.net";
    }
    function getEnvName(baseUrl) {
      return {
        "elclouddev.net": "dev",
        "elcloudstage.net": "stage",
        "explorelearning.com": "prod"
      }[baseUrl || getBaseUrl()] || "dev";
    }
    function getUrls(baseUrl = "") {
      const base = baseUrl || process.env.EL_URLS_BASE || getBaseUrl();
      const services = process.env.EL_URLS_SERVICES || `https://services.${base}`;
      const content = process.env.EL_URLS_CONTENT || `https://content.${base}`;
      const apps = process.env.EL_URLS_APPS || `https://apps.${base}`;
      const platform = process.env.EL_URLS_PLATFORM || `${services}/platform`;
      const platformApi = process.env.EL_URLS_PLATFORM_API || `${platform}/api`;
      const auth = process.env.EL_URLS_AUTH || `${platform}/auth`;
      const reflexApi = process.env.EL_URLS_REFLEX_API || `${services}/reflex/api`;
      const fraxApi = process.env.EL_URLS_FRAX_API || `${services}/frax/api`;
      const fraxSocket = process.env.EL_URLS_FRAX_SOCKET || `${services}/fraxws/api/frax-websocket`;
      const gizmos = process.env.EL_URLS_GIZMOS || `${services}/gizmos`;
      const nextgen = process.env.EL_URLS_NEXTGEN || `${services}/nextgen`;
      const student = process.env.EL_URLS_STUDENT || `${content}/reflex/index.html`;
      const accounts = process.env.EL_URLS_ACCOUNTS || `${apps}/account`;
      const login = process.env.EL_URLS_LOGIN || `${accounts}/login/reflex/teacher`;
      const logout = process.env.EL_URLS_LOGOUT || `${accounts}/reflex/logout`;
      const t4mfLogout = process.env.EL_URLS_T4MF_LOGOUT || "https://www.time4learning.com/App/Resources/Time4MathFactsLogout.aspx";
      const envName = getEnvName(base);
      const nextgenAssets = process.env.EL_URLS_NEXTGEN_ASSETS || `https://s3.amazonaws.com/el-gizmos-${envName}`;
      return {
        accounts,
        apps,
        auth,
        base,
        content,
        fraxApi,
        fraxSocket,
        gizmos,
        login,
        logout,
        nextgen,
        nextgenAssets,
        platform,
        platformApi,
        reflexApi,
        services,
        student,
        t4mfLogout
      };
    }
    var src_default22 = {
      install(Vue5) {
        Vue5.prototype.$urls = getUrls();
      },
      getBaseUrl,
      getUrls,
      getEnvName
    };
  });
  var require_bundle22 = __commonJS2((exports22) => {
    var __defProp22 = Object.defineProperty;
    var __markAsModule22 = (target) => __defProp22(target, "__esModule", {value: true});
    var __export22 = (target, all) => {
      for (var name222 in all)
        __defProp22(target, name222, {get: all[name222], enumerable: true});
    };
    __markAsModule22(exports22);
    __export22(exports22, {
      createLogger: () => createLogger2,
      versionTag: () => versionTag2
    });
    var name22 = "@explorelearning/logger";
    var version22 = "1.10.15";
    var description22 = "Fancy logging in the browser console";
    var main22 = "dist/bundle.js";
    var types22 = "dist/types/index.d.ts";
    var files22 = [
      "/dist"
    ];
    var scripts22 = {
      build: "node ../../helpers/build.js",
      "build:types": "npx tsc",
      test: "npx jest"
    };
    var repository22 = {
      type: "git",
      url: "git+https://github.com/ExploreLearning/el-web.git"
    };
    var author22 = "Brian McMillen <brian.mcmillen@explorelearning.com>";
    var license22 = "ISC";
    var bugs22 = {
      url: "https://github.com/ExploreLearning/el-web/issues"
    };
    var homepage22 = "https://github.com/ExploreLearning/el-web#readme";
    var package_default22 = {
      name: name22,
      version: version22,
      description: description22,
      main: main22,
      types: types22,
      files: files22,
      scripts: scripts22,
      repository: repository22,
      author: author22,
      license: license22,
      bugs: bugs22,
      homepage: homepage22
    };
    function log2(...params) {
      if (localStorage.getItem("debug") === "true")
        console.info(...params);
    }
    if (!window.ELLogger) {
      window.ELLogger = {
        versionTagMap: {}
      };
      window.addEventListener("load", () => {
        const {versionTagMap} = window.ELLogger;
        Object.keys(versionTagMap).forEach((name222) => {
          logVersionTag({name: name222, version: versionTagMap[name222]});
        });
      });
    }
    versionTag2(package_default22);
    function logVersionTag({name: name222, version: version222}) {
      log2(`%c${name222}%cv${version222}`, "color: #fbf1c7; background: #458588; padding: 2px 4px; border-radius: 3px 0 0 3px;", "color: #fbf1c7; background: #d65d0e; padding: 2px 4px; border-radius: 0 3px 3px 0");
    }
    function versionTag2({name: name222, version: version222}) {
      window.ELLogger.versionTagMap[name222] = version222;
    }
    function createLogger2(name222) {
      return (...params) => {
        log2(`${name222}:
`, ...params);
      };
    }
  });
  __markAsModule2(exports2);
  __export2(exports2, {
    default: () => src_default2
  });
  var import_axios2 = __toModule2(require_axios2());
  var import_utils2 = __toModule2(require_bundle());
  var import_urls = __toModule2(require_bundle4());
  var import_axios = __toModule2(require_axios2());
  var CookieRegEx = /(?:(?:^|.*;\s*)el-client\s*=\s*([^;]*).*$)|^.*$/;
  var URLRegEx = /(http.?:\/\/.*\..{2}.?)(\/)(.*)/;
  var ResponseLogger = class {
    constructor(logEndpoint) {
      this.logEndpoint = logEndpoint;
    }
    getFormattedTime() {
      function addZero(x, n) {
        while (x.toString().length < n) {
          x = "0" + x;
        }
        return x.toString();
      }
      const now = new Date();
      const hour = Number(now.getHours());
      const min = addZero(now.getMinutes(), 2);
      const sec = addZero(now.getSeconds(), 2);
      const ms = addZero(now.getMilliseconds(), 3);
      return `${hour}:${min}:${sec}:${ms}`;
    }
    log(response, xclaims, error) {
      return __async2(this, null, function* () {
        var _a, _b;
        try {
          return import_axios.default.post(this.logEndpoint, {
            cookie: document.cookie.replace(CookieRegEx, "$1"),
            clientInfo: navigator.userAgent,
            sessionID: xclaims == null ? void 0 : xclaims.sessionID,
            error,
            trackingEntry: {
              url: (((_a = response == null ? void 0 : response.config) == null ? void 0 : _a.url) || "").replace(URLRegEx, "$2$3"),
              time: this.getFormattedTime(),
              status: response.status,
              error: (_b = response == null ? void 0 : response.body) == null ? void 0 : _b.error
            }
          });
        } catch (e) {
          console.error("failed to log response to backend", e);
          throw e;
        }
      });
    }
  };
  var response_logger_default = ResponseLogger;
  var import_logger2 = __toModule2(require_bundle22());
  var name2 = "@explorelearning/el-authenticator";
  var version2 = "1.10.19";
  var description2 = "Logic for authenticating an application with the auth api";
  var main2 = "dist/bundle.js";
  var types2 = "dist/types/index.d.ts";
  var files2 = [
    "/dist"
  ];
  var scripts2 = {
    build: "node ../../helpers/build.js --external=axios,@explorelearning/utils",
    "build:types": "npx tsc",
    test: "npx jest"
  };
  var repository2 = {
    type: "git",
    url: "git+https://github.com/explorelearning/el-web.git"
  };
  var author2 = "Brian McMillen <brian.mcmillen@explorelearning.com>";
  var license2 = "ISC";
  var bugs2 = {
    url: "https://github.com/explorelearning/el-web/issues"
  };
  var homepage2 = "https://github.com/explorelearning/el-web#readme";
  var devDependencies2 = {
    "@explorelearning/logger": "^1.10.15",
    "@explorelearning/urls": "^1.10.15",
    "@explorelearning/utils": "^1.10.16",
    axios: "^0.21.1"
  };
  var peerDependencies2 = {
    "@explorelearning/logger": "^1.10.7",
    "@explorelearning/urls": "^1.9.8",
    "@explorelearning/utils": "^1.9.8",
    axios: "^0.21.1"
  };
  var gitHead2 = "e474bc856a8276bbc47c73a2a2ee69523319148e";
  var package_default2 = {
    name: name2,
    version: version2,
    description: description2,
    main: main2,
    types: types2,
    files: files2,
    scripts: scripts2,
    repository: repository2,
    author: author2,
    license: license2,
    bugs: bugs2,
    homepage: homepage2,
    devDependencies: devDependencies2,
    peerDependencies: peerDependencies2,
    gitHead: gitHead2
  };
  import_logger2.versionTag(package_default2);
  var log = import_logger2.createLogger("Authenticator");
  var ElAuthenticator2 = class {
    constructor(endpoints) {
      this.isRefreshTurnedOn = true;
      this.refreshing = false;
      const urls = import_urls.default.getUrls();
      this.endpoints = __assign2({
        logging: urls.platform + "/clientLog",
        refresh: urls.platformApi + "/refresh"
      }, endpoints);
      this.responseLogger = new response_logger_default(this.endpoints.logging);
      this.httpsClient = import_axios2.default.create({withCredentials: true});
      this.httpsClient.interceptors.request.use((request) => {
        request.headers["X-CSRFToken"] = this.getToken();
        log("_api.interceptors.request.use", request.headers["X-CSRFToken"]);
        return request;
      });
      this.httpsClient.interceptors.response.use((response) => {
        const error = "The Authenticator should work as expected";
        this.responseLogger.log(response, this.getClaims(), error);
        return response;
      });
    }
    getDelay() {
      const delay = this.getClaims().exp * 1e3 - this.serverTime - performance.now();
      log("_getDelay", delay);
      return delay;
    }
    getQueryStringValue(key) {
      const encodedKey = encodeURIComponent(key).replace(/[.+*]/g, "\\$&");
      const regExp = new RegExp(`^(?:.*[&\\?]${encodedKey}(?:\\=([^&]*))?)?.*$`, "i");
      return decodeURIComponent(window.location.search.replace(regExp, "$1"));
    }
    updateClaims({header}) {
      log("_updateClaims", import_utils2.copy(header));
      this.setClaims(this.decodeClaims(header));
      clearTimeout(this.reauthTimeout);
      const delay = this.getDelay();
      this.reauthTimeout = setTimeout(() => this.authenticate({force: true}), delay);
    }
    getClaims() {
      return __assign2({}, this.claims);
    }
    decodeClaims(data) {
      log("decodeClaims", import_utils2.copy(data));
      const claimsStr = Array.isArray(data) ? data[0] : data;
      return JSON.parse(atob(claimsStr));
    }
    setClaims(claims) {
      log("setClaims", import_utils2.copy(claims));
      this.claims = claims;
    }
    getToken() {
      return this.getClaims().jti;
    }
    clear({logout = false, error = {status: 401}} = {}) {
      log("clear", logout, import_utils2.copy(error));
      clearTimeout(this.reauthTimeout);
      this.claims = null;
      if (!logout) {
        return;
      }
      const auto = this.getQueryStringValue("auto") === "1";
      if (error.status === 401 && !auto && !this.logoutForwardURL) {
        location.href = this.endpoints.login;
        return;
      }
      const {status, data} = error;
      let query = "";
      if (typeof status !== "undefined") {
        query = "?e=error";
        if (data && typeof data.id !== "undefined") {
          query += "-" + data.id;
        }
      }
      if (typeof this.logoutForwardURL !== "undefined") {
        query += query ? "&" : "?";
        query += `f=${encodeURIComponent(this.logoutForwardURL)}`;
      }
      location.href = this.endpoints.logout + query;
    }
    setLogoutForwardURL(url) {
      this.logoutForwardURL = url;
    }
    turnOffRefresh() {
      this.isRefreshTurnedOn = false;
    }
    refresh() {
      return __async2(this, null, function* () {
        log("refresh", this.refreshing);
        if (!this.refreshing && this.isRefreshTurnedOn) {
          this.refreshing = true;
          try {
            const {headers} = yield this.httpsClient.get(this.endpoints.refresh);
            this.updateClaims({header: headers["X-CLAIMS"] || headers["x-claims"]});
          } catch (e) {
            this.clear({logout: true});
          }
          this.refreshing = false;
        }
      });
    }
    authenticate() {
      return __async2(this, arguments, function* ({force = false, logout = true} = {}) {
        log("authenticate", force);
        if (force) {
          this.clear();
        } else if (this.claims) {
          return true;
        }
        try {
          const {data, headers} = yield this.httpsClient.get(this.endpoints.auth);
          if (!this.serverTime) {
            this.serverTime = data.ServerTime.serverTime * 1e3 - performance.now();
          }
          this.updateClaims({header: headers["X-CLAIMS"] || headers["x-claims"]});
        } catch (e) {
          console.warn(`El Authenticator Error:" ${e}`);
          this.clear({logout, error: e.response || {}});
        }
      });
    }
  };
  var src_default2 = ElAuthenticator2;
});

// node_modules/vue/dist/vue.runtime.common.prod.js
var require_vue_runtime_common_prod = __commonJS((exports2, module2) => {
  /*!
   * Vue.js v2.6.12
   * (c) 2014-2020 Evan You
   * Released under the MIT License.
   */
  "use strict";
  var t = Object.freeze({});
  function e(t2) {
    return t2 == null;
  }
  function n(t2) {
    return t2 != null;
  }
  function r(t2) {
    return t2 === true;
  }
  function o(t2) {
    return typeof t2 == "string" || typeof t2 == "number" || typeof t2 == "symbol" || typeof t2 == "boolean";
  }
  function i(t2) {
    return t2 !== null && typeof t2 == "object";
  }
  var a = Object.prototype.toString;
  function s(t2) {
    return a.call(t2) === "[object Object]";
  }
  function c(t2) {
    var e2 = parseFloat(String(t2));
    return e2 >= 0 && Math.floor(e2) === e2 && isFinite(t2);
  }
  function u(t2) {
    return n(t2) && typeof t2.then == "function" && typeof t2.catch == "function";
  }
  function l(t2) {
    return t2 == null ? "" : Array.isArray(t2) || s(t2) && t2.toString === a ? JSON.stringify(t2, null, 2) : String(t2);
  }
  function f(t2) {
    var e2 = parseFloat(t2);
    return isNaN(e2) ? t2 : e2;
  }
  function p(t2, e2) {
    for (var n2 = Object.create(null), r2 = t2.split(","), o2 = 0; o2 < r2.length; o2++)
      n2[r2[o2]] = true;
    return e2 ? function(t3) {
      return n2[t3.toLowerCase()];
    } : function(t3) {
      return n2[t3];
    };
  }
  var d = p("key,ref,slot,slot-scope,is");
  function v(t2, e2) {
    if (t2.length) {
      var n2 = t2.indexOf(e2);
      if (n2 > -1)
        return t2.splice(n2, 1);
    }
  }
  var h = Object.prototype.hasOwnProperty;
  function m(t2, e2) {
    return h.call(t2, e2);
  }
  function y(t2) {
    var e2 = Object.create(null);
    return function(n2) {
      return e2[n2] || (e2[n2] = t2(n2));
    };
  }
  var g = /-(\w)/g;
  var _ = y(function(t2) {
    return t2.replace(g, function(t3, e2) {
      return e2 ? e2.toUpperCase() : "";
    });
  });
  var b = y(function(t2) {
    return t2.charAt(0).toUpperCase() + t2.slice(1);
  });
  var C = /\B([A-Z])/g;
  var $ = y(function(t2) {
    return t2.replace(C, "-$1").toLowerCase();
  });
  var w = Function.prototype.bind ? function(t2, e2) {
    return t2.bind(e2);
  } : function(t2, e2) {
    function n2(n3) {
      var r2 = arguments.length;
      return r2 ? r2 > 1 ? t2.apply(e2, arguments) : t2.call(e2, n3) : t2.call(e2);
    }
    return n2._length = t2.length, n2;
  };
  function A(t2, e2) {
    e2 = e2 || 0;
    for (var n2 = t2.length - e2, r2 = new Array(n2); n2--; )
      r2[n2] = t2[n2 + e2];
    return r2;
  }
  function x(t2, e2) {
    for (var n2 in e2)
      t2[n2] = e2[n2];
    return t2;
  }
  function O(t2) {
    for (var e2 = {}, n2 = 0; n2 < t2.length; n2++)
      t2[n2] && x(e2, t2[n2]);
    return e2;
  }
  function k(t2, e2, n2) {
  }
  var S = function(t2, e2, n2) {
    return false;
  };
  var E = function(t2) {
    return t2;
  };
  function j(t2, e2) {
    if (t2 === e2)
      return true;
    var n2 = i(t2), r2 = i(e2);
    if (!n2 || !r2)
      return !n2 && !r2 && String(t2) === String(e2);
    try {
      var o2 = Array.isArray(t2), a2 = Array.isArray(e2);
      if (o2 && a2)
        return t2.length === e2.length && t2.every(function(t3, n3) {
          return j(t3, e2[n3]);
        });
      if (t2 instanceof Date && e2 instanceof Date)
        return t2.getTime() === e2.getTime();
      if (o2 || a2)
        return false;
      var s2 = Object.keys(t2), c2 = Object.keys(e2);
      return s2.length === c2.length && s2.every(function(n3) {
        return j(t2[n3], e2[n3]);
      });
    } catch (t3) {
      return false;
    }
  }
  function T(t2, e2) {
    for (var n2 = 0; n2 < t2.length; n2++)
      if (j(t2[n2], e2))
        return n2;
    return -1;
  }
  function I(t2) {
    var e2 = false;
    return function() {
      e2 || (e2 = true, t2.apply(this, arguments));
    };
  }
  var D = "data-server-rendered";
  var N = ["component", "directive", "filter"];
  var P = ["beforeCreate", "created", "beforeMount", "mounted", "beforeUpdate", "updated", "beforeDestroy", "destroyed", "activated", "deactivated", "errorCaptured", "serverPrefetch"];
  var L = {optionMergeStrategies: Object.create(null), silent: false, productionTip: false, devtools: false, performance: false, errorHandler: null, warnHandler: null, ignoredElements: [], keyCodes: Object.create(null), isReservedTag: S, isReservedAttr: S, isUnknownElement: S, getTagNamespace: k, parsePlatformTagName: E, mustUseProp: S, async: true, _lifecycleHooks: P};
  function M(t2, e2, n2, r2) {
    Object.defineProperty(t2, e2, {value: n2, enumerable: !!r2, writable: true, configurable: true});
  }
  var F = new RegExp("[^" + /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/.source + ".$_\\d]");
  var R;
  var U = "__proto__" in {};
  var H = typeof window != "undefined";
  var B = typeof WXEnvironment != "undefined" && !!WXEnvironment.platform;
  var V = B && WXEnvironment.platform.toLowerCase();
  var z = H && window.navigator.userAgent.toLowerCase();
  var W = z && /msie|trident/.test(z);
  var q = z && z.indexOf("msie 9.0") > 0;
  var K = z && z.indexOf("edge/") > 0;
  var X = (z && z.indexOf("android"), z && /iphone|ipad|ipod|ios/.test(z) || V === "ios");
  var G = (z && /chrome\/\d+/.test(z), z && /phantomjs/.test(z), z && z.match(/firefox\/(\d+)/));
  var Z = {}.watch;
  var J = false;
  if (H)
    try {
      Q = {};
      Object.defineProperty(Q, "passive", {get: function() {
        J = true;
      }}), window.addEventListener("test-passive", null, Q);
    } catch (t2) {
    }
  var Q;
  var Y = function() {
    return R === void 0 && (R = !H && !B && typeof global != "undefined" && (global.process && global.process.env.VUE_ENV === "server")), R;
  };
  var tt = H && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
  function et(t2) {
    return typeof t2 == "function" && /native code/.test(t2.toString());
  }
  var nt;
  var rt = typeof Symbol != "undefined" && et(Symbol) && typeof Reflect != "undefined" && et(Reflect.ownKeys);
  nt = typeof Set != "undefined" && et(Set) ? Set : function() {
    function t2() {
      this.set = Object.create(null);
    }
    return t2.prototype.has = function(t3) {
      return this.set[t3] === true;
    }, t2.prototype.add = function(t3) {
      this.set[t3] = true;
    }, t2.prototype.clear = function() {
      this.set = Object.create(null);
    }, t2;
  }();
  var ot = k;
  var it = 0;
  var at = function() {
    this.id = it++, this.subs = [];
  };
  at.prototype.addSub = function(t2) {
    this.subs.push(t2);
  }, at.prototype.removeSub = function(t2) {
    v(this.subs, t2);
  }, at.prototype.depend = function() {
    at.target && at.target.addDep(this);
  }, at.prototype.notify = function() {
    for (var t2 = this.subs.slice(), e2 = 0, n2 = t2.length; e2 < n2; e2++)
      t2[e2].update();
  }, at.target = null;
  var st = [];
  function ct(t2) {
    st.push(t2), at.target = t2;
  }
  function ut() {
    st.pop(), at.target = st[st.length - 1];
  }
  var lt = function(t2, e2, n2, r2, o2, i2, a2, s2) {
    this.tag = t2, this.data = e2, this.children = n2, this.text = r2, this.elm = o2, this.ns = void 0, this.context = i2, this.fnContext = void 0, this.fnOptions = void 0, this.fnScopeId = void 0, this.key = e2 && e2.key, this.componentOptions = a2, this.componentInstance = void 0, this.parent = void 0, this.raw = false, this.isStatic = false, this.isRootInsert = true, this.isComment = false, this.isCloned = false, this.isOnce = false, this.asyncFactory = s2, this.asyncMeta = void 0, this.isAsyncPlaceholder = false;
  };
  var ft = {child: {configurable: true}};
  ft.child.get = function() {
    return this.componentInstance;
  }, Object.defineProperties(lt.prototype, ft);
  var pt = function(t2) {
    t2 === void 0 && (t2 = "");
    var e2 = new lt();
    return e2.text = t2, e2.isComment = true, e2;
  };
  function dt(t2) {
    return new lt(void 0, void 0, void 0, String(t2));
  }
  function vt(t2) {
    var e2 = new lt(t2.tag, t2.data, t2.children && t2.children.slice(), t2.text, t2.elm, t2.context, t2.componentOptions, t2.asyncFactory);
    return e2.ns = t2.ns, e2.isStatic = t2.isStatic, e2.key = t2.key, e2.isComment = t2.isComment, e2.fnContext = t2.fnContext, e2.fnOptions = t2.fnOptions, e2.fnScopeId = t2.fnScopeId, e2.asyncMeta = t2.asyncMeta, e2.isCloned = true, e2;
  }
  var ht = Array.prototype;
  var mt = Object.create(ht);
  ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"].forEach(function(t2) {
    var e2 = ht[t2];
    M(mt, t2, function() {
      for (var n2 = [], r2 = arguments.length; r2--; )
        n2[r2] = arguments[r2];
      var o2, i2 = e2.apply(this, n2), a2 = this.__ob__;
      switch (t2) {
        case "push":
        case "unshift":
          o2 = n2;
          break;
        case "splice":
          o2 = n2.slice(2);
      }
      return o2 && a2.observeArray(o2), a2.dep.notify(), i2;
    });
  });
  var yt = Object.getOwnPropertyNames(mt);
  var gt = true;
  function _t(t2) {
    gt = t2;
  }
  var bt = function(t2) {
    var e2;
    this.value = t2, this.dep = new at(), this.vmCount = 0, M(t2, "__ob__", this), Array.isArray(t2) ? (U ? (e2 = mt, t2.__proto__ = e2) : function(t3, e3, n2) {
      for (var r2 = 0, o2 = n2.length; r2 < o2; r2++) {
        var i2 = n2[r2];
        M(t3, i2, e3[i2]);
      }
    }(t2, mt, yt), this.observeArray(t2)) : this.walk(t2);
  };
  function Ct(t2, e2) {
    var n2;
    if (i(t2) && !(t2 instanceof lt))
      return m(t2, "__ob__") && t2.__ob__ instanceof bt ? n2 = t2.__ob__ : gt && !Y() && (Array.isArray(t2) || s(t2)) && Object.isExtensible(t2) && !t2._isVue && (n2 = new bt(t2)), e2 && n2 && n2.vmCount++, n2;
  }
  function $t(t2, e2, n2, r2, o2) {
    var i2 = new at(), a2 = Object.getOwnPropertyDescriptor(t2, e2);
    if (!a2 || a2.configurable !== false) {
      var s2 = a2 && a2.get, c2 = a2 && a2.set;
      s2 && !c2 || arguments.length !== 2 || (n2 = t2[e2]);
      var u2 = !o2 && Ct(n2);
      Object.defineProperty(t2, e2, {enumerable: true, configurable: true, get: function() {
        var e3 = s2 ? s2.call(t2) : n2;
        return at.target && (i2.depend(), u2 && (u2.dep.depend(), Array.isArray(e3) && function t3(e4) {
          for (var n3 = void 0, r3 = 0, o3 = e4.length; r3 < o3; r3++)
            (n3 = e4[r3]) && n3.__ob__ && n3.__ob__.dep.depend(), Array.isArray(n3) && t3(n3);
        }(e3))), e3;
      }, set: function(e3) {
        var r3 = s2 ? s2.call(t2) : n2;
        e3 === r3 || e3 != e3 && r3 != r3 || s2 && !c2 || (c2 ? c2.call(t2, e3) : n2 = e3, u2 = !o2 && Ct(e3), i2.notify());
      }});
    }
  }
  function wt(t2, e2, n2) {
    if (Array.isArray(t2) && c(e2))
      return t2.length = Math.max(t2.length, e2), t2.splice(e2, 1, n2), n2;
    if (e2 in t2 && !(e2 in Object.prototype))
      return t2[e2] = n2, n2;
    var r2 = t2.__ob__;
    return t2._isVue || r2 && r2.vmCount ? n2 : r2 ? ($t(r2.value, e2, n2), r2.dep.notify(), n2) : (t2[e2] = n2, n2);
  }
  function At(t2, e2) {
    if (Array.isArray(t2) && c(e2))
      t2.splice(e2, 1);
    else {
      var n2 = t2.__ob__;
      t2._isVue || n2 && n2.vmCount || m(t2, e2) && (delete t2[e2], n2 && n2.dep.notify());
    }
  }
  bt.prototype.walk = function(t2) {
    for (var e2 = Object.keys(t2), n2 = 0; n2 < e2.length; n2++)
      $t(t2, e2[n2]);
  }, bt.prototype.observeArray = function(t2) {
    for (var e2 = 0, n2 = t2.length; e2 < n2; e2++)
      Ct(t2[e2]);
  };
  var xt = L.optionMergeStrategies;
  function Ot(t2, e2) {
    if (!e2)
      return t2;
    for (var n2, r2, o2, i2 = rt ? Reflect.ownKeys(e2) : Object.keys(e2), a2 = 0; a2 < i2.length; a2++)
      (n2 = i2[a2]) !== "__ob__" && (r2 = t2[n2], o2 = e2[n2], m(t2, n2) ? r2 !== o2 && s(r2) && s(o2) && Ot(r2, o2) : wt(t2, n2, o2));
    return t2;
  }
  function kt(t2, e2, n2) {
    return n2 ? function() {
      var r2 = typeof e2 == "function" ? e2.call(n2, n2) : e2, o2 = typeof t2 == "function" ? t2.call(n2, n2) : t2;
      return r2 ? Ot(r2, o2) : o2;
    } : e2 ? t2 ? function() {
      return Ot(typeof e2 == "function" ? e2.call(this, this) : e2, typeof t2 == "function" ? t2.call(this, this) : t2);
    } : e2 : t2;
  }
  function St(t2, e2) {
    var n2 = e2 ? t2 ? t2.concat(e2) : Array.isArray(e2) ? e2 : [e2] : t2;
    return n2 ? function(t3) {
      for (var e3 = [], n3 = 0; n3 < t3.length; n3++)
        e3.indexOf(t3[n3]) === -1 && e3.push(t3[n3]);
      return e3;
    }(n2) : n2;
  }
  function Et(t2, e2, n2, r2) {
    var o2 = Object.create(t2 || null);
    return e2 ? x(o2, e2) : o2;
  }
  xt.data = function(t2, e2, n2) {
    return n2 ? kt(t2, e2, n2) : e2 && typeof e2 != "function" ? t2 : kt(t2, e2);
  }, P.forEach(function(t2) {
    xt[t2] = St;
  }), N.forEach(function(t2) {
    xt[t2 + "s"] = Et;
  }), xt.watch = function(t2, e2, n2, r2) {
    if (t2 === Z && (t2 = void 0), e2 === Z && (e2 = void 0), !e2)
      return Object.create(t2 || null);
    if (!t2)
      return e2;
    var o2 = {};
    for (var i2 in x(o2, t2), e2) {
      var a2 = o2[i2], s2 = e2[i2];
      a2 && !Array.isArray(a2) && (a2 = [a2]), o2[i2] = a2 ? a2.concat(s2) : Array.isArray(s2) ? s2 : [s2];
    }
    return o2;
  }, xt.props = xt.methods = xt.inject = xt.computed = function(t2, e2, n2, r2) {
    if (!t2)
      return e2;
    var o2 = Object.create(null);
    return x(o2, t2), e2 && x(o2, e2), o2;
  }, xt.provide = kt;
  var jt = function(t2, e2) {
    return e2 === void 0 ? t2 : e2;
  };
  function Tt(t2, e2, n2) {
    if (typeof e2 == "function" && (e2 = e2.options), function(t3, e3) {
      var n3 = t3.props;
      if (n3) {
        var r3, o3, i3 = {};
        if (Array.isArray(n3))
          for (r3 = n3.length; r3--; )
            typeof (o3 = n3[r3]) == "string" && (i3[_(o3)] = {type: null});
        else if (s(n3))
          for (var a3 in n3)
            o3 = n3[a3], i3[_(a3)] = s(o3) ? o3 : {type: o3};
        t3.props = i3;
      }
    }(e2), function(t3, e3) {
      var n3 = t3.inject;
      if (n3) {
        var r3 = t3.inject = {};
        if (Array.isArray(n3))
          for (var o3 = 0; o3 < n3.length; o3++)
            r3[n3[o3]] = {from: n3[o3]};
        else if (s(n3))
          for (var i3 in n3) {
            var a3 = n3[i3];
            r3[i3] = s(a3) ? x({from: i3}, a3) : {from: a3};
          }
      }
    }(e2), function(t3) {
      var e3 = t3.directives;
      if (e3)
        for (var n3 in e3) {
          var r3 = e3[n3];
          typeof r3 == "function" && (e3[n3] = {bind: r3, update: r3});
        }
    }(e2), !e2._base && (e2.extends && (t2 = Tt(t2, e2.extends, n2)), e2.mixins))
      for (var r2 = 0, o2 = e2.mixins.length; r2 < o2; r2++)
        t2 = Tt(t2, e2.mixins[r2], n2);
    var i2, a2 = {};
    for (i2 in t2)
      c2(i2);
    for (i2 in e2)
      m(t2, i2) || c2(i2);
    function c2(r3) {
      var o3 = xt[r3] || jt;
      a2[r3] = o3(t2[r3], e2[r3], n2, r3);
    }
    return a2;
  }
  function It(t2, e2, n2, r2) {
    if (typeof n2 == "string") {
      var o2 = t2[e2];
      if (m(o2, n2))
        return o2[n2];
      var i2 = _(n2);
      if (m(o2, i2))
        return o2[i2];
      var a2 = b(i2);
      return m(o2, a2) ? o2[a2] : o2[n2] || o2[i2] || o2[a2];
    }
  }
  function Dt(t2, e2, n2, r2) {
    var o2 = e2[t2], i2 = !m(n2, t2), a2 = n2[t2], s2 = Lt(Boolean, o2.type);
    if (s2 > -1) {
      if (i2 && !m(o2, "default"))
        a2 = false;
      else if (a2 === "" || a2 === $(t2)) {
        var c2 = Lt(String, o2.type);
        (c2 < 0 || s2 < c2) && (a2 = true);
      }
    }
    if (a2 === void 0) {
      a2 = function(t3, e3, n3) {
        if (!m(e3, "default"))
          return;
        var r3 = e3.default;
        if (t3 && t3.$options.propsData && t3.$options.propsData[n3] === void 0 && t3._props[n3] !== void 0)
          return t3._props[n3];
        return typeof r3 == "function" && Nt(e3.type) !== "Function" ? r3.call(t3) : r3;
      }(r2, o2, t2);
      var u2 = gt;
      _t(true), Ct(a2), _t(u2);
    }
    return a2;
  }
  function Nt(t2) {
    var e2 = t2 && t2.toString().match(/^\s*function (\w+)/);
    return e2 ? e2[1] : "";
  }
  function Pt(t2, e2) {
    return Nt(t2) === Nt(e2);
  }
  function Lt(t2, e2) {
    if (!Array.isArray(e2))
      return Pt(e2, t2) ? 0 : -1;
    for (var n2 = 0, r2 = e2.length; n2 < r2; n2++)
      if (Pt(e2[n2], t2))
        return n2;
    return -1;
  }
  function Mt(t2, e2, n2) {
    ct();
    try {
      if (e2)
        for (var r2 = e2; r2 = r2.$parent; ) {
          var o2 = r2.$options.errorCaptured;
          if (o2)
            for (var i2 = 0; i2 < o2.length; i2++)
              try {
                if (o2[i2].call(r2, t2, e2, n2) === false)
                  return;
              } catch (t3) {
                Rt(t3, r2, "errorCaptured hook");
              }
        }
      Rt(t2, e2, n2);
    } finally {
      ut();
    }
  }
  function Ft(t2, e2, n2, r2, o2) {
    var i2;
    try {
      (i2 = n2 ? t2.apply(e2, n2) : t2.call(e2)) && !i2._isVue && u(i2) && !i2._handled && (i2.catch(function(t3) {
        return Mt(t3, r2, o2 + " (Promise/async)");
      }), i2._handled = true);
    } catch (t3) {
      Mt(t3, r2, o2);
    }
    return i2;
  }
  function Rt(t2, e2, n2) {
    if (L.errorHandler)
      try {
        return L.errorHandler.call(null, t2, e2, n2);
      } catch (e3) {
        e3 !== t2 && Ut(e3, null, "config.errorHandler");
      }
    Ut(t2, e2, n2);
  }
  function Ut(t2, e2, n2) {
    if (!H && !B || typeof console == "undefined")
      throw t2;
    console.error(t2);
  }
  var Ht;
  var Bt = false;
  var Vt = [];
  var zt = false;
  function Wt() {
    zt = false;
    var t2 = Vt.slice(0);
    Vt.length = 0;
    for (var e2 = 0; e2 < t2.length; e2++)
      t2[e2]();
  }
  if (typeof Promise != "undefined" && et(Promise)) {
    qt = Promise.resolve();
    Ht = function() {
      qt.then(Wt), X && setTimeout(k);
    }, Bt = true;
  } else if (W || typeof MutationObserver == "undefined" || !et(MutationObserver) && MutationObserver.toString() !== "[object MutationObserverConstructor]")
    Ht = typeof setImmediate != "undefined" && et(setImmediate) ? function() {
      setImmediate(Wt);
    } : function() {
      setTimeout(Wt, 0);
    };
  else {
    Kt = 1, Xt = new MutationObserver(Wt), Gt = document.createTextNode(String(Kt));
    Xt.observe(Gt, {characterData: true}), Ht = function() {
      Kt = (Kt + 1) % 2, Gt.data = String(Kt);
    }, Bt = true;
  }
  var qt;
  var Kt;
  var Xt;
  var Gt;
  function Zt(t2, e2) {
    var n2;
    if (Vt.push(function() {
      if (t2)
        try {
          t2.call(e2);
        } catch (t3) {
          Mt(t3, e2, "nextTick");
        }
      else
        n2 && n2(e2);
    }), zt || (zt = true, Ht()), !t2 && typeof Promise != "undefined")
      return new Promise(function(t3) {
        n2 = t3;
      });
  }
  var Jt = new nt();
  function Qt(t2) {
    !function t3(e2, n2) {
      var r2, o2;
      var a2 = Array.isArray(e2);
      if (!a2 && !i(e2) || Object.isFrozen(e2) || e2 instanceof lt)
        return;
      if (e2.__ob__) {
        var s2 = e2.__ob__.dep.id;
        if (n2.has(s2))
          return;
        n2.add(s2);
      }
      if (a2)
        for (r2 = e2.length; r2--; )
          t3(e2[r2], n2);
      else
        for (o2 = Object.keys(e2), r2 = o2.length; r2--; )
          t3(e2[o2[r2]], n2);
    }(t2, Jt), Jt.clear();
  }
  var Yt = y(function(t2) {
    var e2 = t2.charAt(0) === "&", n2 = (t2 = e2 ? t2.slice(1) : t2).charAt(0) === "~", r2 = (t2 = n2 ? t2.slice(1) : t2).charAt(0) === "!";
    return {name: t2 = r2 ? t2.slice(1) : t2, once: n2, capture: r2, passive: e2};
  });
  function te(t2, e2) {
    function n2() {
      var t3 = arguments, r2 = n2.fns;
      if (!Array.isArray(r2))
        return Ft(r2, null, arguments, e2, "v-on handler");
      for (var o2 = r2.slice(), i2 = 0; i2 < o2.length; i2++)
        Ft(o2[i2], null, t3, e2, "v-on handler");
    }
    return n2.fns = t2, n2;
  }
  function ee(t2, n2, o2, i2, a2, s2) {
    var c2, u2, l2, f2;
    for (c2 in t2)
      u2 = t2[c2], l2 = n2[c2], f2 = Yt(c2), e(u2) || (e(l2) ? (e(u2.fns) && (u2 = t2[c2] = te(u2, s2)), r(f2.once) && (u2 = t2[c2] = a2(f2.name, u2, f2.capture)), o2(f2.name, u2, f2.capture, f2.passive, f2.params)) : u2 !== l2 && (l2.fns = u2, t2[c2] = l2));
    for (c2 in n2)
      e(t2[c2]) && i2((f2 = Yt(c2)).name, n2[c2], f2.capture);
  }
  function ne(t2, o2, i2) {
    var a2;
    t2 instanceof lt && (t2 = t2.data.hook || (t2.data.hook = {}));
    var s2 = t2[o2];
    function c2() {
      i2.apply(this, arguments), v(a2.fns, c2);
    }
    e(s2) ? a2 = te([c2]) : n(s2.fns) && r(s2.merged) ? (a2 = s2).fns.push(c2) : a2 = te([s2, c2]), a2.merged = true, t2[o2] = a2;
  }
  function re(t2, e2, r2, o2, i2) {
    if (n(e2)) {
      if (m(e2, r2))
        return t2[r2] = e2[r2], i2 || delete e2[r2], true;
      if (m(e2, o2))
        return t2[r2] = e2[o2], i2 || delete e2[o2], true;
    }
    return false;
  }
  function oe(t2) {
    return o(t2) ? [dt(t2)] : Array.isArray(t2) ? function t3(i2, a2) {
      var s2 = [];
      var c2, u2, l2, f2;
      for (c2 = 0; c2 < i2.length; c2++)
        e(u2 = i2[c2]) || typeof u2 == "boolean" || (l2 = s2.length - 1, f2 = s2[l2], Array.isArray(u2) ? u2.length > 0 && (ie((u2 = t3(u2, (a2 || "") + "_" + c2))[0]) && ie(f2) && (s2[l2] = dt(f2.text + u2[0].text), u2.shift()), s2.push.apply(s2, u2)) : o(u2) ? ie(f2) ? s2[l2] = dt(f2.text + u2) : u2 !== "" && s2.push(dt(u2)) : ie(u2) && ie(f2) ? s2[l2] = dt(f2.text + u2.text) : (r(i2._isVList) && n(u2.tag) && e(u2.key) && n(a2) && (u2.key = "__vlist" + a2 + "_" + c2 + "__"), s2.push(u2)));
      return s2;
    }(t2) : void 0;
  }
  function ie(t2) {
    return n(t2) && n(t2.text) && t2.isComment === false;
  }
  function ae(t2, e2) {
    if (t2) {
      for (var n2 = Object.create(null), r2 = rt ? Reflect.ownKeys(t2) : Object.keys(t2), o2 = 0; o2 < r2.length; o2++) {
        var i2 = r2[o2];
        if (i2 !== "__ob__") {
          for (var a2 = t2[i2].from, s2 = e2; s2; ) {
            if (s2._provided && m(s2._provided, a2)) {
              n2[i2] = s2._provided[a2];
              break;
            }
            s2 = s2.$parent;
          }
          if (!s2 && "default" in t2[i2]) {
            var c2 = t2[i2].default;
            n2[i2] = typeof c2 == "function" ? c2.call(e2) : c2;
          }
        }
      }
      return n2;
    }
  }
  function se(t2, e2) {
    if (!t2 || !t2.length)
      return {};
    for (var n2 = {}, r2 = 0, o2 = t2.length; r2 < o2; r2++) {
      var i2 = t2[r2], a2 = i2.data;
      if (a2 && a2.attrs && a2.attrs.slot && delete a2.attrs.slot, i2.context !== e2 && i2.fnContext !== e2 || !a2 || a2.slot == null)
        (n2.default || (n2.default = [])).push(i2);
      else {
        var s2 = a2.slot, c2 = n2[s2] || (n2[s2] = []);
        i2.tag === "template" ? c2.push.apply(c2, i2.children || []) : c2.push(i2);
      }
    }
    for (var u2 in n2)
      n2[u2].every(ce) && delete n2[u2];
    return n2;
  }
  function ce(t2) {
    return t2.isComment && !t2.asyncFactory || t2.text === " ";
  }
  function ue(e2, n2, r2) {
    var o2, i2 = Object.keys(n2).length > 0, a2 = e2 ? !!e2.$stable : !i2, s2 = e2 && e2.$key;
    if (e2) {
      if (e2._normalized)
        return e2._normalized;
      if (a2 && r2 && r2 !== t && s2 === r2.$key && !i2 && !r2.$hasNormal)
        return r2;
      for (var c2 in o2 = {}, e2)
        e2[c2] && c2[0] !== "$" && (o2[c2] = le(n2, c2, e2[c2]));
    } else
      o2 = {};
    for (var u2 in n2)
      u2 in o2 || (o2[u2] = fe(n2, u2));
    return e2 && Object.isExtensible(e2) && (e2._normalized = o2), M(o2, "$stable", a2), M(o2, "$key", s2), M(o2, "$hasNormal", i2), o2;
  }
  function le(t2, e2, n2) {
    var r2 = function() {
      var t3 = arguments.length ? n2.apply(null, arguments) : n2({});
      return (t3 = t3 && typeof t3 == "object" && !Array.isArray(t3) ? [t3] : oe(t3)) && (t3.length === 0 || t3.length === 1 && t3[0].isComment) ? void 0 : t3;
    };
    return n2.proxy && Object.defineProperty(t2, e2, {get: r2, enumerable: true, configurable: true}), r2;
  }
  function fe(t2, e2) {
    return function() {
      return t2[e2];
    };
  }
  function pe(t2, e2) {
    var r2, o2, a2, s2, c2;
    if (Array.isArray(t2) || typeof t2 == "string")
      for (r2 = new Array(t2.length), o2 = 0, a2 = t2.length; o2 < a2; o2++)
        r2[o2] = e2(t2[o2], o2);
    else if (typeof t2 == "number")
      for (r2 = new Array(t2), o2 = 0; o2 < t2; o2++)
        r2[o2] = e2(o2 + 1, o2);
    else if (i(t2))
      if (rt && t2[Symbol.iterator]) {
        r2 = [];
        for (var u2 = t2[Symbol.iterator](), l2 = u2.next(); !l2.done; )
          r2.push(e2(l2.value, r2.length)), l2 = u2.next();
      } else
        for (s2 = Object.keys(t2), r2 = new Array(s2.length), o2 = 0, a2 = s2.length; o2 < a2; o2++)
          c2 = s2[o2], r2[o2] = e2(t2[c2], c2, o2);
    return n(r2) || (r2 = []), r2._isVList = true, r2;
  }
  function de(t2, e2, n2, r2) {
    var o2, i2 = this.$scopedSlots[t2];
    i2 ? (n2 = n2 || {}, r2 && (n2 = x(x({}, r2), n2)), o2 = i2(n2) || e2) : o2 = this.$slots[t2] || e2;
    var a2 = n2 && n2.slot;
    return a2 ? this.$createElement("template", {slot: a2}, o2) : o2;
  }
  function ve(t2) {
    return It(this.$options, "filters", t2) || E;
  }
  function he(t2, e2) {
    return Array.isArray(t2) ? t2.indexOf(e2) === -1 : t2 !== e2;
  }
  function me(t2, e2, n2, r2, o2) {
    var i2 = L.keyCodes[e2] || n2;
    return o2 && r2 && !L.keyCodes[e2] ? he(o2, r2) : i2 ? he(i2, t2) : r2 ? $(r2) !== e2 : void 0;
  }
  function ye(t2, e2, n2, r2, o2) {
    if (n2)
      if (i(n2)) {
        var a2;
        Array.isArray(n2) && (n2 = O(n2));
        var s2 = function(i2) {
          if (i2 === "class" || i2 === "style" || d(i2))
            a2 = t2;
          else {
            var s3 = t2.attrs && t2.attrs.type;
            a2 = r2 || L.mustUseProp(e2, s3, i2) ? t2.domProps || (t2.domProps = {}) : t2.attrs || (t2.attrs = {});
          }
          var c3 = _(i2), u2 = $(i2);
          c3 in a2 || u2 in a2 || (a2[i2] = n2[i2], o2 && ((t2.on || (t2.on = {}))["update:" + i2] = function(t3) {
            n2[i2] = t3;
          }));
        };
        for (var c2 in n2)
          s2(c2);
      } else
        ;
    return t2;
  }
  function ge(t2, e2) {
    var n2 = this._staticTrees || (this._staticTrees = []), r2 = n2[t2];
    return r2 && !e2 ? r2 : (be(r2 = n2[t2] = this.$options.staticRenderFns[t2].call(this._renderProxy, null, this), "__static__" + t2, false), r2);
  }
  function _e(t2, e2, n2) {
    return be(t2, "__once__" + e2 + (n2 ? "_" + n2 : ""), true), t2;
  }
  function be(t2, e2, n2) {
    if (Array.isArray(t2))
      for (var r2 = 0; r2 < t2.length; r2++)
        t2[r2] && typeof t2[r2] != "string" && Ce(t2[r2], e2 + "_" + r2, n2);
    else
      Ce(t2, e2, n2);
  }
  function Ce(t2, e2, n2) {
    t2.isStatic = true, t2.key = e2, t2.isOnce = n2;
  }
  function $e(t2, e2) {
    if (e2)
      if (s(e2)) {
        var n2 = t2.on = t2.on ? x({}, t2.on) : {};
        for (var r2 in e2) {
          var o2 = n2[r2], i2 = e2[r2];
          n2[r2] = o2 ? [].concat(o2, i2) : i2;
        }
      } else
        ;
    return t2;
  }
  function we(t2, e2, n2, r2) {
    e2 = e2 || {$stable: !n2};
    for (var o2 = 0; o2 < t2.length; o2++) {
      var i2 = t2[o2];
      Array.isArray(i2) ? we(i2, e2, n2) : i2 && (i2.proxy && (i2.fn.proxy = true), e2[i2.key] = i2.fn);
    }
    return r2 && (e2.$key = r2), e2;
  }
  function Ae(t2, e2) {
    for (var n2 = 0; n2 < e2.length; n2 += 2) {
      var r2 = e2[n2];
      typeof r2 == "string" && r2 && (t2[e2[n2]] = e2[n2 + 1]);
    }
    return t2;
  }
  function xe(t2, e2) {
    return typeof t2 == "string" ? e2 + t2 : t2;
  }
  function Oe(t2) {
    t2._o = _e, t2._n = f, t2._s = l, t2._l = pe, t2._t = de, t2._q = j, t2._i = T, t2._m = ge, t2._f = ve, t2._k = me, t2._b = ye, t2._v = dt, t2._e = pt, t2._u = we, t2._g = $e, t2._d = Ae, t2._p = xe;
  }
  function ke(e2, n2, o2, i2, a2) {
    var s2, c2 = this, u2 = a2.options;
    m(i2, "_uid") ? (s2 = Object.create(i2))._original = i2 : (s2 = i2, i2 = i2._original);
    var l2 = r(u2._compiled), f2 = !l2;
    this.data = e2, this.props = n2, this.children = o2, this.parent = i2, this.listeners = e2.on || t, this.injections = ae(u2.inject, i2), this.slots = function() {
      return c2.$slots || ue(e2.scopedSlots, c2.$slots = se(o2, i2)), c2.$slots;
    }, Object.defineProperty(this, "scopedSlots", {enumerable: true, get: function() {
      return ue(e2.scopedSlots, this.slots());
    }}), l2 && (this.$options = u2, this.$slots = this.slots(), this.$scopedSlots = ue(e2.scopedSlots, this.$slots)), u2._scopeId ? this._c = function(t2, e3, n3, r2) {
      var o3 = Le(s2, t2, e3, n3, r2, f2);
      return o3 && !Array.isArray(o3) && (o3.fnScopeId = u2._scopeId, o3.fnContext = i2), o3;
    } : this._c = function(t2, e3, n3, r2) {
      return Le(s2, t2, e3, n3, r2, f2);
    };
  }
  function Se(t2, e2, n2, r2, o2) {
    var i2 = vt(t2);
    return i2.fnContext = n2, i2.fnOptions = r2, e2.slot && ((i2.data || (i2.data = {})).slot = e2.slot), i2;
  }
  function Ee(t2, e2) {
    for (var n2 in e2)
      t2[_(n2)] = e2[n2];
  }
  Oe(ke.prototype);
  var je = {init: function(t2, e2) {
    if (t2.componentInstance && !t2.componentInstance._isDestroyed && t2.data.keepAlive) {
      var r2 = t2;
      je.prepatch(r2, r2);
    } else {
      (t2.componentInstance = function(t3, e3) {
        var r3 = {_isComponent: true, _parentVnode: t3, parent: e3}, o2 = t3.data.inlineTemplate;
        n(o2) && (r3.render = o2.render, r3.staticRenderFns = o2.staticRenderFns);
        return new t3.componentOptions.Ctor(r3);
      }(t2, qe)).$mount(e2 ? t2.elm : void 0, e2);
    }
  }, prepatch: function(e2, n2) {
    var r2 = n2.componentOptions;
    !function(e3, n3, r3, o2, i2) {
      var a2 = o2.data.scopedSlots, s2 = e3.$scopedSlots, c2 = !!(a2 && !a2.$stable || s2 !== t && !s2.$stable || a2 && e3.$scopedSlots.$key !== a2.$key), u2 = !!(i2 || e3.$options._renderChildren || c2);
      e3.$options._parentVnode = o2, e3.$vnode = o2, e3._vnode && (e3._vnode.parent = o2);
      if (e3.$options._renderChildren = i2, e3.$attrs = o2.data.attrs || t, e3.$listeners = r3 || t, n3 && e3.$options.props) {
        _t(false);
        for (var l2 = e3._props, f2 = e3.$options._propKeys || [], p2 = 0; p2 < f2.length; p2++) {
          var d2 = f2[p2], v2 = e3.$options.props;
          l2[d2] = Dt(d2, v2, n3, e3);
        }
        _t(true), e3.$options.propsData = n3;
      }
      r3 = r3 || t;
      var h2 = e3.$options._parentListeners;
      e3.$options._parentListeners = r3, We(e3, r3, h2), u2 && (e3.$slots = se(i2, o2.context), e3.$forceUpdate());
    }(n2.componentInstance = e2.componentInstance, r2.propsData, r2.listeners, n2, r2.children);
  }, insert: function(t2) {
    var e2, n2 = t2.context, r2 = t2.componentInstance;
    r2._isMounted || (r2._isMounted = true, Ze(r2, "mounted")), t2.data.keepAlive && (n2._isMounted ? ((e2 = r2)._inactive = false, Qe.push(e2)) : Ge(r2, true));
  }, destroy: function(t2) {
    var e2 = t2.componentInstance;
    e2._isDestroyed || (t2.data.keepAlive ? function t3(e3, n2) {
      if (n2 && (e3._directInactive = true, Xe(e3)))
        return;
      if (!e3._inactive) {
        e3._inactive = true;
        for (var r2 = 0; r2 < e3.$children.length; r2++)
          t3(e3.$children[r2]);
        Ze(e3, "deactivated");
      }
    }(e2, true) : e2.$destroy());
  }};
  var Te = Object.keys(je);
  function Ie(o2, a2, s2, c2, l2) {
    if (!e(o2)) {
      var f2 = s2.$options._base;
      if (i(o2) && (o2 = f2.extend(o2)), typeof o2 == "function") {
        var p2;
        if (e(o2.cid) && (o2 = function(t2, o3) {
          if (r(t2.error) && n(t2.errorComp))
            return t2.errorComp;
          if (n(t2.resolved))
            return t2.resolved;
          var a3 = Fe;
          a3 && n(t2.owners) && t2.owners.indexOf(a3) === -1 && t2.owners.push(a3);
          if (r(t2.loading) && n(t2.loadingComp))
            return t2.loadingComp;
          if (a3 && !n(t2.owners)) {
            var s3 = t2.owners = [a3], c3 = true, l3 = null, f3 = null;
            a3.$on("hook:destroyed", function() {
              return v(s3, a3);
            });
            var p3 = function(t3) {
              for (var e2 = 0, n2 = s3.length; e2 < n2; e2++)
                s3[e2].$forceUpdate();
              t3 && (s3.length = 0, l3 !== null && (clearTimeout(l3), l3 = null), f3 !== null && (clearTimeout(f3), f3 = null));
            }, d3 = I(function(e2) {
              t2.resolved = Re(e2, o3), c3 ? s3.length = 0 : p3(true);
            }), h3 = I(function(e2) {
              n(t2.errorComp) && (t2.error = true, p3(true));
            }), m3 = t2(d3, h3);
            return i(m3) && (u(m3) ? e(t2.resolved) && m3.then(d3, h3) : u(m3.component) && (m3.component.then(d3, h3), n(m3.error) && (t2.errorComp = Re(m3.error, o3)), n(m3.loading) && (t2.loadingComp = Re(m3.loading, o3), m3.delay === 0 ? t2.loading = true : l3 = setTimeout(function() {
              l3 = null, e(t2.resolved) && e(t2.error) && (t2.loading = true, p3(false));
            }, m3.delay || 200)), n(m3.timeout) && (f3 = setTimeout(function() {
              f3 = null, e(t2.resolved) && h3(null);
            }, m3.timeout)))), c3 = false, t2.loading ? t2.loadingComp : t2.resolved;
          }
        }(p2 = o2, f2)) === void 0)
          return function(t2, e2, n2, r2, o3) {
            var i2 = pt();
            return i2.asyncFactory = t2, i2.asyncMeta = {data: e2, context: n2, children: r2, tag: o3}, i2;
          }(p2, a2, s2, c2, l2);
        a2 = a2 || {}, _n(o2), n(a2.model) && function(t2, e2) {
          var r2 = t2.model && t2.model.prop || "value", o3 = t2.model && t2.model.event || "input";
          (e2.attrs || (e2.attrs = {}))[r2] = e2.model.value;
          var i2 = e2.on || (e2.on = {}), a3 = i2[o3], s3 = e2.model.callback;
          n(a3) ? (Array.isArray(a3) ? a3.indexOf(s3) === -1 : a3 !== s3) && (i2[o3] = [s3].concat(a3)) : i2[o3] = s3;
        }(o2.options, a2);
        var d2 = function(t2, r2, o3) {
          var i2 = r2.options.props;
          if (!e(i2)) {
            var a3 = {}, s3 = t2.attrs, c3 = t2.props;
            if (n(s3) || n(c3))
              for (var u2 in i2) {
                var l3 = $(u2);
                re(a3, c3, u2, l3, true) || re(a3, s3, u2, l3, false);
              }
            return a3;
          }
        }(a2, o2);
        if (r(o2.options.functional))
          return function(e2, r2, o3, i2, a3) {
            var s3 = e2.options, c3 = {}, u2 = s3.props;
            if (n(u2))
              for (var l3 in u2)
                c3[l3] = Dt(l3, u2, r2 || t);
            else
              n(o3.attrs) && Ee(c3, o3.attrs), n(o3.props) && Ee(c3, o3.props);
            var f3 = new ke(o3, c3, a3, i2, e2), p3 = s3.render.call(null, f3._c, f3);
            if (p3 instanceof lt)
              return Se(p3, o3, f3.parent, s3);
            if (Array.isArray(p3)) {
              for (var d3 = oe(p3) || [], v2 = new Array(d3.length), h3 = 0; h3 < d3.length; h3++)
                v2[h3] = Se(d3[h3], o3, f3.parent, s3);
              return v2;
            }
          }(o2, d2, a2, s2, c2);
        var h2 = a2.on;
        if (a2.on = a2.nativeOn, r(o2.options.abstract)) {
          var m2 = a2.slot;
          a2 = {}, m2 && (a2.slot = m2);
        }
        !function(t2) {
          for (var e2 = t2.hook || (t2.hook = {}), n2 = 0; n2 < Te.length; n2++) {
            var r2 = Te[n2], o3 = e2[r2], i2 = je[r2];
            o3 === i2 || o3 && o3._merged || (e2[r2] = o3 ? De(i2, o3) : i2);
          }
        }(a2);
        var y2 = o2.options.name || l2;
        return new lt("vue-component-" + o2.cid + (y2 ? "-" + y2 : ""), a2, void 0, void 0, void 0, s2, {Ctor: o2, propsData: d2, listeners: h2, tag: l2, children: c2}, p2);
      }
    }
  }
  function De(t2, e2) {
    var n2 = function(n3, r2) {
      t2(n3, r2), e2(n3, r2);
    };
    return n2._merged = true, n2;
  }
  var Ne = 1;
  var Pe = 2;
  function Le(t2, a2, s2, c2, u2, l2) {
    return (Array.isArray(s2) || o(s2)) && (u2 = c2, c2 = s2, s2 = void 0), r(l2) && (u2 = Pe), function(t3, o2, a3, s3, c3) {
      if (n(a3) && n(a3.__ob__))
        return pt();
      n(a3) && n(a3.is) && (o2 = a3.is);
      if (!o2)
        return pt();
      Array.isArray(s3) && typeof s3[0] == "function" && ((a3 = a3 || {}).scopedSlots = {default: s3[0]}, s3.length = 0);
      c3 === Pe ? s3 = oe(s3) : c3 === Ne && (s3 = function(t4) {
        for (var e2 = 0; e2 < t4.length; e2++)
          if (Array.isArray(t4[e2]))
            return Array.prototype.concat.apply([], t4);
        return t4;
      }(s3));
      var u3, l3;
      if (typeof o2 == "string") {
        var f2;
        l3 = t3.$vnode && t3.$vnode.ns || L.getTagNamespace(o2), u3 = L.isReservedTag(o2) ? new lt(L.parsePlatformTagName(o2), a3, s3, void 0, void 0, t3) : a3 && a3.pre || !n(f2 = It(t3.$options, "components", o2)) ? new lt(o2, a3, s3, void 0, void 0, t3) : Ie(f2, a3, t3, s3, o2);
      } else
        u3 = Ie(o2, a3, t3, s3);
      return Array.isArray(u3) ? u3 : n(u3) ? (n(l3) && function t4(o3, i2, a4) {
        o3.ns = i2;
        o3.tag === "foreignObject" && (i2 = void 0, a4 = true);
        if (n(o3.children))
          for (var s4 = 0, c4 = o3.children.length; s4 < c4; s4++) {
            var u4 = o3.children[s4];
            n(u4.tag) && (e(u4.ns) || r(a4) && u4.tag !== "svg") && t4(u4, i2, a4);
          }
      }(u3, l3), n(a3) && function(t4) {
        i(t4.style) && Qt(t4.style);
        i(t4.class) && Qt(t4.class);
      }(a3), u3) : pt();
    }(t2, a2, s2, c2, u2);
  }
  var Me;
  var Fe = null;
  function Re(t2, e2) {
    return (t2.__esModule || rt && t2[Symbol.toStringTag] === "Module") && (t2 = t2.default), i(t2) ? e2.extend(t2) : t2;
  }
  function Ue(t2) {
    return t2.isComment && t2.asyncFactory;
  }
  function He(t2) {
    if (Array.isArray(t2))
      for (var e2 = 0; e2 < t2.length; e2++) {
        var r2 = t2[e2];
        if (n(r2) && (n(r2.componentOptions) || Ue(r2)))
          return r2;
      }
  }
  function Be(t2, e2) {
    Me.$on(t2, e2);
  }
  function Ve(t2, e2) {
    Me.$off(t2, e2);
  }
  function ze(t2, e2) {
    var n2 = Me;
    return function r2() {
      e2.apply(null, arguments) !== null && n2.$off(t2, r2);
    };
  }
  function We(t2, e2, n2) {
    Me = t2, ee(e2, n2 || {}, Be, Ve, ze, t2), Me = void 0;
  }
  var qe = null;
  function Ke(t2) {
    var e2 = qe;
    return qe = t2, function() {
      qe = e2;
    };
  }
  function Xe(t2) {
    for (; t2 && (t2 = t2.$parent); )
      if (t2._inactive)
        return true;
    return false;
  }
  function Ge(t2, e2) {
    if (e2) {
      if (t2._directInactive = false, Xe(t2))
        return;
    } else if (t2._directInactive)
      return;
    if (t2._inactive || t2._inactive === null) {
      t2._inactive = false;
      for (var n2 = 0; n2 < t2.$children.length; n2++)
        Ge(t2.$children[n2]);
      Ze(t2, "activated");
    }
  }
  function Ze(t2, e2) {
    ct();
    var n2 = t2.$options[e2], r2 = e2 + " hook";
    if (n2)
      for (var o2 = 0, i2 = n2.length; o2 < i2; o2++)
        Ft(n2[o2], t2, null, t2, r2);
    t2._hasHookEvent && t2.$emit("hook:" + e2), ut();
  }
  var Je = [];
  var Qe = [];
  var Ye = {};
  var tn = false;
  var en = false;
  var nn = 0;
  var rn = 0;
  var on = Date.now;
  if (H && !W) {
    an = window.performance;
    an && typeof an.now == "function" && on() > document.createEvent("Event").timeStamp && (on = function() {
      return an.now();
    });
  }
  var an;
  function sn() {
    var t2, e2;
    for (rn = on(), en = true, Je.sort(function(t3, e3) {
      return t3.id - e3.id;
    }), nn = 0; nn < Je.length; nn++)
      (t2 = Je[nn]).before && t2.before(), e2 = t2.id, Ye[e2] = null, t2.run();
    var n2 = Qe.slice(), r2 = Je.slice();
    nn = Je.length = Qe.length = 0, Ye = {}, tn = en = false, function(t3) {
      for (var e3 = 0; e3 < t3.length; e3++)
        t3[e3]._inactive = true, Ge(t3[e3], true);
    }(n2), function(t3) {
      var e3 = t3.length;
      for (; e3--; ) {
        var n3 = t3[e3], r3 = n3.vm;
        r3._watcher === n3 && r3._isMounted && !r3._isDestroyed && Ze(r3, "updated");
      }
    }(r2), tt && L.devtools && tt.emit("flush");
  }
  var cn = 0;
  var un = function(t2, e2, n2, r2, o2) {
    this.vm = t2, o2 && (t2._watcher = this), t2._watchers.push(this), r2 ? (this.deep = !!r2.deep, this.user = !!r2.user, this.lazy = !!r2.lazy, this.sync = !!r2.sync, this.before = r2.before) : this.deep = this.user = this.lazy = this.sync = false, this.cb = n2, this.id = ++cn, this.active = true, this.dirty = this.lazy, this.deps = [], this.newDeps = [], this.depIds = new nt(), this.newDepIds = new nt(), this.expression = "", typeof e2 == "function" ? this.getter = e2 : (this.getter = function(t3) {
      if (!F.test(t3)) {
        var e3 = t3.split(".");
        return function(t4) {
          for (var n3 = 0; n3 < e3.length; n3++) {
            if (!t4)
              return;
            t4 = t4[e3[n3]];
          }
          return t4;
        };
      }
    }(e2), this.getter || (this.getter = k)), this.value = this.lazy ? void 0 : this.get();
  };
  un.prototype.get = function() {
    var t2;
    ct(this);
    var e2 = this.vm;
    try {
      t2 = this.getter.call(e2, e2);
    } catch (t3) {
      if (!this.user)
        throw t3;
      Mt(t3, e2, 'getter for watcher "' + this.expression + '"');
    } finally {
      this.deep && Qt(t2), ut(), this.cleanupDeps();
    }
    return t2;
  }, un.prototype.addDep = function(t2) {
    var e2 = t2.id;
    this.newDepIds.has(e2) || (this.newDepIds.add(e2), this.newDeps.push(t2), this.depIds.has(e2) || t2.addSub(this));
  }, un.prototype.cleanupDeps = function() {
    for (var t2 = this.deps.length; t2--; ) {
      var e2 = this.deps[t2];
      this.newDepIds.has(e2.id) || e2.removeSub(this);
    }
    var n2 = this.depIds;
    this.depIds = this.newDepIds, this.newDepIds = n2, this.newDepIds.clear(), n2 = this.deps, this.deps = this.newDeps, this.newDeps = n2, this.newDeps.length = 0;
  }, un.prototype.update = function() {
    this.lazy ? this.dirty = true : this.sync ? this.run() : function(t2) {
      var e2 = t2.id;
      if (Ye[e2] == null) {
        if (Ye[e2] = true, en) {
          for (var n2 = Je.length - 1; n2 > nn && Je[n2].id > t2.id; )
            n2--;
          Je.splice(n2 + 1, 0, t2);
        } else
          Je.push(t2);
        tn || (tn = true, Zt(sn));
      }
    }(this);
  }, un.prototype.run = function() {
    if (this.active) {
      var t2 = this.get();
      if (t2 !== this.value || i(t2) || this.deep) {
        var e2 = this.value;
        if (this.value = t2, this.user)
          try {
            this.cb.call(this.vm, t2, e2);
          } catch (t3) {
            Mt(t3, this.vm, 'callback for watcher "' + this.expression + '"');
          }
        else
          this.cb.call(this.vm, t2, e2);
      }
    }
  }, un.prototype.evaluate = function() {
    this.value = this.get(), this.dirty = false;
  }, un.prototype.depend = function() {
    for (var t2 = this.deps.length; t2--; )
      this.deps[t2].depend();
  }, un.prototype.teardown = function() {
    if (this.active) {
      this.vm._isBeingDestroyed || v(this.vm._watchers, this);
      for (var t2 = this.deps.length; t2--; )
        this.deps[t2].removeSub(this);
      this.active = false;
    }
  };
  var ln = {enumerable: true, configurable: true, get: k, set: k};
  function fn(t2, e2, n2) {
    ln.get = function() {
      return this[e2][n2];
    }, ln.set = function(t3) {
      this[e2][n2] = t3;
    }, Object.defineProperty(t2, n2, ln);
  }
  function pn(t2) {
    t2._watchers = [];
    var e2 = t2.$options;
    e2.props && function(t3, e3) {
      var n2 = t3.$options.propsData || {}, r2 = t3._props = {}, o2 = t3.$options._propKeys = [];
      t3.$parent && _t(false);
      var i2 = function(i3) {
        o2.push(i3);
        var a3 = Dt(i3, e3, n2, t3);
        $t(r2, i3, a3), i3 in t3 || fn(t3, "_props", i3);
      };
      for (var a2 in e3)
        i2(a2);
      _t(true);
    }(t2, e2.props), e2.methods && function(t3, e3) {
      t3.$options.props;
      for (var n2 in e3)
        t3[n2] = typeof e3[n2] != "function" ? k : w(e3[n2], t3);
    }(t2, e2.methods), e2.data ? function(t3) {
      var e3 = t3.$options.data;
      s(e3 = t3._data = typeof e3 == "function" ? function(t4, e4) {
        ct();
        try {
          return t4.call(e4, e4);
        } catch (t5) {
          return Mt(t5, e4, "data()"), {};
        } finally {
          ut();
        }
      }(e3, t3) : e3 || {}) || (e3 = {});
      var n2 = Object.keys(e3), r2 = t3.$options.props, o2 = (t3.$options.methods, n2.length);
      for (; o2--; ) {
        var i2 = n2[o2];
        r2 && m(r2, i2) || (a2 = void 0, (a2 = (i2 + "").charCodeAt(0)) !== 36 && a2 !== 95 && fn(t3, "_data", i2));
      }
      var a2;
      Ct(e3, true);
    }(t2) : Ct(t2._data = {}, true), e2.computed && function(t3, e3) {
      var n2 = t3._computedWatchers = Object.create(null), r2 = Y();
      for (var o2 in e3) {
        var i2 = e3[o2], a2 = typeof i2 == "function" ? i2 : i2.get;
        r2 || (n2[o2] = new un(t3, a2 || k, k, dn)), o2 in t3 || vn(t3, o2, i2);
      }
    }(t2, e2.computed), e2.watch && e2.watch !== Z && function(t3, e3) {
      for (var n2 in e3) {
        var r2 = e3[n2];
        if (Array.isArray(r2))
          for (var o2 = 0; o2 < r2.length; o2++)
            yn(t3, n2, r2[o2]);
        else
          yn(t3, n2, r2);
      }
    }(t2, e2.watch);
  }
  var dn = {lazy: true};
  function vn(t2, e2, n2) {
    var r2 = !Y();
    typeof n2 == "function" ? (ln.get = r2 ? hn(e2) : mn(n2), ln.set = k) : (ln.get = n2.get ? r2 && n2.cache !== false ? hn(e2) : mn(n2.get) : k, ln.set = n2.set || k), Object.defineProperty(t2, e2, ln);
  }
  function hn(t2) {
    return function() {
      var e2 = this._computedWatchers && this._computedWatchers[t2];
      if (e2)
        return e2.dirty && e2.evaluate(), at.target && e2.depend(), e2.value;
    };
  }
  function mn(t2) {
    return function() {
      return t2.call(this, this);
    };
  }
  function yn(t2, e2, n2, r2) {
    return s(n2) && (r2 = n2, n2 = n2.handler), typeof n2 == "string" && (n2 = t2[n2]), t2.$watch(e2, n2, r2);
  }
  var gn = 0;
  function _n(t2) {
    var e2 = t2.options;
    if (t2.super) {
      var n2 = _n(t2.super);
      if (n2 !== t2.superOptions) {
        t2.superOptions = n2;
        var r2 = function(t3) {
          var e3, n3 = t3.options, r3 = t3.sealedOptions;
          for (var o2 in n3)
            n3[o2] !== r3[o2] && (e3 || (e3 = {}), e3[o2] = n3[o2]);
          return e3;
        }(t2);
        r2 && x(t2.extendOptions, r2), (e2 = t2.options = Tt(n2, t2.extendOptions)).name && (e2.components[e2.name] = t2);
      }
    }
    return e2;
  }
  function bn(t2) {
    this._init(t2);
  }
  function Cn(t2) {
    t2.cid = 0;
    var e2 = 1;
    t2.extend = function(t3) {
      t3 = t3 || {};
      var n2 = this, r2 = n2.cid, o2 = t3._Ctor || (t3._Ctor = {});
      if (o2[r2])
        return o2[r2];
      var i2 = t3.name || n2.options.name, a2 = function(t4) {
        this._init(t4);
      };
      return (a2.prototype = Object.create(n2.prototype)).constructor = a2, a2.cid = e2++, a2.options = Tt(n2.options, t3), a2.super = n2, a2.options.props && function(t4) {
        var e3 = t4.options.props;
        for (var n3 in e3)
          fn(t4.prototype, "_props", n3);
      }(a2), a2.options.computed && function(t4) {
        var e3 = t4.options.computed;
        for (var n3 in e3)
          vn(t4.prototype, n3, e3[n3]);
      }(a2), a2.extend = n2.extend, a2.mixin = n2.mixin, a2.use = n2.use, N.forEach(function(t4) {
        a2[t4] = n2[t4];
      }), i2 && (a2.options.components[i2] = a2), a2.superOptions = n2.options, a2.extendOptions = t3, a2.sealedOptions = x({}, a2.options), o2[r2] = a2, a2;
    };
  }
  function $n(t2) {
    return t2 && (t2.Ctor.options.name || t2.tag);
  }
  function wn(t2, e2) {
    return Array.isArray(t2) ? t2.indexOf(e2) > -1 : typeof t2 == "string" ? t2.split(",").indexOf(e2) > -1 : (n2 = t2, a.call(n2) === "[object RegExp]" && t2.test(e2));
    var n2;
  }
  function An(t2, e2) {
    var n2 = t2.cache, r2 = t2.keys, o2 = t2._vnode;
    for (var i2 in n2) {
      var a2 = n2[i2];
      if (a2) {
        var s2 = $n(a2.componentOptions);
        s2 && !e2(s2) && xn(n2, i2, r2, o2);
      }
    }
  }
  function xn(t2, e2, n2, r2) {
    var o2 = t2[e2];
    !o2 || r2 && o2.tag === r2.tag || o2.componentInstance.$destroy(), t2[e2] = null, v(n2, e2);
  }
  !function(e2) {
    e2.prototype._init = function(e3) {
      var n2 = this;
      n2._uid = gn++, n2._isVue = true, e3 && e3._isComponent ? function(t2, e4) {
        var n3 = t2.$options = Object.create(t2.constructor.options), r2 = e4._parentVnode;
        n3.parent = e4.parent, n3._parentVnode = r2;
        var o2 = r2.componentOptions;
        n3.propsData = o2.propsData, n3._parentListeners = o2.listeners, n3._renderChildren = o2.children, n3._componentTag = o2.tag, e4.render && (n3.render = e4.render, n3.staticRenderFns = e4.staticRenderFns);
      }(n2, e3) : n2.$options = Tt(_n(n2.constructor), e3 || {}, n2), n2._renderProxy = n2, n2._self = n2, function(t2) {
        var e4 = t2.$options, n3 = e4.parent;
        if (n3 && !e4.abstract) {
          for (; n3.$options.abstract && n3.$parent; )
            n3 = n3.$parent;
          n3.$children.push(t2);
        }
        t2.$parent = n3, t2.$root = n3 ? n3.$root : t2, t2.$children = [], t2.$refs = {}, t2._watcher = null, t2._inactive = null, t2._directInactive = false, t2._isMounted = false, t2._isDestroyed = false, t2._isBeingDestroyed = false;
      }(n2), function(t2) {
        t2._events = Object.create(null), t2._hasHookEvent = false;
        var e4 = t2.$options._parentListeners;
        e4 && We(t2, e4);
      }(n2), function(e4) {
        e4._vnode = null, e4._staticTrees = null;
        var n3 = e4.$options, r2 = e4.$vnode = n3._parentVnode, o2 = r2 && r2.context;
        e4.$slots = se(n3._renderChildren, o2), e4.$scopedSlots = t, e4._c = function(t2, n4, r3, o3) {
          return Le(e4, t2, n4, r3, o3, false);
        }, e4.$createElement = function(t2, n4, r3, o3) {
          return Le(e4, t2, n4, r3, o3, true);
        };
        var i2 = r2 && r2.data;
        $t(e4, "$attrs", i2 && i2.attrs || t, null, true), $t(e4, "$listeners", n3._parentListeners || t, null, true);
      }(n2), Ze(n2, "beforeCreate"), function(t2) {
        var e4 = ae(t2.$options.inject, t2);
        e4 && (_t(false), Object.keys(e4).forEach(function(n3) {
          $t(t2, n3, e4[n3]);
        }), _t(true));
      }(n2), pn(n2), function(t2) {
        var e4 = t2.$options.provide;
        e4 && (t2._provided = typeof e4 == "function" ? e4.call(t2) : e4);
      }(n2), Ze(n2, "created"), n2.$options.el && n2.$mount(n2.$options.el);
    };
  }(bn), function(t2) {
    var e2 = {get: function() {
      return this._data;
    }}, n2 = {get: function() {
      return this._props;
    }};
    Object.defineProperty(t2.prototype, "$data", e2), Object.defineProperty(t2.prototype, "$props", n2), t2.prototype.$set = wt, t2.prototype.$delete = At, t2.prototype.$watch = function(t3, e3, n3) {
      if (s(e3))
        return yn(this, t3, e3, n3);
      (n3 = n3 || {}).user = true;
      var r2 = new un(this, t3, e3, n3);
      if (n3.immediate)
        try {
          e3.call(this, r2.value);
        } catch (t4) {
          Mt(t4, this, 'callback for immediate watcher "' + r2.expression + '"');
        }
      return function() {
        r2.teardown();
      };
    };
  }(bn), function(t2) {
    var e2 = /^hook:/;
    t2.prototype.$on = function(t3, n2) {
      var r2 = this;
      if (Array.isArray(t3))
        for (var o2 = 0, i2 = t3.length; o2 < i2; o2++)
          r2.$on(t3[o2], n2);
      else
        (r2._events[t3] || (r2._events[t3] = [])).push(n2), e2.test(t3) && (r2._hasHookEvent = true);
      return r2;
    }, t2.prototype.$once = function(t3, e3) {
      var n2 = this;
      function r2() {
        n2.$off(t3, r2), e3.apply(n2, arguments);
      }
      return r2.fn = e3, n2.$on(t3, r2), n2;
    }, t2.prototype.$off = function(t3, e3) {
      var n2 = this;
      if (!arguments.length)
        return n2._events = Object.create(null), n2;
      if (Array.isArray(t3)) {
        for (var r2 = 0, o2 = t3.length; r2 < o2; r2++)
          n2.$off(t3[r2], e3);
        return n2;
      }
      var i2, a2 = n2._events[t3];
      if (!a2)
        return n2;
      if (!e3)
        return n2._events[t3] = null, n2;
      for (var s2 = a2.length; s2--; )
        if ((i2 = a2[s2]) === e3 || i2.fn === e3) {
          a2.splice(s2, 1);
          break;
        }
      return n2;
    }, t2.prototype.$emit = function(t3) {
      var e3 = this._events[t3];
      if (e3) {
        e3 = e3.length > 1 ? A(e3) : e3;
        for (var n2 = A(arguments, 1), r2 = 'event handler for "' + t3 + '"', o2 = 0, i2 = e3.length; o2 < i2; o2++)
          Ft(e3[o2], this, n2, this, r2);
      }
      return this;
    };
  }(bn), function(t2) {
    t2.prototype._update = function(t3, e2) {
      var n2 = this, r2 = n2.$el, o2 = n2._vnode, i2 = Ke(n2);
      n2._vnode = t3, n2.$el = o2 ? n2.__patch__(o2, t3) : n2.__patch__(n2.$el, t3, e2, false), i2(), r2 && (r2.__vue__ = null), n2.$el && (n2.$el.__vue__ = n2), n2.$vnode && n2.$parent && n2.$vnode === n2.$parent._vnode && (n2.$parent.$el = n2.$el);
    }, t2.prototype.$forceUpdate = function() {
      this._watcher && this._watcher.update();
    }, t2.prototype.$destroy = function() {
      var t3 = this;
      if (!t3._isBeingDestroyed) {
        Ze(t3, "beforeDestroy"), t3._isBeingDestroyed = true;
        var e2 = t3.$parent;
        !e2 || e2._isBeingDestroyed || t3.$options.abstract || v(e2.$children, t3), t3._watcher && t3._watcher.teardown();
        for (var n2 = t3._watchers.length; n2--; )
          t3._watchers[n2].teardown();
        t3._data.__ob__ && t3._data.__ob__.vmCount--, t3._isDestroyed = true, t3.__patch__(t3._vnode, null), Ze(t3, "destroyed"), t3.$off(), t3.$el && (t3.$el.__vue__ = null), t3.$vnode && (t3.$vnode.parent = null);
      }
    };
  }(bn), function(t2) {
    Oe(t2.prototype), t2.prototype.$nextTick = function(t3) {
      return Zt(t3, this);
    }, t2.prototype._render = function() {
      var t3, e2 = this, n2 = e2.$options, r2 = n2.render, o2 = n2._parentVnode;
      o2 && (e2.$scopedSlots = ue(o2.data.scopedSlots, e2.$slots, e2.$scopedSlots)), e2.$vnode = o2;
      try {
        Fe = e2, t3 = r2.call(e2._renderProxy, e2.$createElement);
      } catch (n3) {
        Mt(n3, e2, "render"), t3 = e2._vnode;
      } finally {
        Fe = null;
      }
      return Array.isArray(t3) && t3.length === 1 && (t3 = t3[0]), t3 instanceof lt || (t3 = pt()), t3.parent = o2, t3;
    };
  }(bn);
  var On = [String, RegExp, Array];
  var kn = {KeepAlive: {name: "keep-alive", abstract: true, props: {include: On, exclude: On, max: [String, Number]}, created: function() {
    this.cache = Object.create(null), this.keys = [];
  }, destroyed: function() {
    for (var t2 in this.cache)
      xn(this.cache, t2, this.keys);
  }, mounted: function() {
    var t2 = this;
    this.$watch("include", function(e2) {
      An(t2, function(t3) {
        return wn(e2, t3);
      });
    }), this.$watch("exclude", function(e2) {
      An(t2, function(t3) {
        return !wn(e2, t3);
      });
    });
  }, render: function() {
    var t2 = this.$slots.default, e2 = He(t2), n2 = e2 && e2.componentOptions;
    if (n2) {
      var r2 = $n(n2), o2 = this.include, i2 = this.exclude;
      if (o2 && (!r2 || !wn(o2, r2)) || i2 && r2 && wn(i2, r2))
        return e2;
      var a2 = this.cache, s2 = this.keys, c2 = e2.key == null ? n2.Ctor.cid + (n2.tag ? "::" + n2.tag : "") : e2.key;
      a2[c2] ? (e2.componentInstance = a2[c2].componentInstance, v(s2, c2), s2.push(c2)) : (a2[c2] = e2, s2.push(c2), this.max && s2.length > parseInt(this.max) && xn(a2, s2[0], s2, this._vnode)), e2.data.keepAlive = true;
    }
    return e2 || t2 && t2[0];
  }}};
  !function(t2) {
    var e2 = {get: function() {
      return L;
    }};
    Object.defineProperty(t2, "config", e2), t2.util = {warn: ot, extend: x, mergeOptions: Tt, defineReactive: $t}, t2.set = wt, t2.delete = At, t2.nextTick = Zt, t2.observable = function(t3) {
      return Ct(t3), t3;
    }, t2.options = Object.create(null), N.forEach(function(e3) {
      t2.options[e3 + "s"] = Object.create(null);
    }), t2.options._base = t2, x(t2.options.components, kn), function(t3) {
      t3.use = function(t4) {
        var e3 = this._installedPlugins || (this._installedPlugins = []);
        if (e3.indexOf(t4) > -1)
          return this;
        var n2 = A(arguments, 1);
        return n2.unshift(this), typeof t4.install == "function" ? t4.install.apply(t4, n2) : typeof t4 == "function" && t4.apply(null, n2), e3.push(t4), this;
      };
    }(t2), function(t3) {
      t3.mixin = function(t4) {
        return this.options = Tt(this.options, t4), this;
      };
    }(t2), Cn(t2), function(t3) {
      N.forEach(function(e3) {
        t3[e3] = function(t4, n2) {
          return n2 ? (e3 === "component" && s(n2) && (n2.name = n2.name || t4, n2 = this.options._base.extend(n2)), e3 === "directive" && typeof n2 == "function" && (n2 = {bind: n2, update: n2}), this.options[e3 + "s"][t4] = n2, n2) : this.options[e3 + "s"][t4];
        };
      });
    }(t2);
  }(bn), Object.defineProperty(bn.prototype, "$isServer", {get: Y}), Object.defineProperty(bn.prototype, "$ssrContext", {get: function() {
    return this.$vnode && this.$vnode.ssrContext;
  }}), Object.defineProperty(bn, "FunctionalRenderContext", {value: ke}), bn.version = "2.6.12";
  var Sn = p("style,class");
  var En = p("input,textarea,option,select,progress");
  var jn = p("contenteditable,draggable,spellcheck");
  var Tn = p("events,caret,typing,plaintext-only");
  var In = function(t2, e2) {
    return Mn(e2) || e2 === "false" ? "false" : t2 === "contenteditable" && Tn(e2) ? e2 : "true";
  };
  var Dn = p("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible");
  var Nn = "http://www.w3.org/1999/xlink";
  var Pn = function(t2) {
    return t2.charAt(5) === ":" && t2.slice(0, 5) === "xlink";
  };
  var Ln = function(t2) {
    return Pn(t2) ? t2.slice(6, t2.length) : "";
  };
  var Mn = function(t2) {
    return t2 == null || t2 === false;
  };
  function Fn(t2) {
    for (var e2 = t2.data, r2 = t2, o2 = t2; n(o2.componentInstance); )
      (o2 = o2.componentInstance._vnode) && o2.data && (e2 = Rn(o2.data, e2));
    for (; n(r2 = r2.parent); )
      r2 && r2.data && (e2 = Rn(e2, r2.data));
    return function(t3, e3) {
      if (n(t3) || n(e3))
        return Un(t3, Hn(e3));
      return "";
    }(e2.staticClass, e2.class);
  }
  function Rn(t2, e2) {
    return {staticClass: Un(t2.staticClass, e2.staticClass), class: n(t2.class) ? [t2.class, e2.class] : e2.class};
  }
  function Un(t2, e2) {
    return t2 ? e2 ? t2 + " " + e2 : t2 : e2 || "";
  }
  function Hn(t2) {
    return Array.isArray(t2) ? function(t3) {
      for (var e2, r2 = "", o2 = 0, i2 = t3.length; o2 < i2; o2++)
        n(e2 = Hn(t3[o2])) && e2 !== "" && (r2 && (r2 += " "), r2 += e2);
      return r2;
    }(t2) : i(t2) ? function(t3) {
      var e2 = "";
      for (var n2 in t3)
        t3[n2] && (e2 && (e2 += " "), e2 += n2);
      return e2;
    }(t2) : typeof t2 == "string" ? t2 : "";
  }
  var Bn = {svg: "http://www.w3.org/2000/svg", math: "http://www.w3.org/1998/Math/MathML"};
  var Vn = p("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot");
  var zn = p("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", true);
  var Wn = function(t2) {
    return Vn(t2) || zn(t2);
  };
  var qn = Object.create(null);
  var Kn = p("text,number,password,search,email,tel,url");
  var Xn = Object.freeze({createElement: function(t2, e2) {
    var n2 = document.createElement(t2);
    return t2 !== "select" ? n2 : (e2.data && e2.data.attrs && e2.data.attrs.multiple !== void 0 && n2.setAttribute("multiple", "multiple"), n2);
  }, createElementNS: function(t2, e2) {
    return document.createElementNS(Bn[t2], e2);
  }, createTextNode: function(t2) {
    return document.createTextNode(t2);
  }, createComment: function(t2) {
    return document.createComment(t2);
  }, insertBefore: function(t2, e2, n2) {
    t2.insertBefore(e2, n2);
  }, removeChild: function(t2, e2) {
    t2.removeChild(e2);
  }, appendChild: function(t2, e2) {
    t2.appendChild(e2);
  }, parentNode: function(t2) {
    return t2.parentNode;
  }, nextSibling: function(t2) {
    return t2.nextSibling;
  }, tagName: function(t2) {
    return t2.tagName;
  }, setTextContent: function(t2, e2) {
    t2.textContent = e2;
  }, setStyleScope: function(t2, e2) {
    t2.setAttribute(e2, "");
  }});
  var Gn = {create: function(t2, e2) {
    Zn(e2);
  }, update: function(t2, e2) {
    t2.data.ref !== e2.data.ref && (Zn(t2, true), Zn(e2));
  }, destroy: function(t2) {
    Zn(t2, true);
  }};
  function Zn(t2, e2) {
    var r2 = t2.data.ref;
    if (n(r2)) {
      var o2 = t2.context, i2 = t2.componentInstance || t2.elm, a2 = o2.$refs;
      e2 ? Array.isArray(a2[r2]) ? v(a2[r2], i2) : a2[r2] === i2 && (a2[r2] = void 0) : t2.data.refInFor ? Array.isArray(a2[r2]) ? a2[r2].indexOf(i2) < 0 && a2[r2].push(i2) : a2[r2] = [i2] : a2[r2] = i2;
    }
  }
  var Jn = new lt("", {}, []);
  var Qn = ["create", "activate", "update", "remove", "destroy"];
  function Yn(t2, o2) {
    return t2.key === o2.key && (t2.tag === o2.tag && t2.isComment === o2.isComment && n(t2.data) === n(o2.data) && function(t3, e2) {
      if (t3.tag !== "input")
        return true;
      var r2, o3 = n(r2 = t3.data) && n(r2 = r2.attrs) && r2.type, i2 = n(r2 = e2.data) && n(r2 = r2.attrs) && r2.type;
      return o3 === i2 || Kn(o3) && Kn(i2);
    }(t2, o2) || r(t2.isAsyncPlaceholder) && t2.asyncFactory === o2.asyncFactory && e(o2.asyncFactory.error));
  }
  function tr(t2, e2, r2) {
    var o2, i2, a2 = {};
    for (o2 = e2; o2 <= r2; ++o2)
      n(i2 = t2[o2].key) && (a2[i2] = o2);
    return a2;
  }
  var er = {create: nr, update: nr, destroy: function(t2) {
    nr(t2, Jn);
  }};
  function nr(t2, e2) {
    (t2.data.directives || e2.data.directives) && function(t3, e3) {
      var n2, r2, o2, i2 = t3 === Jn, a2 = e3 === Jn, s2 = or(t3.data.directives, t3.context), c2 = or(e3.data.directives, e3.context), u2 = [], l2 = [];
      for (n2 in c2)
        r2 = s2[n2], o2 = c2[n2], r2 ? (o2.oldValue = r2.value, o2.oldArg = r2.arg, ar(o2, "update", e3, t3), o2.def && o2.def.componentUpdated && l2.push(o2)) : (ar(o2, "bind", e3, t3), o2.def && o2.def.inserted && u2.push(o2));
      if (u2.length) {
        var f2 = function() {
          for (var n3 = 0; n3 < u2.length; n3++)
            ar(u2[n3], "inserted", e3, t3);
        };
        i2 ? ne(e3, "insert", f2) : f2();
      }
      l2.length && ne(e3, "postpatch", function() {
        for (var n3 = 0; n3 < l2.length; n3++)
          ar(l2[n3], "componentUpdated", e3, t3);
      });
      if (!i2)
        for (n2 in s2)
          c2[n2] || ar(s2[n2], "unbind", t3, t3, a2);
    }(t2, e2);
  }
  var rr = Object.create(null);
  function or(t2, e2) {
    var n2, r2, o2 = Object.create(null);
    if (!t2)
      return o2;
    for (n2 = 0; n2 < t2.length; n2++)
      (r2 = t2[n2]).modifiers || (r2.modifiers = rr), o2[ir(r2)] = r2, r2.def = It(e2.$options, "directives", r2.name);
    return o2;
  }
  function ir(t2) {
    return t2.rawName || t2.name + "." + Object.keys(t2.modifiers || {}).join(".");
  }
  function ar(t2, e2, n2, r2, o2) {
    var i2 = t2.def && t2.def[e2];
    if (i2)
      try {
        i2(n2.elm, t2, n2, r2, o2);
      } catch (r3) {
        Mt(r3, n2.context, "directive " + t2.name + " " + e2 + " hook");
      }
  }
  var sr = [Gn, er];
  function cr(t2, r2) {
    var o2 = r2.componentOptions;
    if (!(n(o2) && o2.Ctor.options.inheritAttrs === false || e(t2.data.attrs) && e(r2.data.attrs))) {
      var i2, a2, s2 = r2.elm, c2 = t2.data.attrs || {}, u2 = r2.data.attrs || {};
      for (i2 in n(u2.__ob__) && (u2 = r2.data.attrs = x({}, u2)), u2)
        a2 = u2[i2], c2[i2] !== a2 && ur(s2, i2, a2);
      for (i2 in (W || K) && u2.value !== c2.value && ur(s2, "value", u2.value), c2)
        e(u2[i2]) && (Pn(i2) ? s2.removeAttributeNS(Nn, Ln(i2)) : jn(i2) || s2.removeAttribute(i2));
    }
  }
  function ur(t2, e2, n2) {
    t2.tagName.indexOf("-") > -1 ? lr(t2, e2, n2) : Dn(e2) ? Mn(n2) ? t2.removeAttribute(e2) : (n2 = e2 === "allowfullscreen" && t2.tagName === "EMBED" ? "true" : e2, t2.setAttribute(e2, n2)) : jn(e2) ? t2.setAttribute(e2, In(e2, n2)) : Pn(e2) ? Mn(n2) ? t2.removeAttributeNS(Nn, Ln(e2)) : t2.setAttributeNS(Nn, e2, n2) : lr(t2, e2, n2);
  }
  function lr(t2, e2, n2) {
    if (Mn(n2))
      t2.removeAttribute(e2);
    else {
      if (W && !q && t2.tagName === "TEXTAREA" && e2 === "placeholder" && n2 !== "" && !t2.__ieph) {
        var r2 = function(e3) {
          e3.stopImmediatePropagation(), t2.removeEventListener("input", r2);
        };
        t2.addEventListener("input", r2), t2.__ieph = true;
      }
      t2.setAttribute(e2, n2);
    }
  }
  var fr = {create: cr, update: cr};
  function pr(t2, r2) {
    var o2 = r2.elm, i2 = r2.data, a2 = t2.data;
    if (!(e(i2.staticClass) && e(i2.class) && (e(a2) || e(a2.staticClass) && e(a2.class)))) {
      var s2 = Fn(r2), c2 = o2._transitionClasses;
      n(c2) && (s2 = Un(s2, Hn(c2))), s2 !== o2._prevClass && (o2.setAttribute("class", s2), o2._prevClass = s2);
    }
  }
  var dr;
  var vr = {create: pr, update: pr};
  var hr = "__r";
  var mr = "__c";
  function yr(t2, e2, n2) {
    var r2 = dr;
    return function o2() {
      e2.apply(null, arguments) !== null && br(t2, o2, n2, r2);
    };
  }
  var gr = Bt && !(G && Number(G[1]) <= 53);
  function _r(t2, e2, n2, r2) {
    if (gr) {
      var o2 = rn, i2 = e2;
      e2 = i2._wrapper = function(t3) {
        if (t3.target === t3.currentTarget || t3.timeStamp >= o2 || t3.timeStamp <= 0 || t3.target.ownerDocument !== document)
          return i2.apply(this, arguments);
      };
    }
    dr.addEventListener(t2, e2, J ? {capture: n2, passive: r2} : n2);
  }
  function br(t2, e2, n2, r2) {
    (r2 || dr).removeEventListener(t2, e2._wrapper || e2, n2);
  }
  function Cr(t2, r2) {
    if (!e(t2.data.on) || !e(r2.data.on)) {
      var o2 = r2.data.on || {}, i2 = t2.data.on || {};
      dr = r2.elm, function(t3) {
        if (n(t3[hr])) {
          var e2 = W ? "change" : "input";
          t3[e2] = [].concat(t3[hr], t3[e2] || []), delete t3[hr];
        }
        n(t3[mr]) && (t3.change = [].concat(t3[mr], t3.change || []), delete t3[mr]);
      }(o2), ee(o2, i2, _r, br, yr, r2.context), dr = void 0;
    }
  }
  var $r;
  var wr = {create: Cr, update: Cr};
  function Ar(t2, r2) {
    if (!e(t2.data.domProps) || !e(r2.data.domProps)) {
      var o2, i2, a2 = r2.elm, s2 = t2.data.domProps || {}, c2 = r2.data.domProps || {};
      for (o2 in n(c2.__ob__) && (c2 = r2.data.domProps = x({}, c2)), s2)
        o2 in c2 || (a2[o2] = "");
      for (o2 in c2) {
        if (i2 = c2[o2], o2 === "textContent" || o2 === "innerHTML") {
          if (r2.children && (r2.children.length = 0), i2 === s2[o2])
            continue;
          a2.childNodes.length === 1 && a2.removeChild(a2.childNodes[0]);
        }
        if (o2 === "value" && a2.tagName !== "PROGRESS") {
          a2._value = i2;
          var u2 = e(i2) ? "" : String(i2);
          xr(a2, u2) && (a2.value = u2);
        } else if (o2 === "innerHTML" && zn(a2.tagName) && e(a2.innerHTML)) {
          ($r = $r || document.createElement("div")).innerHTML = "<svg>" + i2 + "</svg>";
          for (var l2 = $r.firstChild; a2.firstChild; )
            a2.removeChild(a2.firstChild);
          for (; l2.firstChild; )
            a2.appendChild(l2.firstChild);
        } else if (i2 !== s2[o2])
          try {
            a2[o2] = i2;
          } catch (t3) {
          }
      }
    }
  }
  function xr(t2, e2) {
    return !t2.composing && (t2.tagName === "OPTION" || function(t3, e3) {
      var n2 = true;
      try {
        n2 = document.activeElement !== t3;
      } catch (t4) {
      }
      return n2 && t3.value !== e3;
    }(t2, e2) || function(t3, e3) {
      var r2 = t3.value, o2 = t3._vModifiers;
      if (n(o2)) {
        if (o2.number)
          return f(r2) !== f(e3);
        if (o2.trim)
          return r2.trim() !== e3.trim();
      }
      return r2 !== e3;
    }(t2, e2));
  }
  var Or = {create: Ar, update: Ar};
  var kr = y(function(t2) {
    var e2 = {}, n2 = /:(.+)/;
    return t2.split(/;(?![^(]*\))/g).forEach(function(t3) {
      if (t3) {
        var r2 = t3.split(n2);
        r2.length > 1 && (e2[r2[0].trim()] = r2[1].trim());
      }
    }), e2;
  });
  function Sr(t2) {
    var e2 = Er(t2.style);
    return t2.staticStyle ? x(t2.staticStyle, e2) : e2;
  }
  function Er(t2) {
    return Array.isArray(t2) ? O(t2) : typeof t2 == "string" ? kr(t2) : t2;
  }
  var jr;
  var Tr = /^--/;
  var Ir = /\s*!important$/;
  var Dr = function(t2, e2, n2) {
    if (Tr.test(e2))
      t2.style.setProperty(e2, n2);
    else if (Ir.test(n2))
      t2.style.setProperty($(e2), n2.replace(Ir, ""), "important");
    else {
      var r2 = Pr(e2);
      if (Array.isArray(n2))
        for (var o2 = 0, i2 = n2.length; o2 < i2; o2++)
          t2.style[r2] = n2[o2];
      else
        t2.style[r2] = n2;
    }
  };
  var Nr = ["Webkit", "Moz", "ms"];
  var Pr = y(function(t2) {
    if (jr = jr || document.createElement("div").style, (t2 = _(t2)) !== "filter" && t2 in jr)
      return t2;
    for (var e2 = t2.charAt(0).toUpperCase() + t2.slice(1), n2 = 0; n2 < Nr.length; n2++) {
      var r2 = Nr[n2] + e2;
      if (r2 in jr)
        return r2;
    }
  });
  function Lr(t2, r2) {
    var o2 = r2.data, i2 = t2.data;
    if (!(e(o2.staticStyle) && e(o2.style) && e(i2.staticStyle) && e(i2.style))) {
      var a2, s2, c2 = r2.elm, u2 = i2.staticStyle, l2 = i2.normalizedStyle || i2.style || {}, f2 = u2 || l2, p2 = Er(r2.data.style) || {};
      r2.data.normalizedStyle = n(p2.__ob__) ? x({}, p2) : p2;
      var d2 = function(t3, e2) {
        var n2, r3 = {};
        if (e2)
          for (var o3 = t3; o3.componentInstance; )
            (o3 = o3.componentInstance._vnode) && o3.data && (n2 = Sr(o3.data)) && x(r3, n2);
        (n2 = Sr(t3.data)) && x(r3, n2);
        for (var i3 = t3; i3 = i3.parent; )
          i3.data && (n2 = Sr(i3.data)) && x(r3, n2);
        return r3;
      }(r2, true);
      for (s2 in f2)
        e(d2[s2]) && Dr(c2, s2, "");
      for (s2 in d2)
        (a2 = d2[s2]) !== f2[s2] && Dr(c2, s2, a2 == null ? "" : a2);
    }
  }
  var Mr = {create: Lr, update: Lr};
  var Fr = /\s+/;
  function Rr(t2, e2) {
    if (e2 && (e2 = e2.trim()))
      if (t2.classList)
        e2.indexOf(" ") > -1 ? e2.split(Fr).forEach(function(e3) {
          return t2.classList.add(e3);
        }) : t2.classList.add(e2);
      else {
        var n2 = " " + (t2.getAttribute("class") || "") + " ";
        n2.indexOf(" " + e2 + " ") < 0 && t2.setAttribute("class", (n2 + e2).trim());
      }
  }
  function Ur(t2, e2) {
    if (e2 && (e2 = e2.trim()))
      if (t2.classList)
        e2.indexOf(" ") > -1 ? e2.split(Fr).forEach(function(e3) {
          return t2.classList.remove(e3);
        }) : t2.classList.remove(e2), t2.classList.length || t2.removeAttribute("class");
      else {
        for (var n2 = " " + (t2.getAttribute("class") || "") + " ", r2 = " " + e2 + " "; n2.indexOf(r2) >= 0; )
          n2 = n2.replace(r2, " ");
        (n2 = n2.trim()) ? t2.setAttribute("class", n2) : t2.removeAttribute("class");
      }
  }
  function Hr(t2) {
    if (t2) {
      if (typeof t2 == "object") {
        var e2 = {};
        return t2.css !== false && x(e2, Br(t2.name || "v")), x(e2, t2), e2;
      }
      return typeof t2 == "string" ? Br(t2) : void 0;
    }
  }
  var Br = y(function(t2) {
    return {enterClass: t2 + "-enter", enterToClass: t2 + "-enter-to", enterActiveClass: t2 + "-enter-active", leaveClass: t2 + "-leave", leaveToClass: t2 + "-leave-to", leaveActiveClass: t2 + "-leave-active"};
  });
  var Vr = H && !q;
  var zr = "transition";
  var Wr = "animation";
  var qr = "transition";
  var Kr = "transitionend";
  var Xr = "animation";
  var Gr = "animationend";
  Vr && (window.ontransitionend === void 0 && window.onwebkittransitionend !== void 0 && (qr = "WebkitTransition", Kr = "webkitTransitionEnd"), window.onanimationend === void 0 && window.onwebkitanimationend !== void 0 && (Xr = "WebkitAnimation", Gr = "webkitAnimationEnd"));
  var Zr = H ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : function(t2) {
    return t2();
  };
  function Jr(t2) {
    Zr(function() {
      Zr(t2);
    });
  }
  function Qr(t2, e2) {
    var n2 = t2._transitionClasses || (t2._transitionClasses = []);
    n2.indexOf(e2) < 0 && (n2.push(e2), Rr(t2, e2));
  }
  function Yr(t2, e2) {
    t2._transitionClasses && v(t2._transitionClasses, e2), Ur(t2, e2);
  }
  function to(t2, e2, n2) {
    var r2 = no(t2, e2), o2 = r2.type, i2 = r2.timeout, a2 = r2.propCount;
    if (!o2)
      return n2();
    var s2 = o2 === zr ? Kr : Gr, c2 = 0, u2 = function() {
      t2.removeEventListener(s2, l2), n2();
    }, l2 = function(e3) {
      e3.target === t2 && ++c2 >= a2 && u2();
    };
    setTimeout(function() {
      c2 < a2 && u2();
    }, i2 + 1), t2.addEventListener(s2, l2);
  }
  var eo = /\b(transform|all)(,|$)/;
  function no(t2, e2) {
    var n2, r2 = window.getComputedStyle(t2), o2 = (r2[qr + "Delay"] || "").split(", "), i2 = (r2[qr + "Duration"] || "").split(", "), a2 = ro(o2, i2), s2 = (r2[Xr + "Delay"] || "").split(", "), c2 = (r2[Xr + "Duration"] || "").split(", "), u2 = ro(s2, c2), l2 = 0, f2 = 0;
    return e2 === zr ? a2 > 0 && (n2 = zr, l2 = a2, f2 = i2.length) : e2 === Wr ? u2 > 0 && (n2 = Wr, l2 = u2, f2 = c2.length) : f2 = (n2 = (l2 = Math.max(a2, u2)) > 0 ? a2 > u2 ? zr : Wr : null) ? n2 === zr ? i2.length : c2.length : 0, {type: n2, timeout: l2, propCount: f2, hasTransform: n2 === zr && eo.test(r2[qr + "Property"])};
  }
  function ro(t2, e2) {
    for (; t2.length < e2.length; )
      t2 = t2.concat(t2);
    return Math.max.apply(null, e2.map(function(e3, n2) {
      return oo(e3) + oo(t2[n2]);
    }));
  }
  function oo(t2) {
    return 1e3 * Number(t2.slice(0, -1).replace(",", "."));
  }
  function io(t2, r2) {
    var o2 = t2.elm;
    n(o2._leaveCb) && (o2._leaveCb.cancelled = true, o2._leaveCb());
    var a2 = Hr(t2.data.transition);
    if (!e(a2) && !n(o2._enterCb) && o2.nodeType === 1) {
      for (var s2 = a2.css, c2 = a2.type, u2 = a2.enterClass, l2 = a2.enterToClass, p2 = a2.enterActiveClass, d2 = a2.appearClass, v2 = a2.appearToClass, h2 = a2.appearActiveClass, m2 = a2.beforeEnter, y2 = a2.enter, g2 = a2.afterEnter, _2 = a2.enterCancelled, b2 = a2.beforeAppear, C2 = a2.appear, $2 = a2.afterAppear, w2 = a2.appearCancelled, A2 = a2.duration, x2 = qe, O2 = qe.$vnode; O2 && O2.parent; )
        x2 = O2.context, O2 = O2.parent;
      var k2 = !x2._isMounted || !t2.isRootInsert;
      if (!k2 || C2 || C2 === "") {
        var S2 = k2 && d2 ? d2 : u2, E2 = k2 && h2 ? h2 : p2, j2 = k2 && v2 ? v2 : l2, T2 = k2 && b2 || m2, D2 = k2 && typeof C2 == "function" ? C2 : y2, N2 = k2 && $2 || g2, P2 = k2 && w2 || _2, L2 = f(i(A2) ? A2.enter : A2), M2 = s2 !== false && !q, F2 = co(D2), R2 = o2._enterCb = I(function() {
          M2 && (Yr(o2, j2), Yr(o2, E2)), R2.cancelled ? (M2 && Yr(o2, S2), P2 && P2(o2)) : N2 && N2(o2), o2._enterCb = null;
        });
        t2.data.show || ne(t2, "insert", function() {
          var e2 = o2.parentNode, n2 = e2 && e2._pending && e2._pending[t2.key];
          n2 && n2.tag === t2.tag && n2.elm._leaveCb && n2.elm._leaveCb(), D2 && D2(o2, R2);
        }), T2 && T2(o2), M2 && (Qr(o2, S2), Qr(o2, E2), Jr(function() {
          Yr(o2, S2), R2.cancelled || (Qr(o2, j2), F2 || (so(L2) ? setTimeout(R2, L2) : to(o2, c2, R2)));
        })), t2.data.show && (r2 && r2(), D2 && D2(o2, R2)), M2 || F2 || R2();
      }
    }
  }
  function ao(t2, r2) {
    var o2 = t2.elm;
    n(o2._enterCb) && (o2._enterCb.cancelled = true, o2._enterCb());
    var a2 = Hr(t2.data.transition);
    if (e(a2) || o2.nodeType !== 1)
      return r2();
    if (!n(o2._leaveCb)) {
      var s2 = a2.css, c2 = a2.type, u2 = a2.leaveClass, l2 = a2.leaveToClass, p2 = a2.leaveActiveClass, d2 = a2.beforeLeave, v2 = a2.leave, h2 = a2.afterLeave, m2 = a2.leaveCancelled, y2 = a2.delayLeave, g2 = a2.duration, _2 = s2 !== false && !q, b2 = co(v2), C2 = f(i(g2) ? g2.leave : g2), $2 = o2._leaveCb = I(function() {
        o2.parentNode && o2.parentNode._pending && (o2.parentNode._pending[t2.key] = null), _2 && (Yr(o2, l2), Yr(o2, p2)), $2.cancelled ? (_2 && Yr(o2, u2), m2 && m2(o2)) : (r2(), h2 && h2(o2)), o2._leaveCb = null;
      });
      y2 ? y2(w2) : w2();
    }
    function w2() {
      $2.cancelled || (!t2.data.show && o2.parentNode && ((o2.parentNode._pending || (o2.parentNode._pending = {}))[t2.key] = t2), d2 && d2(o2), _2 && (Qr(o2, u2), Qr(o2, p2), Jr(function() {
        Yr(o2, u2), $2.cancelled || (Qr(o2, l2), b2 || (so(C2) ? setTimeout($2, C2) : to(o2, c2, $2)));
      })), v2 && v2(o2, $2), _2 || b2 || $2());
    }
  }
  function so(t2) {
    return typeof t2 == "number" && !isNaN(t2);
  }
  function co(t2) {
    if (e(t2))
      return false;
    var r2 = t2.fns;
    return n(r2) ? co(Array.isArray(r2) ? r2[0] : r2) : (t2._length || t2.length) > 1;
  }
  function uo(t2, e2) {
    e2.data.show !== true && io(e2);
  }
  var lo = function(t2) {
    var i2, a2, s2 = {}, c2 = t2.modules, u2 = t2.nodeOps;
    for (i2 = 0; i2 < Qn.length; ++i2)
      for (s2[Qn[i2]] = [], a2 = 0; a2 < c2.length; ++a2)
        n(c2[a2][Qn[i2]]) && s2[Qn[i2]].push(c2[a2][Qn[i2]]);
    function l2(t3) {
      var e2 = u2.parentNode(t3);
      n(e2) && u2.removeChild(e2, t3);
    }
    function f2(t3, e2, o2, i3, a3, c3, l3) {
      if (n(t3.elm) && n(c3) && (t3 = c3[l3] = vt(t3)), t3.isRootInsert = !a3, !function(t4, e3, o3, i4) {
        var a4 = t4.data;
        if (n(a4)) {
          var c4 = n(t4.componentInstance) && a4.keepAlive;
          if (n(a4 = a4.hook) && n(a4 = a4.init) && a4(t4, false), n(t4.componentInstance))
            return d2(t4, e3), v2(o3, t4.elm, i4), r(c4) && function(t5, e4, r2, o4) {
              for (var i5, a5 = t5; a5.componentInstance; )
                if (a5 = a5.componentInstance._vnode, n(i5 = a5.data) && n(i5 = i5.transition)) {
                  for (i5 = 0; i5 < s2.activate.length; ++i5)
                    s2.activate[i5](Jn, a5);
                  e4.push(a5);
                  break;
                }
              v2(r2, t5.elm, o4);
            }(t4, e3, o3, i4), true;
        }
      }(t3, e2, o2, i3)) {
        var f3 = t3.data, p2 = t3.children, m3 = t3.tag;
        n(m3) ? (t3.elm = t3.ns ? u2.createElementNS(t3.ns, m3) : u2.createElement(m3, t3), g2(t3), h2(t3, p2, e2), n(f3) && y2(t3, e2), v2(o2, t3.elm, i3)) : r(t3.isComment) ? (t3.elm = u2.createComment(t3.text), v2(o2, t3.elm, i3)) : (t3.elm = u2.createTextNode(t3.text), v2(o2, t3.elm, i3));
      }
    }
    function d2(t3, e2) {
      n(t3.data.pendingInsert) && (e2.push.apply(e2, t3.data.pendingInsert), t3.data.pendingInsert = null), t3.elm = t3.componentInstance.$el, m2(t3) ? (y2(t3, e2), g2(t3)) : (Zn(t3), e2.push(t3));
    }
    function v2(t3, e2, r2) {
      n(t3) && (n(r2) ? u2.parentNode(r2) === t3 && u2.insertBefore(t3, e2, r2) : u2.appendChild(t3, e2));
    }
    function h2(t3, e2, n2) {
      if (Array.isArray(e2))
        for (var r2 = 0; r2 < e2.length; ++r2)
          f2(e2[r2], n2, t3.elm, null, true, e2, r2);
      else
        o(t3.text) && u2.appendChild(t3.elm, u2.createTextNode(String(t3.text)));
    }
    function m2(t3) {
      for (; t3.componentInstance; )
        t3 = t3.componentInstance._vnode;
      return n(t3.tag);
    }
    function y2(t3, e2) {
      for (var r2 = 0; r2 < s2.create.length; ++r2)
        s2.create[r2](Jn, t3);
      n(i2 = t3.data.hook) && (n(i2.create) && i2.create(Jn, t3), n(i2.insert) && e2.push(t3));
    }
    function g2(t3) {
      var e2;
      if (n(e2 = t3.fnScopeId))
        u2.setStyleScope(t3.elm, e2);
      else
        for (var r2 = t3; r2; )
          n(e2 = r2.context) && n(e2 = e2.$options._scopeId) && u2.setStyleScope(t3.elm, e2), r2 = r2.parent;
      n(e2 = qe) && e2 !== t3.context && e2 !== t3.fnContext && n(e2 = e2.$options._scopeId) && u2.setStyleScope(t3.elm, e2);
    }
    function _2(t3, e2, n2, r2, o2, i3) {
      for (; r2 <= o2; ++r2)
        f2(n2[r2], i3, t3, e2, false, n2, r2);
    }
    function b2(t3) {
      var e2, r2, o2 = t3.data;
      if (n(o2))
        for (n(e2 = o2.hook) && n(e2 = e2.destroy) && e2(t3), e2 = 0; e2 < s2.destroy.length; ++e2)
          s2.destroy[e2](t3);
      if (n(e2 = t3.children))
        for (r2 = 0; r2 < t3.children.length; ++r2)
          b2(t3.children[r2]);
    }
    function C2(t3, e2, r2) {
      for (; e2 <= r2; ++e2) {
        var o2 = t3[e2];
        n(o2) && (n(o2.tag) ? ($2(o2), b2(o2)) : l2(o2.elm));
      }
    }
    function $2(t3, e2) {
      if (n(e2) || n(t3.data)) {
        var r2, o2 = s2.remove.length + 1;
        for (n(e2) ? e2.listeners += o2 : e2 = function(t4, e3) {
          function n2() {
            --n2.listeners == 0 && l2(t4);
          }
          return n2.listeners = e3, n2;
        }(t3.elm, o2), n(r2 = t3.componentInstance) && n(r2 = r2._vnode) && n(r2.data) && $2(r2, e2), r2 = 0; r2 < s2.remove.length; ++r2)
          s2.remove[r2](t3, e2);
        n(r2 = t3.data.hook) && n(r2 = r2.remove) ? r2(t3, e2) : e2();
      } else
        l2(t3.elm);
    }
    function w2(t3, e2, r2, o2) {
      for (var i3 = r2; i3 < o2; i3++) {
        var a3 = e2[i3];
        if (n(a3) && Yn(t3, a3))
          return i3;
      }
    }
    function A2(t3, o2, i3, a3, c3, l3) {
      if (t3 !== o2) {
        n(o2.elm) && n(a3) && (o2 = a3[c3] = vt(o2));
        var p2 = o2.elm = t3.elm;
        if (r(t3.isAsyncPlaceholder))
          n(o2.asyncFactory.resolved) ? k2(t3.elm, o2, i3) : o2.isAsyncPlaceholder = true;
        else if (r(o2.isStatic) && r(t3.isStatic) && o2.key === t3.key && (r(o2.isCloned) || r(o2.isOnce)))
          o2.componentInstance = t3.componentInstance;
        else {
          var d3, v3 = o2.data;
          n(v3) && n(d3 = v3.hook) && n(d3 = d3.prepatch) && d3(t3, o2);
          var h3 = t3.children, y3 = o2.children;
          if (n(v3) && m2(o2)) {
            for (d3 = 0; d3 < s2.update.length; ++d3)
              s2.update[d3](t3, o2);
            n(d3 = v3.hook) && n(d3 = d3.update) && d3(t3, o2);
          }
          e(o2.text) ? n(h3) && n(y3) ? h3 !== y3 && function(t4, r2, o3, i4, a4) {
            for (var s3, c4, l4, p3 = 0, d4 = 0, v4 = r2.length - 1, h4 = r2[0], m3 = r2[v4], y4 = o3.length - 1, g3 = o3[0], b3 = o3[y4], $3 = !a4; p3 <= v4 && d4 <= y4; )
              e(h4) ? h4 = r2[++p3] : e(m3) ? m3 = r2[--v4] : Yn(h4, g3) ? (A2(h4, g3, i4, o3, d4), h4 = r2[++p3], g3 = o3[++d4]) : Yn(m3, b3) ? (A2(m3, b3, i4, o3, y4), m3 = r2[--v4], b3 = o3[--y4]) : Yn(h4, b3) ? (A2(h4, b3, i4, o3, y4), $3 && u2.insertBefore(t4, h4.elm, u2.nextSibling(m3.elm)), h4 = r2[++p3], b3 = o3[--y4]) : Yn(m3, g3) ? (A2(m3, g3, i4, o3, d4), $3 && u2.insertBefore(t4, m3.elm, h4.elm), m3 = r2[--v4], g3 = o3[++d4]) : (e(s3) && (s3 = tr(r2, p3, v4)), e(c4 = n(g3.key) ? s3[g3.key] : w2(g3, r2, p3, v4)) ? f2(g3, i4, t4, h4.elm, false, o3, d4) : Yn(l4 = r2[c4], g3) ? (A2(l4, g3, i4, o3, d4), r2[c4] = void 0, $3 && u2.insertBefore(t4, l4.elm, h4.elm)) : f2(g3, i4, t4, h4.elm, false, o3, d4), g3 = o3[++d4]);
            p3 > v4 ? _2(t4, e(o3[y4 + 1]) ? null : o3[y4 + 1].elm, o3, d4, y4, i4) : d4 > y4 && C2(r2, p3, v4);
          }(p2, h3, y3, i3, l3) : n(y3) ? (n(t3.text) && u2.setTextContent(p2, ""), _2(p2, null, y3, 0, y3.length - 1, i3)) : n(h3) ? C2(h3, 0, h3.length - 1) : n(t3.text) && u2.setTextContent(p2, "") : t3.text !== o2.text && u2.setTextContent(p2, o2.text), n(v3) && n(d3 = v3.hook) && n(d3 = d3.postpatch) && d3(t3, o2);
        }
      }
    }
    function x2(t3, e2, o2) {
      if (r(o2) && n(t3.parent))
        t3.parent.data.pendingInsert = e2;
      else
        for (var i3 = 0; i3 < e2.length; ++i3)
          e2[i3].data.hook.insert(e2[i3]);
    }
    var O2 = p("attrs,class,staticClass,staticStyle,key");
    function k2(t3, e2, o2, i3) {
      var a3, s3 = e2.tag, c3 = e2.data, u3 = e2.children;
      if (i3 = i3 || c3 && c3.pre, e2.elm = t3, r(e2.isComment) && n(e2.asyncFactory))
        return e2.isAsyncPlaceholder = true, true;
      if (n(c3) && (n(a3 = c3.hook) && n(a3 = a3.init) && a3(e2, true), n(a3 = e2.componentInstance)))
        return d2(e2, o2), true;
      if (n(s3)) {
        if (n(u3))
          if (t3.hasChildNodes())
            if (n(a3 = c3) && n(a3 = a3.domProps) && n(a3 = a3.innerHTML)) {
              if (a3 !== t3.innerHTML)
                return false;
            } else {
              for (var l3 = true, f3 = t3.firstChild, p2 = 0; p2 < u3.length; p2++) {
                if (!f3 || !k2(f3, u3[p2], o2, i3)) {
                  l3 = false;
                  break;
                }
                f3 = f3.nextSibling;
              }
              if (!l3 || f3)
                return false;
            }
          else
            h2(e2, u3, o2);
        if (n(c3)) {
          var v3 = false;
          for (var m3 in c3)
            if (!O2(m3)) {
              v3 = true, y2(e2, o2);
              break;
            }
          !v3 && c3.class && Qt(c3.class);
        }
      } else
        t3.data !== e2.text && (t3.data = e2.text);
      return true;
    }
    return function(t3, o2, i3, a3) {
      if (!e(o2)) {
        var c3, l3 = false, p2 = [];
        if (e(t3))
          l3 = true, f2(o2, p2);
        else {
          var d3 = n(t3.nodeType);
          if (!d3 && Yn(t3, o2))
            A2(t3, o2, p2, null, null, a3);
          else {
            if (d3) {
              if (t3.nodeType === 1 && t3.hasAttribute(D) && (t3.removeAttribute(D), i3 = true), r(i3) && k2(t3, o2, p2))
                return x2(o2, p2, true), t3;
              c3 = t3, t3 = new lt(u2.tagName(c3).toLowerCase(), {}, [], void 0, c3);
            }
            var v3 = t3.elm, h3 = u2.parentNode(v3);
            if (f2(o2, p2, v3._leaveCb ? null : h3, u2.nextSibling(v3)), n(o2.parent))
              for (var y3 = o2.parent, g3 = m2(o2); y3; ) {
                for (var _3 = 0; _3 < s2.destroy.length; ++_3)
                  s2.destroy[_3](y3);
                if (y3.elm = o2.elm, g3) {
                  for (var $3 = 0; $3 < s2.create.length; ++$3)
                    s2.create[$3](Jn, y3);
                  var w3 = y3.data.hook.insert;
                  if (w3.merged)
                    for (var O3 = 1; O3 < w3.fns.length; O3++)
                      w3.fns[O3]();
                } else
                  Zn(y3);
                y3 = y3.parent;
              }
            n(h3) ? C2([t3], 0, 0) : n(t3.tag) && b2(t3);
          }
        }
        return x2(o2, p2, l3), o2.elm;
      }
      n(t3) && b2(t3);
    };
  }({nodeOps: Xn, modules: [fr, vr, wr, Or, Mr, H ? {create: uo, activate: uo, remove: function(t2, e2) {
    t2.data.show !== true ? ao(t2, e2) : e2();
  }} : {}].concat(sr)});
  q && document.addEventListener("selectionchange", function() {
    var t2 = document.activeElement;
    t2 && t2.vmodel && _o(t2, "input");
  });
  var fo = {inserted: function(t2, e2, n2, r2) {
    n2.tag === "select" ? (r2.elm && !r2.elm._vOptions ? ne(n2, "postpatch", function() {
      fo.componentUpdated(t2, e2, n2);
    }) : po(t2, e2, n2.context), t2._vOptions = [].map.call(t2.options, mo)) : (n2.tag === "textarea" || Kn(t2.type)) && (t2._vModifiers = e2.modifiers, e2.modifiers.lazy || (t2.addEventListener("compositionstart", yo), t2.addEventListener("compositionend", go), t2.addEventListener("change", go), q && (t2.vmodel = true)));
  }, componentUpdated: function(t2, e2, n2) {
    if (n2.tag === "select") {
      po(t2, e2, n2.context);
      var r2 = t2._vOptions, o2 = t2._vOptions = [].map.call(t2.options, mo);
      if (o2.some(function(t3, e3) {
        return !j(t3, r2[e3]);
      }))
        (t2.multiple ? e2.value.some(function(t3) {
          return ho(t3, o2);
        }) : e2.value !== e2.oldValue && ho(e2.value, o2)) && _o(t2, "change");
    }
  }};
  function po(t2, e2, n2) {
    vo(t2, e2, n2), (W || K) && setTimeout(function() {
      vo(t2, e2, n2);
    }, 0);
  }
  function vo(t2, e2, n2) {
    var r2 = e2.value, o2 = t2.multiple;
    if (!o2 || Array.isArray(r2)) {
      for (var i2, a2, s2 = 0, c2 = t2.options.length; s2 < c2; s2++)
        if (a2 = t2.options[s2], o2)
          i2 = T(r2, mo(a2)) > -1, a2.selected !== i2 && (a2.selected = i2);
        else if (j(mo(a2), r2))
          return void (t2.selectedIndex !== s2 && (t2.selectedIndex = s2));
      o2 || (t2.selectedIndex = -1);
    }
  }
  function ho(t2, e2) {
    return e2.every(function(e3) {
      return !j(e3, t2);
    });
  }
  function mo(t2) {
    return "_value" in t2 ? t2._value : t2.value;
  }
  function yo(t2) {
    t2.target.composing = true;
  }
  function go(t2) {
    t2.target.composing && (t2.target.composing = false, _o(t2.target, "input"));
  }
  function _o(t2, e2) {
    var n2 = document.createEvent("HTMLEvents");
    n2.initEvent(e2, true, true), t2.dispatchEvent(n2);
  }
  function bo(t2) {
    return !t2.componentInstance || t2.data && t2.data.transition ? t2 : bo(t2.componentInstance._vnode);
  }
  var Co = {model: fo, show: {bind: function(t2, e2, n2) {
    var r2 = e2.value, o2 = (n2 = bo(n2)).data && n2.data.transition, i2 = t2.__vOriginalDisplay = t2.style.display === "none" ? "" : t2.style.display;
    r2 && o2 ? (n2.data.show = true, io(n2, function() {
      t2.style.display = i2;
    })) : t2.style.display = r2 ? i2 : "none";
  }, update: function(t2, e2, n2) {
    var r2 = e2.value;
    !r2 != !e2.oldValue && ((n2 = bo(n2)).data && n2.data.transition ? (n2.data.show = true, r2 ? io(n2, function() {
      t2.style.display = t2.__vOriginalDisplay;
    }) : ao(n2, function() {
      t2.style.display = "none";
    })) : t2.style.display = r2 ? t2.__vOriginalDisplay : "none");
  }, unbind: function(t2, e2, n2, r2, o2) {
    o2 || (t2.style.display = t2.__vOriginalDisplay);
  }}};
  var $o = {name: String, appear: Boolean, css: Boolean, mode: String, type: String, enterClass: String, leaveClass: String, enterToClass: String, leaveToClass: String, enterActiveClass: String, leaveActiveClass: String, appearClass: String, appearActiveClass: String, appearToClass: String, duration: [Number, String, Object]};
  function wo(t2) {
    var e2 = t2 && t2.componentOptions;
    return e2 && e2.Ctor.options.abstract ? wo(He(e2.children)) : t2;
  }
  function Ao(t2) {
    var e2 = {}, n2 = t2.$options;
    for (var r2 in n2.propsData)
      e2[r2] = t2[r2];
    var o2 = n2._parentListeners;
    for (var i2 in o2)
      e2[_(i2)] = o2[i2];
    return e2;
  }
  function xo(t2, e2) {
    if (/\d-keep-alive$/.test(e2.tag))
      return t2("keep-alive", {props: e2.componentOptions.propsData});
  }
  var Oo = function(t2) {
    return t2.tag || Ue(t2);
  };
  var ko = function(t2) {
    return t2.name === "show";
  };
  var So = {name: "transition", props: $o, abstract: true, render: function(t2) {
    var e2 = this, n2 = this.$slots.default;
    if (n2 && (n2 = n2.filter(Oo)).length) {
      var r2 = this.mode, i2 = n2[0];
      if (function(t3) {
        for (; t3 = t3.parent; )
          if (t3.data.transition)
            return true;
      }(this.$vnode))
        return i2;
      var a2 = wo(i2);
      if (!a2)
        return i2;
      if (this._leaving)
        return xo(t2, i2);
      var s2 = "__transition-" + this._uid + "-";
      a2.key = a2.key == null ? a2.isComment ? s2 + "comment" : s2 + a2.tag : o(a2.key) ? String(a2.key).indexOf(s2) === 0 ? a2.key : s2 + a2.key : a2.key;
      var c2 = (a2.data || (a2.data = {})).transition = Ao(this), u2 = this._vnode, l2 = wo(u2);
      if (a2.data.directives && a2.data.directives.some(ko) && (a2.data.show = true), l2 && l2.data && !function(t3, e3) {
        return e3.key === t3.key && e3.tag === t3.tag;
      }(a2, l2) && !Ue(l2) && (!l2.componentInstance || !l2.componentInstance._vnode.isComment)) {
        var f2 = l2.data.transition = x({}, c2);
        if (r2 === "out-in")
          return this._leaving = true, ne(f2, "afterLeave", function() {
            e2._leaving = false, e2.$forceUpdate();
          }), xo(t2, i2);
        if (r2 === "in-out") {
          if (Ue(a2))
            return u2;
          var p2, d2 = function() {
            p2();
          };
          ne(c2, "afterEnter", d2), ne(c2, "enterCancelled", d2), ne(f2, "delayLeave", function(t3) {
            p2 = t3;
          });
        }
      }
      return i2;
    }
  }};
  var Eo = x({tag: String, moveClass: String}, $o);
  function jo(t2) {
    t2.elm._moveCb && t2.elm._moveCb(), t2.elm._enterCb && t2.elm._enterCb();
  }
  function To(t2) {
    t2.data.newPos = t2.elm.getBoundingClientRect();
  }
  function Io(t2) {
    var e2 = t2.data.pos, n2 = t2.data.newPos, r2 = e2.left - n2.left, o2 = e2.top - n2.top;
    if (r2 || o2) {
      t2.data.moved = true;
      var i2 = t2.elm.style;
      i2.transform = i2.WebkitTransform = "translate(" + r2 + "px," + o2 + "px)", i2.transitionDuration = "0s";
    }
  }
  delete Eo.mode;
  var Do = {Transition: So, TransitionGroup: {props: Eo, beforeMount: function() {
    var t2 = this, e2 = this._update;
    this._update = function(n2, r2) {
      var o2 = Ke(t2);
      t2.__patch__(t2._vnode, t2.kept, false, true), t2._vnode = t2.kept, o2(), e2.call(t2, n2, r2);
    };
  }, render: function(t2) {
    for (var e2 = this.tag || this.$vnode.data.tag || "span", n2 = Object.create(null), r2 = this.prevChildren = this.children, o2 = this.$slots.default || [], i2 = this.children = [], a2 = Ao(this), s2 = 0; s2 < o2.length; s2++) {
      var c2 = o2[s2];
      c2.tag && c2.key != null && String(c2.key).indexOf("__vlist") !== 0 && (i2.push(c2), n2[c2.key] = c2, (c2.data || (c2.data = {})).transition = a2);
    }
    if (r2) {
      for (var u2 = [], l2 = [], f2 = 0; f2 < r2.length; f2++) {
        var p2 = r2[f2];
        p2.data.transition = a2, p2.data.pos = p2.elm.getBoundingClientRect(), n2[p2.key] ? u2.push(p2) : l2.push(p2);
      }
      this.kept = t2(e2, null, u2), this.removed = l2;
    }
    return t2(e2, null, i2);
  }, updated: function() {
    var t2 = this.prevChildren, e2 = this.moveClass || (this.name || "v") + "-move";
    t2.length && this.hasMove(t2[0].elm, e2) && (t2.forEach(jo), t2.forEach(To), t2.forEach(Io), this._reflow = document.body.offsetHeight, t2.forEach(function(t3) {
      if (t3.data.moved) {
        var n2 = t3.elm, r2 = n2.style;
        Qr(n2, e2), r2.transform = r2.WebkitTransform = r2.transitionDuration = "", n2.addEventListener(Kr, n2._moveCb = function t4(r3) {
          r3 && r3.target !== n2 || r3 && !/transform$/.test(r3.propertyName) || (n2.removeEventListener(Kr, t4), n2._moveCb = null, Yr(n2, e2));
        });
      }
    }));
  }, methods: {hasMove: function(t2, e2) {
    if (!Vr)
      return false;
    if (this._hasMove)
      return this._hasMove;
    var n2 = t2.cloneNode();
    t2._transitionClasses && t2._transitionClasses.forEach(function(t3) {
      Ur(n2, t3);
    }), Rr(n2, e2), n2.style.display = "none", this.$el.appendChild(n2);
    var r2 = no(n2);
    return this.$el.removeChild(n2), this._hasMove = r2.hasTransform;
  }}}};
  bn.config.mustUseProp = function(t2, e2, n2) {
    return n2 === "value" && En(t2) && e2 !== "button" || n2 === "selected" && t2 === "option" || n2 === "checked" && t2 === "input" || n2 === "muted" && t2 === "video";
  }, bn.config.isReservedTag = Wn, bn.config.isReservedAttr = Sn, bn.config.getTagNamespace = function(t2) {
    return zn(t2) ? "svg" : t2 === "math" ? "math" : void 0;
  }, bn.config.isUnknownElement = function(t2) {
    if (!H)
      return true;
    if (Wn(t2))
      return false;
    if (t2 = t2.toLowerCase(), qn[t2] != null)
      return qn[t2];
    var e2 = document.createElement(t2);
    return t2.indexOf("-") > -1 ? qn[t2] = e2.constructor === window.HTMLUnknownElement || e2.constructor === window.HTMLElement : qn[t2] = /HTMLUnknownElement/.test(e2.toString());
  }, x(bn.options.directives, Co), x(bn.options.components, Do), bn.prototype.__patch__ = H ? lo : k, bn.prototype.$mount = function(t2, e2) {
    return function(t3, e3, n2) {
      var r2;
      return t3.$el = e3, t3.$options.render || (t3.$options.render = pt), Ze(t3, "beforeMount"), r2 = function() {
        t3._update(t3._render(), n2);
      }, new un(t3, r2, k, {before: function() {
        t3._isMounted && !t3._isDestroyed && Ze(t3, "beforeUpdate");
      }}, true), n2 = false, t3.$vnode == null && (t3._isMounted = true, Ze(t3, "mounted")), t3;
    }(this, t2 = t2 && H ? function(t3) {
      if (typeof t3 == "string") {
        var e3 = document.querySelector(t3);
        return e3 || document.createElement("div");
      }
      return t3;
    }(t2) : void 0, e2);
  }, H && setTimeout(function() {
    L.devtools && tt && tt.emit("init", bn);
  }, 0), module2.exports = bn;
});

// node_modules/vue/dist/vue.runtime.common.dev.js
var require_vue_runtime_common_dev = __commonJS((exports2, module2) => {
  /*!
   * Vue.js v2.6.12
   * (c) 2014-2020 Evan You
   * Released under the MIT License.
   */
  "use strict";
  var emptyObject = Object.freeze({});
  function isUndef(v) {
    return v === void 0 || v === null;
  }
  function isDef(v) {
    return v !== void 0 && v !== null;
  }
  function isTrue(v) {
    return v === true;
  }
  function isFalse(v) {
    return v === false;
  }
  function isPrimitive(value) {
    return typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "boolean";
  }
  function isObject(obj) {
    return obj !== null && typeof obj === "object";
  }
  var _toString = Object.prototype.toString;
  function toRawType(value) {
    return _toString.call(value).slice(8, -1);
  }
  function isPlainObject(obj) {
    return _toString.call(obj) === "[object Object]";
  }
  function isRegExp(v) {
    return _toString.call(v) === "[object RegExp]";
  }
  function isValidArrayIndex(val) {
    var n = parseFloat(String(val));
    return n >= 0 && Math.floor(n) === n && isFinite(val);
  }
  function isPromise(val) {
    return isDef(val) && typeof val.then === "function" && typeof val.catch === "function";
  }
  function toString(val) {
    return val == null ? "" : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
  }
  function toNumber(val) {
    var n = parseFloat(val);
    return isNaN(n) ? val : n;
  }
  function makeMap(str, expectsLowerCase) {
    var map = Object.create(null);
    var list = str.split(",");
    for (var i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return expectsLowerCase ? function(val) {
      return map[val.toLowerCase()];
    } : function(val) {
      return map[val];
    };
  }
  var isBuiltInTag = makeMap("slot,component", true);
  var isReservedAttribute = makeMap("key,ref,slot,slot-scope,is");
  function remove(arr, item) {
    if (arr.length) {
      var index2 = arr.indexOf(item);
      if (index2 > -1) {
        return arr.splice(index2, 1);
      }
    }
  }
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function hasOwn(obj, key) {
    return hasOwnProperty.call(obj, key);
  }
  function cached(fn) {
    var cache = Object.create(null);
    return function cachedFn(str) {
      var hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  }
  var camelizeRE = /-(\w)/g;
  var camelize = cached(function(str) {
    return str.replace(camelizeRE, function(_, c) {
      return c ? c.toUpperCase() : "";
    });
  });
  var capitalize = cached(function(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cached(function(str) {
    return str.replace(hyphenateRE, "-$1").toLowerCase();
  });
  function polyfillBind(fn, ctx) {
    function boundFn(a) {
      var l = arguments.length;
      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
    }
    boundFn._length = fn.length;
    return boundFn;
  }
  function nativeBind(fn, ctx) {
    return fn.bind(ctx);
  }
  var bind = Function.prototype.bind ? nativeBind : polyfillBind;
  function toArray(list, start) {
    start = start || 0;
    var i = list.length - start;
    var ret = new Array(i);
    while (i--) {
      ret[i] = list[i + start];
    }
    return ret;
  }
  function extend(to, _from) {
    for (var key in _from) {
      to[key] = _from[key];
    }
    return to;
  }
  function toObject(arr) {
    var res = {};
    for (var i = 0; i < arr.length; i++) {
      if (arr[i]) {
        extend(res, arr[i]);
      }
    }
    return res;
  }
  function noop(a, b, c) {
  }
  var no = function(a, b, c) {
    return false;
  };
  var identity = function(_) {
    return _;
  };
  function looseEqual(a, b) {
    if (a === b) {
      return true;
    }
    var isObjectA = isObject(a);
    var isObjectB = isObject(b);
    if (isObjectA && isObjectB) {
      try {
        var isArrayA = Array.isArray(a);
        var isArrayB = Array.isArray(b);
        if (isArrayA && isArrayB) {
          return a.length === b.length && a.every(function(e, i) {
            return looseEqual(e, b[i]);
          });
        } else if (a instanceof Date && b instanceof Date) {
          return a.getTime() === b.getTime();
        } else if (!isArrayA && !isArrayB) {
          var keysA = Object.keys(a);
          var keysB = Object.keys(b);
          return keysA.length === keysB.length && keysA.every(function(key) {
            return looseEqual(a[key], b[key]);
          });
        } else {
          return false;
        }
      } catch (e) {
        return false;
      }
    } else if (!isObjectA && !isObjectB) {
      return String(a) === String(b);
    } else {
      return false;
    }
  }
  function looseIndexOf(arr, val) {
    for (var i = 0; i < arr.length; i++) {
      if (looseEqual(arr[i], val)) {
        return i;
      }
    }
    return -1;
  }
  function once(fn) {
    var called = false;
    return function() {
      if (!called) {
        called = true;
        fn.apply(this, arguments);
      }
    };
  }
  var SSR_ATTR = "data-server-rendered";
  var ASSET_TYPES = [
    "component",
    "directive",
    "filter"
  ];
  var LIFECYCLE_HOOKS = [
    "beforeCreate",
    "created",
    "beforeMount",
    "mounted",
    "beforeUpdate",
    "updated",
    "beforeDestroy",
    "destroyed",
    "activated",
    "deactivated",
    "errorCaptured",
    "serverPrefetch"
  ];
  var config = {
    optionMergeStrategies: Object.create(null),
    silent: false,
    productionTip: true,
    devtools: true,
    performance: false,
    errorHandler: null,
    warnHandler: null,
    ignoredElements: [],
    keyCodes: Object.create(null),
    isReservedTag: no,
    isReservedAttr: no,
    isUnknownElement: no,
    getTagNamespace: noop,
    parsePlatformTagName: identity,
    mustUseProp: no,
    async: true,
    _lifecycleHooks: LIFECYCLE_HOOKS
  };
  var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
  function isReserved(str) {
    var c = (str + "").charCodeAt(0);
    return c === 36 || c === 95;
  }
  function def(obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
      value: val,
      enumerable: !!enumerable,
      writable: true,
      configurable: true
    });
  }
  var bailRE = new RegExp("[^" + unicodeRegExp.source + ".$_\\d]");
  function parsePath(path) {
    if (bailRE.test(path)) {
      return;
    }
    var segments = path.split(".");
    return function(obj) {
      for (var i = 0; i < segments.length; i++) {
        if (!obj) {
          return;
        }
        obj = obj[segments[i]];
      }
      return obj;
    };
  }
  var hasProto = "__proto__" in {};
  var inBrowser = typeof window !== "undefined";
  var inWeex = typeof WXEnvironment !== "undefined" && !!WXEnvironment.platform;
  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
  var UA = inBrowser && window.navigator.userAgent.toLowerCase();
  var isIE = UA && /msie|trident/.test(UA);
  var isIE9 = UA && UA.indexOf("msie 9.0") > 0;
  var isEdge = UA && UA.indexOf("edge/") > 0;
  var isAndroid = UA && UA.indexOf("android") > 0 || weexPlatform === "android";
  var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === "ios";
  var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
  var isPhantomJS = UA && /phantomjs/.test(UA);
  var isFF = UA && UA.match(/firefox\/(\d+)/);
  var nativeWatch = {}.watch;
  var supportsPassive = false;
  if (inBrowser) {
    try {
      opts = {};
      Object.defineProperty(opts, "passive", {
        get: function get() {
          supportsPassive = true;
        }
      });
      window.addEventListener("test-passive", null, opts);
    } catch (e) {
    }
  }
  var opts;
  var _isServer;
  var isServerRendering = function() {
    if (_isServer === void 0) {
      if (!inBrowser && !inWeex && typeof global !== "undefined") {
        _isServer = global["process"] && global["process"].env.VUE_ENV === "server";
      } else {
        _isServer = false;
      }
    }
    return _isServer;
  };
  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
  function isNative(Ctor) {
    return typeof Ctor === "function" && /native code/.test(Ctor.toString());
  }
  var hasSymbol = typeof Symbol !== "undefined" && isNative(Symbol) && typeof Reflect !== "undefined" && isNative(Reflect.ownKeys);
  var _Set;
  if (typeof Set !== "undefined" && isNative(Set)) {
    _Set = Set;
  } else {
    _Set = /* @__PURE__ */ function() {
      function Set2() {
        this.set = Object.create(null);
      }
      Set2.prototype.has = function has2(key) {
        return this.set[key] === true;
      };
      Set2.prototype.add = function add2(key) {
        this.set[key] = true;
      };
      Set2.prototype.clear = function clear() {
        this.set = Object.create(null);
      };
      return Set2;
    }();
  }
  var warn = noop;
  var tip = noop;
  var generateComponentTrace = noop;
  var formatComponentName = noop;
  {
    hasConsole = typeof console !== "undefined";
    classifyRE = /(?:^|[-_])(\w)/g;
    classify = function(str) {
      return str.replace(classifyRE, function(c) {
        return c.toUpperCase();
      }).replace(/[-_]/g, "");
    };
    warn = function(msg, vm) {
      var trace = vm ? generateComponentTrace(vm) : "";
      if (config.warnHandler) {
        config.warnHandler.call(null, msg, vm, trace);
      } else if (hasConsole && !config.silent) {
        console.error("[Vue warn]: " + msg + trace);
      }
    };
    tip = function(msg, vm) {
      if (hasConsole && !config.silent) {
        console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ""));
      }
    };
    formatComponentName = function(vm, includeFile) {
      if (vm.$root === vm) {
        return "<Root>";
      }
      var options = typeof vm === "function" && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
      var name2 = options.name || options._componentTag;
      var file = options.__file;
      if (!name2 && file) {
        var match = file.match(/([^/\\]+)\.vue$/);
        name2 = match && match[1];
      }
      return (name2 ? "<" + classify(name2) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : "");
    };
    repeat = function(str, n) {
      var res = "";
      while (n) {
        if (n % 2 === 1) {
          res += str;
        }
        if (n > 1) {
          str += str;
        }
        n >>= 1;
      }
      return res;
    };
    generateComponentTrace = function(vm) {
      if (vm._isVue && vm.$parent) {
        var tree = [];
        var currentRecursiveSequence = 0;
        while (vm) {
          if (tree.length > 0) {
            var last = tree[tree.length - 1];
            if (last.constructor === vm.constructor) {
              currentRecursiveSequence++;
              vm = vm.$parent;
              continue;
            } else if (currentRecursiveSequence > 0) {
              tree[tree.length - 1] = [last, currentRecursiveSequence];
              currentRecursiveSequence = 0;
            }
          }
          tree.push(vm);
          vm = vm.$parent;
        }
        return "\n\nfound in\n\n" + tree.map(function(vm2, i) {
          return "" + (i === 0 ? "---> " : repeat(" ", 5 + i * 2)) + (Array.isArray(vm2) ? formatComponentName(vm2[0]) + "... (" + vm2[1] + " recursive calls)" : formatComponentName(vm2));
        }).join("\n");
      } else {
        return "\n\n(found in " + formatComponentName(vm) + ")";
      }
    };
  }
  var hasConsole;
  var classifyRE;
  var classify;
  var repeat;
  var uid = 0;
  var Dep = function Dep2() {
    this.id = uid++;
    this.subs = [];
  };
  Dep.prototype.addSub = function addSub(sub) {
    this.subs.push(sub);
  };
  Dep.prototype.removeSub = function removeSub(sub) {
    remove(this.subs, sub);
  };
  Dep.prototype.depend = function depend() {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  };
  Dep.prototype.notify = function notify() {
    var subs = this.subs.slice();
    if (!config.async) {
      subs.sort(function(a, b) {
        return a.id - b.id;
      });
    }
    for (var i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  };
  Dep.target = null;
  var targetStack = [];
  function pushTarget(target2) {
    targetStack.push(target2);
    Dep.target = target2;
  }
  function popTarget() {
    targetStack.pop();
    Dep.target = targetStack[targetStack.length - 1];
  }
  var VNode = function VNode2(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
    this.tag = tag;
    this.data = data;
    this.children = children;
    this.text = text;
    this.elm = elm;
    this.ns = void 0;
    this.context = context;
    this.fnContext = void 0;
    this.fnOptions = void 0;
    this.fnScopeId = void 0;
    this.key = data && data.key;
    this.componentOptions = componentOptions;
    this.componentInstance = void 0;
    this.parent = void 0;
    this.raw = false;
    this.isStatic = false;
    this.isRootInsert = true;
    this.isComment = false;
    this.isCloned = false;
    this.isOnce = false;
    this.asyncFactory = asyncFactory;
    this.asyncMeta = void 0;
    this.isAsyncPlaceholder = false;
  };
  var prototypeAccessors = {child: {configurable: true}};
  prototypeAccessors.child.get = function() {
    return this.componentInstance;
  };
  Object.defineProperties(VNode.prototype, prototypeAccessors);
  var createEmptyVNode = function(text) {
    if (text === void 0)
      text = "";
    var node = new VNode();
    node.text = text;
    node.isComment = true;
    return node;
  };
  function createTextVNode(val) {
    return new VNode(void 0, void 0, void 0, String(val));
  }
  function cloneVNode(vnode) {
    var cloned = new VNode(vnode.tag, vnode.data, vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
    cloned.ns = vnode.ns;
    cloned.isStatic = vnode.isStatic;
    cloned.key = vnode.key;
    cloned.isComment = vnode.isComment;
    cloned.fnContext = vnode.fnContext;
    cloned.fnOptions = vnode.fnOptions;
    cloned.fnScopeId = vnode.fnScopeId;
    cloned.asyncMeta = vnode.asyncMeta;
    cloned.isCloned = true;
    return cloned;
  }
  var arrayProto = Array.prototype;
  var arrayMethods = Object.create(arrayProto);
  var methodsToPatch = [
    "push",
    "pop",
    "shift",
    "unshift",
    "splice",
    "sort",
    "reverse"
  ];
  methodsToPatch.forEach(function(method) {
    var original = arrayProto[method];
    def(arrayMethods, method, function mutator() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var result = original.apply(this, args);
      var ob = this.__ob__;
      var inserted;
      switch (method) {
        case "push":
        case "unshift":
          inserted = args;
          break;
        case "splice":
          inserted = args.slice(2);
          break;
      }
      if (inserted) {
        ob.observeArray(inserted);
      }
      ob.dep.notify();
      return result;
    });
  });
  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
  var shouldObserve = true;
  function toggleObserving(value) {
    shouldObserve = value;
  }
  var Observer = function Observer2(value) {
    this.value = value;
    this.dep = new Dep();
    this.vmCount = 0;
    def(value, "__ob__", this);
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods);
      } else {
        copyAugment(value, arrayMethods, arrayKeys);
      }
      this.observeArray(value);
    } else {
      this.walk(value);
    }
  };
  Observer.prototype.walk = function walk(obj) {
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
      defineReactive$$1(obj, keys[i]);
    }
  };
  Observer.prototype.observeArray = function observeArray(items) {
    for (var i = 0, l = items.length; i < l; i++) {
      observe(items[i]);
    }
  };
  function protoAugment(target2, src) {
    target2.__proto__ = src;
  }
  function copyAugment(target2, src, keys) {
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      def(target2, key, src[key]);
    }
  }
  function observe(value, asRootData) {
    if (!isObject(value) || value instanceof VNode) {
      return;
    }
    var ob;
    if (hasOwn(value, "__ob__") && value.__ob__ instanceof Observer) {
      ob = value.__ob__;
    } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
      ob = new Observer(value);
    }
    if (asRootData && ob) {
      ob.vmCount++;
    }
    return ob;
  }
  function defineReactive$$1(obj, key, val, customSetter, shallow) {
    var dep = new Dep();
    var property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
      return;
    }
    var getter = property && property.get;
    var setter = property && property.set;
    if ((!getter || setter) && arguments.length === 2) {
      val = obj[key];
    }
    var childOb = !shallow && observe(val);
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get: function reactiveGetter() {
        var value = getter ? getter.call(obj) : val;
        if (Dep.target) {
          dep.depend();
          if (childOb) {
            childOb.dep.depend();
            if (Array.isArray(value)) {
              dependArray(value);
            }
          }
        }
        return value;
      },
      set: function reactiveSetter(newVal) {
        var value = getter ? getter.call(obj) : val;
        if (newVal === value || newVal !== newVal && value !== value) {
          return;
        }
        if (customSetter) {
          customSetter();
        }
        if (getter && !setter) {
          return;
        }
        if (setter) {
          setter.call(obj, newVal);
        } else {
          val = newVal;
        }
        childOb = !shallow && observe(newVal);
        dep.notify();
      }
    });
  }
  function set(target2, key, val) {
    if (isUndef(target2) || isPrimitive(target2)) {
      warn("Cannot set reactive property on undefined, null, or primitive value: " + target2);
    }
    if (Array.isArray(target2) && isValidArrayIndex(key)) {
      target2.length = Math.max(target2.length, key);
      target2.splice(key, 1, val);
      return val;
    }
    if (key in target2 && !(key in Object.prototype)) {
      target2[key] = val;
      return val;
    }
    var ob = target2.__ob__;
    if (target2._isVue || ob && ob.vmCount) {
      warn("Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option.");
      return val;
    }
    if (!ob) {
      target2[key] = val;
      return val;
    }
    defineReactive$$1(ob.value, key, val);
    ob.dep.notify();
    return val;
  }
  function del(target2, key) {
    if (isUndef(target2) || isPrimitive(target2)) {
      warn("Cannot delete reactive property on undefined, null, or primitive value: " + target2);
    }
    if (Array.isArray(target2) && isValidArrayIndex(key)) {
      target2.splice(key, 1);
      return;
    }
    var ob = target2.__ob__;
    if (target2._isVue || ob && ob.vmCount) {
      warn("Avoid deleting properties on a Vue instance or its root $data - just set it to null.");
      return;
    }
    if (!hasOwn(target2, key)) {
      return;
    }
    delete target2[key];
    if (!ob) {
      return;
    }
    ob.dep.notify();
  }
  function dependArray(value) {
    for (var e = void 0, i = 0, l = value.length; i < l; i++) {
      e = value[i];
      e && e.__ob__ && e.__ob__.dep.depend();
      if (Array.isArray(e)) {
        dependArray(e);
      }
    }
  }
  var strats = config.optionMergeStrategies;
  {
    strats.el = strats.propsData = function(parent, child, vm, key) {
      if (!vm) {
        warn('option "' + key + '" can only be used during instance creation with the `new` keyword.');
      }
      return defaultStrat(parent, child);
    };
  }
  function mergeData(to, from) {
    if (!from) {
      return to;
    }
    var key, toVal, fromVal;
    var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      key = keys[i];
      if (key === "__ob__") {
        continue;
      }
      toVal = to[key];
      fromVal = from[key];
      if (!hasOwn(to, key)) {
        set(to, key, fromVal);
      } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {
        mergeData(toVal, fromVal);
      }
    }
    return to;
  }
  function mergeDataOrFn(parentVal, childVal, vm) {
    if (!vm) {
      if (!childVal) {
        return parentVal;
      }
      if (!parentVal) {
        return childVal;
      }
      return function mergedDataFn() {
        return mergeData(typeof childVal === "function" ? childVal.call(this, this) : childVal, typeof parentVal === "function" ? parentVal.call(this, this) : parentVal);
      };
    } else {
      return function mergedInstanceDataFn() {
        var instanceData = typeof childVal === "function" ? childVal.call(vm, vm) : childVal;
        var defaultData = typeof parentVal === "function" ? parentVal.call(vm, vm) : parentVal;
        if (instanceData) {
          return mergeData(instanceData, defaultData);
        } else {
          return defaultData;
        }
      };
    }
  }
  strats.data = function(parentVal, childVal, vm) {
    if (!vm) {
      if (childVal && typeof childVal !== "function") {
        warn('The "data" option should be a function that returns a per-instance value in component definitions.', vm);
        return parentVal;
      }
      return mergeDataOrFn(parentVal, childVal);
    }
    return mergeDataOrFn(parentVal, childVal, vm);
  };
  function mergeHook(parentVal, childVal) {
    var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
    return res ? dedupeHooks(res) : res;
  }
  function dedupeHooks(hooks2) {
    var res = [];
    for (var i = 0; i < hooks2.length; i++) {
      if (res.indexOf(hooks2[i]) === -1) {
        res.push(hooks2[i]);
      }
    }
    return res;
  }
  LIFECYCLE_HOOKS.forEach(function(hook) {
    strats[hook] = mergeHook;
  });
  function mergeAssets(parentVal, childVal, vm, key) {
    var res = Object.create(parentVal || null);
    if (childVal) {
      assertObjectType(key, childVal, vm);
      return extend(res, childVal);
    } else {
      return res;
    }
  }
  ASSET_TYPES.forEach(function(type) {
    strats[type + "s"] = mergeAssets;
  });
  strats.watch = function(parentVal, childVal, vm, key) {
    if (parentVal === nativeWatch) {
      parentVal = void 0;
    }
    if (childVal === nativeWatch) {
      childVal = void 0;
    }
    if (!childVal) {
      return Object.create(parentVal || null);
    }
    {
      assertObjectType(key, childVal, vm);
    }
    if (!parentVal) {
      return childVal;
    }
    var ret = {};
    extend(ret, parentVal);
    for (var key$1 in childVal) {
      var parent = ret[key$1];
      var child = childVal[key$1];
      if (parent && !Array.isArray(parent)) {
        parent = [parent];
      }
      ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
    }
    return ret;
  };
  strats.props = strats.methods = strats.inject = strats.computed = function(parentVal, childVal, vm, key) {
    if (childVal && true) {
      assertObjectType(key, childVal, vm);
    }
    if (!parentVal) {
      return childVal;
    }
    var ret = Object.create(null);
    extend(ret, parentVal);
    if (childVal) {
      extend(ret, childVal);
    }
    return ret;
  };
  strats.provide = mergeDataOrFn;
  var defaultStrat = function(parentVal, childVal) {
    return childVal === void 0 ? parentVal : childVal;
  };
  function checkComponents(options) {
    for (var key in options.components) {
      validateComponentName(key);
    }
  }
  function validateComponentName(name2) {
    if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeRegExp.source + "]*$").test(name2)) {
      warn('Invalid component name: "' + name2 + '". Component names should conform to valid custom element name in html5 specification.');
    }
    if (isBuiltInTag(name2) || config.isReservedTag(name2)) {
      warn("Do not use built-in or reserved HTML elements as component id: " + name2);
    }
  }
  function normalizeProps(options, vm) {
    var props2 = options.props;
    if (!props2) {
      return;
    }
    var res = {};
    var i, val, name2;
    if (Array.isArray(props2)) {
      i = props2.length;
      while (i--) {
        val = props2[i];
        if (typeof val === "string") {
          name2 = camelize(val);
          res[name2] = {type: null};
        } else {
          warn("props must be strings when using array syntax.");
        }
      }
    } else if (isPlainObject(props2)) {
      for (var key in props2) {
        val = props2[key];
        name2 = camelize(key);
        res[name2] = isPlainObject(val) ? val : {type: val};
      }
    } else {
      warn('Invalid value for option "props": expected an Array or an Object, but got ' + toRawType(props2) + ".", vm);
    }
    options.props = res;
  }
  function normalizeInject(options, vm) {
    var inject = options.inject;
    if (!inject) {
      return;
    }
    var normalized = options.inject = {};
    if (Array.isArray(inject)) {
      for (var i = 0; i < inject.length; i++) {
        normalized[inject[i]] = {from: inject[i]};
      }
    } else if (isPlainObject(inject)) {
      for (var key in inject) {
        var val = inject[key];
        normalized[key] = isPlainObject(val) ? extend({from: key}, val) : {from: val};
      }
    } else {
      warn('Invalid value for option "inject": expected an Array or an Object, but got ' + toRawType(inject) + ".", vm);
    }
  }
  function normalizeDirectives(options) {
    var dirs = options.directives;
    if (dirs) {
      for (var key in dirs) {
        var def$$1 = dirs[key];
        if (typeof def$$1 === "function") {
          dirs[key] = {bind: def$$1, update: def$$1};
        }
      }
    }
  }
  function assertObjectType(name2, value, vm) {
    if (!isPlainObject(value)) {
      warn('Invalid value for option "' + name2 + '": expected an Object, but got ' + toRawType(value) + ".", vm);
    }
  }
  function mergeOptions(parent, child, vm) {
    {
      checkComponents(child);
    }
    if (typeof child === "function") {
      child = child.options;
    }
    normalizeProps(child, vm);
    normalizeInject(child, vm);
    normalizeDirectives(child);
    if (!child._base) {
      if (child.extends) {
        parent = mergeOptions(parent, child.extends, vm);
      }
      if (child.mixins) {
        for (var i = 0, l = child.mixins.length; i < l; i++) {
          parent = mergeOptions(parent, child.mixins[i], vm);
        }
      }
    }
    var options = {};
    var key;
    for (key in parent) {
      mergeField(key);
    }
    for (key in child) {
      if (!hasOwn(parent, key)) {
        mergeField(key);
      }
    }
    function mergeField(key2) {
      var strat = strats[key2] || defaultStrat;
      options[key2] = strat(parent[key2], child[key2], vm, key2);
    }
    return options;
  }
  function resolveAsset(options, type, id, warnMissing) {
    if (typeof id !== "string") {
      return;
    }
    var assets = options[type];
    if (hasOwn(assets, id)) {
      return assets[id];
    }
    var camelizedId = camelize(id);
    if (hasOwn(assets, camelizedId)) {
      return assets[camelizedId];
    }
    var PascalCaseId = capitalize(camelizedId);
    if (hasOwn(assets, PascalCaseId)) {
      return assets[PascalCaseId];
    }
    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
    if (warnMissing && !res) {
      warn("Failed to resolve " + type.slice(0, -1) + ": " + id, options);
    }
    return res;
  }
  function validateProp(key, propOptions, propsData, vm) {
    var prop = propOptions[key];
    var absent = !hasOwn(propsData, key);
    var value = propsData[key];
    var booleanIndex = getTypeIndex(Boolean, prop.type);
    if (booleanIndex > -1) {
      if (absent && !hasOwn(prop, "default")) {
        value = false;
      } else if (value === "" || value === hyphenate(key)) {
        var stringIndex = getTypeIndex(String, prop.type);
        if (stringIndex < 0 || booleanIndex < stringIndex) {
          value = true;
        }
      }
    }
    if (value === void 0) {
      value = getPropDefaultValue(vm, prop, key);
      var prevShouldObserve = shouldObserve;
      toggleObserving(true);
      observe(value);
      toggleObserving(prevShouldObserve);
    }
    {
      assertProp(prop, key, value, vm, absent);
    }
    return value;
  }
  function getPropDefaultValue(vm, prop, key) {
    if (!hasOwn(prop, "default")) {
      return void 0;
    }
    var def2 = prop.default;
    if (isObject(def2)) {
      warn('Invalid default value for prop "' + key + '": Props with type Object/Array must use a factory function to return the default value.', vm);
    }
    if (vm && vm.$options.propsData && vm.$options.propsData[key] === void 0 && vm._props[key] !== void 0) {
      return vm._props[key];
    }
    return typeof def2 === "function" && getType(prop.type) !== "Function" ? def2.call(vm) : def2;
  }
  function assertProp(prop, name2, value, vm, absent) {
    if (prop.required && absent) {
      warn('Missing required prop: "' + name2 + '"', vm);
      return;
    }
    if (value == null && !prop.required) {
      return;
    }
    var type = prop.type;
    var valid = !type || type === true;
    var expectedTypes = [];
    if (type) {
      if (!Array.isArray(type)) {
        type = [type];
      }
      for (var i = 0; i < type.length && !valid; i++) {
        var assertedType = assertType(value, type[i]);
        expectedTypes.push(assertedType.expectedType || "");
        valid = assertedType.valid;
      }
    }
    if (!valid) {
      warn(getInvalidTypeMessage(name2, value, expectedTypes), vm);
      return;
    }
    var validator = prop.validator;
    if (validator) {
      if (!validator(value)) {
        warn('Invalid prop: custom validator check failed for prop "' + name2 + '".', vm);
      }
    }
  }
  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;
  function assertType(value, type) {
    var valid;
    var expectedType = getType(type);
    if (simpleCheckRE.test(expectedType)) {
      var t = typeof value;
      valid = t === expectedType.toLowerCase();
      if (!valid && t === "object") {
        valid = value instanceof type;
      }
    } else if (expectedType === "Object") {
      valid = isPlainObject(value);
    } else if (expectedType === "Array") {
      valid = Array.isArray(value);
    } else {
      valid = value instanceof type;
    }
    return {
      valid,
      expectedType
    };
  }
  function getType(fn) {
    var match = fn && fn.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : "";
  }
  function isSameType(a, b) {
    return getType(a) === getType(b);
  }
  function getTypeIndex(type, expectedTypes) {
    if (!Array.isArray(expectedTypes)) {
      return isSameType(expectedTypes, type) ? 0 : -1;
    }
    for (var i = 0, len = expectedTypes.length; i < len; i++) {
      if (isSameType(expectedTypes[i], type)) {
        return i;
      }
    }
    return -1;
  }
  function getInvalidTypeMessage(name2, value, expectedTypes) {
    var message = 'Invalid prop: type check failed for prop "' + name2 + '". Expected ' + expectedTypes.map(capitalize).join(", ");
    var expectedType = expectedTypes[0];
    var receivedType = toRawType(value);
    var expectedValue = styleValue(value, expectedType);
    var receivedValue = styleValue(value, receivedType);
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
      message += " with value " + expectedValue;
    }
    message += ", got " + receivedType + " ";
    if (isExplicable(receivedType)) {
      message += "with value " + receivedValue + ".";
    }
    return message;
  }
  function styleValue(value, type) {
    if (type === "String") {
      return '"' + value + '"';
    } else if (type === "Number") {
      return "" + Number(value);
    } else {
      return "" + value;
    }
  }
  function isExplicable(value) {
    var explicitTypes = ["string", "number", "boolean"];
    return explicitTypes.some(function(elem) {
      return value.toLowerCase() === elem;
    });
  }
  function isBoolean() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    return args.some(function(elem) {
      return elem.toLowerCase() === "boolean";
    });
  }
  function handleError(err, vm, info) {
    pushTarget();
    try {
      if (vm) {
        var cur = vm;
        while (cur = cur.$parent) {
          var hooks2 = cur.$options.errorCaptured;
          if (hooks2) {
            for (var i = 0; i < hooks2.length; i++) {
              try {
                var capture = hooks2[i].call(cur, err, vm, info) === false;
                if (capture) {
                  return;
                }
              } catch (e) {
                globalHandleError(e, cur, "errorCaptured hook");
              }
            }
          }
        }
      }
      globalHandleError(err, vm, info);
    } finally {
      popTarget();
    }
  }
  function invokeWithErrorHandling(handler, context, args, vm, info) {
    var res;
    try {
      res = args ? handler.apply(context, args) : handler.call(context);
      if (res && !res._isVue && isPromise(res) && !res._handled) {
        res.catch(function(e) {
          return handleError(e, vm, info + " (Promise/async)");
        });
        res._handled = true;
      }
    } catch (e) {
      handleError(e, vm, info);
    }
    return res;
  }
  function globalHandleError(err, vm, info) {
    if (config.errorHandler) {
      try {
        return config.errorHandler.call(null, err, vm, info);
      } catch (e) {
        if (e !== err) {
          logError(e, null, "config.errorHandler");
        }
      }
    }
    logError(err, vm, info);
  }
  function logError(err, vm, info) {
    {
      warn("Error in " + info + ': "' + err.toString() + '"', vm);
    }
    if ((inBrowser || inWeex) && typeof console !== "undefined") {
      console.error(err);
    } else {
      throw err;
    }
  }
  var isUsingMicroTask = false;
  var callbacks = [];
  var pending = false;
  function flushCallbacks() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }
  var timerFunc;
  if (typeof Promise !== "undefined" && isNative(Promise)) {
    p = Promise.resolve();
    timerFunc = function() {
      p.then(flushCallbacks);
      if (isIOS) {
        setTimeout(noop);
      }
    };
    isUsingMicroTask = true;
  } else if (!isIE && typeof MutationObserver !== "undefined" && (isNative(MutationObserver) || MutationObserver.toString() === "[object MutationObserverConstructor]")) {
    counter = 1;
    observer = new MutationObserver(flushCallbacks);
    textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function() {
      counter = (counter + 1) % 2;
      textNode.data = String(counter);
    };
    isUsingMicroTask = true;
  } else if (typeof setImmediate !== "undefined" && isNative(setImmediate)) {
    timerFunc = function() {
      setImmediate(flushCallbacks);
    };
  } else {
    timerFunc = function() {
      setTimeout(flushCallbacks, 0);
    };
  }
  var p;
  var counter;
  var observer;
  var textNode;
  function nextTick(cb, ctx) {
    var _resolve;
    callbacks.push(function() {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, "nextTick");
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      timerFunc();
    }
    if (!cb && typeof Promise !== "undefined") {
      return new Promise(function(resolve) {
        _resolve = resolve;
      });
    }
  }
  var initProxy;
  {
    allowedGlobals = makeMap("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,require");
    warnNonPresent = function(target2, key) {
      warn('Property or method "' + key + '" is not defined on the instance but referenced during render. Make sure that this property is reactive, either in the data option, or for class-based components, by initializing the property. See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target2);
    };
    warnReservedPrefix = function(target2, key) {
      warn('Property "' + key + '" must be accessed with "$data.' + key + '" because properties starting with "$" or "_" are not proxied in the Vue instance to prevent conflicts with Vue internals. See: https://vuejs.org/v2/api/#data', target2);
    };
    hasProxy = typeof Proxy !== "undefined" && isNative(Proxy);
    if (hasProxy) {
      isBuiltInModifier = makeMap("stop,prevent,self,ctrl,shift,alt,meta,exact");
      config.keyCodes = new Proxy(config.keyCodes, {
        set: function set2(target2, key, value) {
          if (isBuiltInModifier(key)) {
            warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
            return false;
          } else {
            target2[key] = value;
            return true;
          }
        }
      });
    }
    hasHandler = {
      has: function has2(target2, key) {
        var has3 = key in target2;
        var isAllowed = allowedGlobals(key) || typeof key === "string" && key.charAt(0) === "_" && !(key in target2.$data);
        if (!has3 && !isAllowed) {
          if (key in target2.$data) {
            warnReservedPrefix(target2, key);
          } else {
            warnNonPresent(target2, key);
          }
        }
        return has3 || !isAllowed;
      }
    };
    getHandler = {
      get: function get(target2, key) {
        if (typeof key === "string" && !(key in target2)) {
          if (key in target2.$data) {
            warnReservedPrefix(target2, key);
          } else {
            warnNonPresent(target2, key);
          }
        }
        return target2[key];
      }
    };
    initProxy = function initProxy2(vm) {
      if (hasProxy) {
        var options = vm.$options;
        var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
        vm._renderProxy = new Proxy(vm, handlers);
      } else {
        vm._renderProxy = vm;
      }
    };
  }
  var allowedGlobals;
  var warnNonPresent;
  var warnReservedPrefix;
  var hasProxy;
  var isBuiltInModifier;
  var hasHandler;
  var getHandler;
  var seenObjects = new _Set();
  function traverse(val) {
    _traverse(val, seenObjects);
    seenObjects.clear();
  }
  function _traverse(val, seen) {
    var i, keys;
    var isA = Array.isArray(val);
    if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
      return;
    }
    if (val.__ob__) {
      var depId = val.__ob__.dep.id;
      if (seen.has(depId)) {
        return;
      }
      seen.add(depId);
    }
    if (isA) {
      i = val.length;
      while (i--) {
        _traverse(val[i], seen);
      }
    } else {
      keys = Object.keys(val);
      i = keys.length;
      while (i--) {
        _traverse(val[keys[i]], seen);
      }
    }
  }
  var mark;
  var measure;
  {
    perf = inBrowser && window.performance;
    if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
      mark = function(tag) {
        return perf.mark(tag);
      };
      measure = function(name2, startTag, endTag) {
        perf.measure(name2, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
      };
    }
  }
  var perf;
  var normalizeEvent = cached(function(name2) {
    var passive = name2.charAt(0) === "&";
    name2 = passive ? name2.slice(1) : name2;
    var once$$1 = name2.charAt(0) === "~";
    name2 = once$$1 ? name2.slice(1) : name2;
    var capture = name2.charAt(0) === "!";
    name2 = capture ? name2.slice(1) : name2;
    return {
      name: name2,
      once: once$$1,
      capture,
      passive
    };
  });
  function createFnInvoker(fns, vm) {
    function invoker() {
      var arguments$1 = arguments;
      var fns2 = invoker.fns;
      if (Array.isArray(fns2)) {
        var cloned = fns2.slice();
        for (var i = 0; i < cloned.length; i++) {
          invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
        }
      } else {
        return invokeWithErrorHandling(fns2, null, arguments, vm, "v-on handler");
      }
    }
    invoker.fns = fns;
    return invoker;
  }
  function updateListeners(on, oldOn, add2, remove$$1, createOnceHandler2, vm) {
    var name2, def$$1, cur, old, event;
    for (name2 in on) {
      def$$1 = cur = on[name2];
      old = oldOn[name2];
      event = normalizeEvent(name2);
      if (isUndef(cur)) {
        warn('Invalid handler for event "' + event.name + '": got ' + String(cur), vm);
      } else if (isUndef(old)) {
        if (isUndef(cur.fns)) {
          cur = on[name2] = createFnInvoker(cur, vm);
        }
        if (isTrue(event.once)) {
          cur = on[name2] = createOnceHandler2(event.name, cur, event.capture);
        }
        add2(event.name, cur, event.capture, event.passive, event.params);
      } else if (cur !== old) {
        old.fns = cur;
        on[name2] = old;
      }
    }
    for (name2 in oldOn) {
      if (isUndef(on[name2])) {
        event = normalizeEvent(name2);
        remove$$1(event.name, oldOn[name2], event.capture);
      }
    }
  }
  function mergeVNodeHook(def2, hookKey, hook) {
    if (def2 instanceof VNode) {
      def2 = def2.data.hook || (def2.data.hook = {});
    }
    var invoker;
    var oldHook = def2[hookKey];
    function wrappedHook() {
      hook.apply(this, arguments);
      remove(invoker.fns, wrappedHook);
    }
    if (isUndef(oldHook)) {
      invoker = createFnInvoker([wrappedHook]);
    } else {
      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
        invoker = oldHook;
        invoker.fns.push(wrappedHook);
      } else {
        invoker = createFnInvoker([oldHook, wrappedHook]);
      }
    }
    invoker.merged = true;
    def2[hookKey] = invoker;
  }
  function extractPropsFromVNodeData(data, Ctor, tag) {
    var propOptions = Ctor.options.props;
    if (isUndef(propOptions)) {
      return;
    }
    var res = {};
    var attrs2 = data.attrs;
    var props2 = data.props;
    if (isDef(attrs2) || isDef(props2)) {
      for (var key in propOptions) {
        var altKey = hyphenate(key);
        {
          var keyInLowerCase = key.toLowerCase();
          if (key !== keyInLowerCase && attrs2 && hasOwn(attrs2, keyInLowerCase)) {
            tip('Prop "' + keyInLowerCase + '" is passed to component ' + formatComponentName(tag || Ctor) + ', but the declared prop name is "' + key + '". Note that HTML attributes are case-insensitive and camelCased props need to use their kebab-case equivalents when using in-DOM templates. You should probably use "' + altKey + '" instead of "' + key + '".');
          }
        }
        checkProp(res, props2, key, altKey, true) || checkProp(res, attrs2, key, altKey, false);
      }
    }
    return res;
  }
  function checkProp(res, hash, key, altKey, preserve) {
    if (isDef(hash)) {
      if (hasOwn(hash, key)) {
        res[key] = hash[key];
        if (!preserve) {
          delete hash[key];
        }
        return true;
      } else if (hasOwn(hash, altKey)) {
        res[key] = hash[altKey];
        if (!preserve) {
          delete hash[altKey];
        }
        return true;
      }
    }
    return false;
  }
  function simpleNormalizeChildren(children) {
    for (var i = 0; i < children.length; i++) {
      if (Array.isArray(children[i])) {
        return Array.prototype.concat.apply([], children);
      }
    }
    return children;
  }
  function normalizeChildren(children) {
    return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : void 0;
  }
  function isTextNode(node) {
    return isDef(node) && isDef(node.text) && isFalse(node.isComment);
  }
  function normalizeArrayChildren(children, nestedIndex) {
    var res = [];
    var i, c, lastIndex, last;
    for (i = 0; i < children.length; i++) {
      c = children[i];
      if (isUndef(c) || typeof c === "boolean") {
        continue;
      }
      lastIndex = res.length - 1;
      last = res[lastIndex];
      if (Array.isArray(c)) {
        if (c.length > 0) {
          c = normalizeArrayChildren(c, (nestedIndex || "") + "_" + i);
          if (isTextNode(c[0]) && isTextNode(last)) {
            res[lastIndex] = createTextVNode(last.text + c[0].text);
            c.shift();
          }
          res.push.apply(res, c);
        }
      } else if (isPrimitive(c)) {
        if (isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c);
        } else if (c !== "") {
          res.push(createTextVNode(c));
        }
      } else {
        if (isTextNode(c) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c.text);
        } else {
          if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
            c.key = "__vlist" + nestedIndex + "_" + i + "__";
          }
          res.push(c);
        }
      }
    }
    return res;
  }
  function initProvide(vm) {
    var provide = vm.$options.provide;
    if (provide) {
      vm._provided = typeof provide === "function" ? provide.call(vm) : provide;
    }
  }
  function initInjections(vm) {
    var result = resolveInject(vm.$options.inject, vm);
    if (result) {
      toggleObserving(false);
      Object.keys(result).forEach(function(key) {
        {
          defineReactive$$1(vm, key, result[key], function() {
            warn('Avoid mutating an injected value directly since the changes will be overwritten whenever the provided component re-renders. injection being mutated: "' + key + '"', vm);
          });
        }
      });
      toggleObserving(true);
    }
  }
  function resolveInject(inject, vm) {
    if (inject) {
      var result = Object.create(null);
      var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key === "__ob__") {
          continue;
        }
        var provideKey = inject[key].from;
        var source = vm;
        while (source) {
          if (source._provided && hasOwn(source._provided, provideKey)) {
            result[key] = source._provided[provideKey];
            break;
          }
          source = source.$parent;
        }
        if (!source) {
          if ("default" in inject[key]) {
            var provideDefault = inject[key].default;
            result[key] = typeof provideDefault === "function" ? provideDefault.call(vm) : provideDefault;
          } else {
            warn('Injection "' + key + '" not found', vm);
          }
        }
      }
      return result;
    }
  }
  function resolveSlots(children, context) {
    if (!children || !children.length) {
      return {};
    }
    var slots = {};
    for (var i = 0, l = children.length; i < l; i++) {
      var child = children[i];
      var data = child.data;
      if (data && data.attrs && data.attrs.slot) {
        delete data.attrs.slot;
      }
      if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
        var name2 = data.slot;
        var slot = slots[name2] || (slots[name2] = []);
        if (child.tag === "template") {
          slot.push.apply(slot, child.children || []);
        } else {
          slot.push(child);
        }
      } else {
        (slots.default || (slots.default = [])).push(child);
      }
    }
    for (var name$1 in slots) {
      if (slots[name$1].every(isWhitespace)) {
        delete slots[name$1];
      }
    }
    return slots;
  }
  function isWhitespace(node) {
    return node.isComment && !node.asyncFactory || node.text === " ";
  }
  function normalizeScopedSlots(slots, normalSlots, prevSlots) {
    var res;
    var hasNormalSlots = Object.keys(normalSlots).length > 0;
    var isStable = slots ? !!slots.$stable : !hasNormalSlots;
    var key = slots && slots.$key;
    if (!slots) {
      res = {};
    } else if (slots._normalized) {
      return slots._normalized;
    } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {
      return prevSlots;
    } else {
      res = {};
      for (var key$1 in slots) {
        if (slots[key$1] && key$1[0] !== "$") {
          res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
        }
      }
    }
    for (var key$2 in normalSlots) {
      if (!(key$2 in res)) {
        res[key$2] = proxyNormalSlot(normalSlots, key$2);
      }
    }
    if (slots && Object.isExtensible(slots)) {
      slots._normalized = res;
    }
    def(res, "$stable", isStable);
    def(res, "$key", key);
    def(res, "$hasNormal", hasNormalSlots);
    return res;
  }
  function normalizeScopedSlot(normalSlots, key, fn) {
    var normalized = function() {
      var res = arguments.length ? fn.apply(null, arguments) : fn({});
      res = res && typeof res === "object" && !Array.isArray(res) ? [res] : normalizeChildren(res);
      return res && (res.length === 0 || res.length === 1 && res[0].isComment) ? void 0 : res;
    };
    if (fn.proxy) {
      Object.defineProperty(normalSlots, key, {
        get: normalized,
        enumerable: true,
        configurable: true
      });
    }
    return normalized;
  }
  function proxyNormalSlot(slots, key) {
    return function() {
      return slots[key];
    };
  }
  function renderList(val, render) {
    var ret, i, l, keys, key;
    if (Array.isArray(val) || typeof val === "string") {
      ret = new Array(val.length);
      for (i = 0, l = val.length; i < l; i++) {
        ret[i] = render(val[i], i);
      }
    } else if (typeof val === "number") {
      ret = new Array(val);
      for (i = 0; i < val; i++) {
        ret[i] = render(i + 1, i);
      }
    } else if (isObject(val)) {
      if (hasSymbol && val[Symbol.iterator]) {
        ret = [];
        var iterator = val[Symbol.iterator]();
        var result = iterator.next();
        while (!result.done) {
          ret.push(render(result.value, ret.length));
          result = iterator.next();
        }
      } else {
        keys = Object.keys(val);
        ret = new Array(keys.length);
        for (i = 0, l = keys.length; i < l; i++) {
          key = keys[i];
          ret[i] = render(val[key], key, i);
        }
      }
    }
    if (!isDef(ret)) {
      ret = [];
    }
    ret._isVList = true;
    return ret;
  }
  function renderSlot(name2, fallback, props2, bindObject) {
    var scopedSlotFn = this.$scopedSlots[name2];
    var nodes;
    if (scopedSlotFn) {
      props2 = props2 || {};
      if (bindObject) {
        if (!isObject(bindObject)) {
          warn("slot v-bind without argument expects an Object", this);
        }
        props2 = extend(extend({}, bindObject), props2);
      }
      nodes = scopedSlotFn(props2) || fallback;
    } else {
      nodes = this.$slots[name2] || fallback;
    }
    var target2 = props2 && props2.slot;
    if (target2) {
      return this.$createElement("template", {slot: target2}, nodes);
    } else {
      return nodes;
    }
  }
  function resolveFilter(id) {
    return resolveAsset(this.$options, "filters", id, true) || identity;
  }
  function isKeyNotMatch(expect, actual) {
    if (Array.isArray(expect)) {
      return expect.indexOf(actual) === -1;
    } else {
      return expect !== actual;
    }
  }
  function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
      return isKeyNotMatch(builtInKeyName, eventKeyName);
    } else if (mappedKeyCode) {
      return isKeyNotMatch(mappedKeyCode, eventKeyCode);
    } else if (eventKeyName) {
      return hyphenate(eventKeyName) !== key;
    }
  }
  function bindObjectProps(data, tag, value, asProp, isSync) {
    if (value) {
      if (!isObject(value)) {
        warn("v-bind without argument expects an Object or Array value", this);
      } else {
        if (Array.isArray(value)) {
          value = toObject(value);
        }
        var hash;
        var loop = function(key2) {
          if (key2 === "class" || key2 === "style" || isReservedAttribute(key2)) {
            hash = data;
          } else {
            var type = data.attrs && data.attrs.type;
            hash = asProp || config.mustUseProp(tag, type, key2) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
          }
          var camelizedKey = camelize(key2);
          var hyphenatedKey = hyphenate(key2);
          if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
            hash[key2] = value[key2];
            if (isSync) {
              var on = data.on || (data.on = {});
              on["update:" + key2] = function($event) {
                value[key2] = $event;
              };
            }
          }
        };
        for (var key in value)
          loop(key);
      }
    }
    return data;
  }
  function renderStatic(index2, isInFor) {
    var cached2 = this._staticTrees || (this._staticTrees = []);
    var tree = cached2[index2];
    if (tree && !isInFor) {
      return tree;
    }
    tree = cached2[index2] = this.$options.staticRenderFns[index2].call(this._renderProxy, null, this);
    markStatic(tree, "__static__" + index2, false);
    return tree;
  }
  function markOnce(tree, index2, key) {
    markStatic(tree, "__once__" + index2 + (key ? "_" + key : ""), true);
    return tree;
  }
  function markStatic(tree, key, isOnce) {
    if (Array.isArray(tree)) {
      for (var i = 0; i < tree.length; i++) {
        if (tree[i] && typeof tree[i] !== "string") {
          markStaticNode(tree[i], key + "_" + i, isOnce);
        }
      }
    } else {
      markStaticNode(tree, key, isOnce);
    }
  }
  function markStaticNode(node, key, isOnce) {
    node.isStatic = true;
    node.key = key;
    node.isOnce = isOnce;
  }
  function bindObjectListeners(data, value) {
    if (value) {
      if (!isPlainObject(value)) {
        warn("v-on without argument expects an Object value", this);
      } else {
        var on = data.on = data.on ? extend({}, data.on) : {};
        for (var key in value) {
          var existing = on[key];
          var ours = value[key];
          on[key] = existing ? [].concat(existing, ours) : ours;
        }
      }
    }
    return data;
  }
  function resolveScopedSlots(fns, res, hasDynamicKeys, contentHashKey) {
    res = res || {$stable: !hasDynamicKeys};
    for (var i = 0; i < fns.length; i++) {
      var slot = fns[i];
      if (Array.isArray(slot)) {
        resolveScopedSlots(slot, res, hasDynamicKeys);
      } else if (slot) {
        if (slot.proxy) {
          slot.fn.proxy = true;
        }
        res[slot.key] = slot.fn;
      }
    }
    if (contentHashKey) {
      res.$key = contentHashKey;
    }
    return res;
  }
  function bindDynamicKeys(baseObj, values) {
    for (var i = 0; i < values.length; i += 2) {
      var key = values[i];
      if (typeof key === "string" && key) {
        baseObj[values[i]] = values[i + 1];
      } else if (key !== "" && key !== null) {
        warn("Invalid value for dynamic directive argument (expected string or null): " + key, this);
      }
    }
    return baseObj;
  }
  function prependModifier(value, symbol) {
    return typeof value === "string" ? symbol + value : value;
  }
  function installRenderHelpers(target2) {
    target2._o = markOnce;
    target2._n = toNumber;
    target2._s = toString;
    target2._l = renderList;
    target2._t = renderSlot;
    target2._q = looseEqual;
    target2._i = looseIndexOf;
    target2._m = renderStatic;
    target2._f = resolveFilter;
    target2._k = checkKeyCodes;
    target2._b = bindObjectProps;
    target2._v = createTextVNode;
    target2._e = createEmptyVNode;
    target2._u = resolveScopedSlots;
    target2._g = bindObjectListeners;
    target2._d = bindDynamicKeys;
    target2._p = prependModifier;
  }
  function FunctionalRenderContext(data, props2, children, parent, Ctor) {
    var this$1 = this;
    var options = Ctor.options;
    var contextVm;
    if (hasOwn(parent, "_uid")) {
      contextVm = Object.create(parent);
      contextVm._original = parent;
    } else {
      contextVm = parent;
      parent = parent._original;
    }
    var isCompiled = isTrue(options._compiled);
    var needNormalization = !isCompiled;
    this.data = data;
    this.props = props2;
    this.children = children;
    this.parent = parent;
    this.listeners = data.on || emptyObject;
    this.injections = resolveInject(options.inject, parent);
    this.slots = function() {
      if (!this$1.$slots) {
        normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
      }
      return this$1.$slots;
    };
    Object.defineProperty(this, "scopedSlots", {
      enumerable: true,
      get: function get() {
        return normalizeScopedSlots(data.scopedSlots, this.slots());
      }
    });
    if (isCompiled) {
      this.$options = options;
      this.$slots = this.slots();
      this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
    }
    if (options._scopeId) {
      this._c = function(a, b, c, d) {
        var vnode = createElement(contextVm, a, b, c, d, needNormalization);
        if (vnode && !Array.isArray(vnode)) {
          vnode.fnScopeId = options._scopeId;
          vnode.fnContext = parent;
        }
        return vnode;
      };
    } else {
      this._c = function(a, b, c, d) {
        return createElement(contextVm, a, b, c, d, needNormalization);
      };
    }
  }
  installRenderHelpers(FunctionalRenderContext.prototype);
  function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
    var options = Ctor.options;
    var props2 = {};
    var propOptions = options.props;
    if (isDef(propOptions)) {
      for (var key in propOptions) {
        props2[key] = validateProp(key, propOptions, propsData || emptyObject);
      }
    } else {
      if (isDef(data.attrs)) {
        mergeProps(props2, data.attrs);
      }
      if (isDef(data.props)) {
        mergeProps(props2, data.props);
      }
    }
    var renderContext = new FunctionalRenderContext(data, props2, children, contextVm, Ctor);
    var vnode = options.render.call(null, renderContext._c, renderContext);
    if (vnode instanceof VNode) {
      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
    } else if (Array.isArray(vnode)) {
      var vnodes = normalizeChildren(vnode) || [];
      var res = new Array(vnodes.length);
      for (var i = 0; i < vnodes.length; i++) {
        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
      }
      return res;
    }
  }
  function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
    var clone = cloneVNode(vnode);
    clone.fnContext = contextVm;
    clone.fnOptions = options;
    {
      (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
    }
    if (data.slot) {
      (clone.data || (clone.data = {})).slot = data.slot;
    }
    return clone;
  }
  function mergeProps(to, from) {
    for (var key in from) {
      to[camelize(key)] = from[key];
    }
  }
  var componentVNodeHooks = {
    init: function init(vnode, hydrating) {
      if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
        var mountedNode = vnode;
        componentVNodeHooks.prepatch(mountedNode, mountedNode);
      } else {
        var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
        child.$mount(hydrating ? vnode.elm : void 0, hydrating);
      }
    },
    prepatch: function prepatch(oldVnode, vnode) {
      var options = vnode.componentOptions;
      var child = vnode.componentInstance = oldVnode.componentInstance;
      updateChildComponent(child, options.propsData, options.listeners, vnode, options.children);
    },
    insert: function insert(vnode) {
      var context = vnode.context;
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isMounted) {
        componentInstance._isMounted = true;
        callHook(componentInstance, "mounted");
      }
      if (vnode.data.keepAlive) {
        if (context._isMounted) {
          queueActivatedComponent(componentInstance);
        } else {
          activateChildComponent(componentInstance, true);
        }
      }
    },
    destroy: function destroy(vnode) {
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isDestroyed) {
        if (!vnode.data.keepAlive) {
          componentInstance.$destroy();
        } else {
          deactivateChildComponent(componentInstance, true);
        }
      }
    }
  };
  var hooksToMerge = Object.keys(componentVNodeHooks);
  function createComponent(Ctor, data, context, children, tag) {
    if (isUndef(Ctor)) {
      return;
    }
    var baseCtor = context.$options._base;
    if (isObject(Ctor)) {
      Ctor = baseCtor.extend(Ctor);
    }
    if (typeof Ctor !== "function") {
      {
        warn("Invalid Component definition: " + String(Ctor), context);
      }
      return;
    }
    var asyncFactory;
    if (isUndef(Ctor.cid)) {
      asyncFactory = Ctor;
      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
      if (Ctor === void 0) {
        return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
      }
    }
    data = data || {};
    resolveConstructorOptions(Ctor);
    if (isDef(data.model)) {
      transformModel(Ctor.options, data);
    }
    var propsData = extractPropsFromVNodeData(data, Ctor, tag);
    if (isTrue(Ctor.options.functional)) {
      return createFunctionalComponent(Ctor, propsData, data, context, children);
    }
    var listeners = data.on;
    data.on = data.nativeOn;
    if (isTrue(Ctor.options.abstract)) {
      var slot = data.slot;
      data = {};
      if (slot) {
        data.slot = slot;
      }
    }
    installComponentHooks(data);
    var name2 = Ctor.options.name || tag;
    var vnode = new VNode("vue-component-" + Ctor.cid + (name2 ? "-" + name2 : ""), data, void 0, void 0, void 0, context, {Ctor, propsData, listeners, tag, children}, asyncFactory);
    return vnode;
  }
  function createComponentInstanceForVnode(vnode, parent) {
    var options = {
      _isComponent: true,
      _parentVnode: vnode,
      parent
    };
    var inlineTemplate = vnode.data.inlineTemplate;
    if (isDef(inlineTemplate)) {
      options.render = inlineTemplate.render;
      options.staticRenderFns = inlineTemplate.staticRenderFns;
    }
    return new vnode.componentOptions.Ctor(options);
  }
  function installComponentHooks(data) {
    var hooks2 = data.hook || (data.hook = {});
    for (var i = 0; i < hooksToMerge.length; i++) {
      var key = hooksToMerge[i];
      var existing = hooks2[key];
      var toMerge = componentVNodeHooks[key];
      if (existing !== toMerge && !(existing && existing._merged)) {
        hooks2[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
      }
    }
  }
  function mergeHook$1(f1, f2) {
    var merged = function(a, b) {
      f1(a, b);
      f2(a, b);
    };
    merged._merged = true;
    return merged;
  }
  function transformModel(options, data) {
    var prop = options.model && options.model.prop || "value";
    var event = options.model && options.model.event || "input";
    (data.attrs || (data.attrs = {}))[prop] = data.model.value;
    var on = data.on || (data.on = {});
    var existing = on[event];
    var callback = data.model.callback;
    if (isDef(existing)) {
      if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
        on[event] = [callback].concat(existing);
      }
    } else {
      on[event] = callback;
    }
  }
  var SIMPLE_NORMALIZE = 1;
  var ALWAYS_NORMALIZE = 2;
  function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
    if (Array.isArray(data) || isPrimitive(data)) {
      normalizationType = children;
      children = data;
      data = void 0;
    }
    if (isTrue(alwaysNormalize)) {
      normalizationType = ALWAYS_NORMALIZE;
    }
    return _createElement(context, tag, data, children, normalizationType);
  }
  function _createElement(context, tag, data, children, normalizationType) {
    if (isDef(data) && isDef(data.__ob__)) {
      warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\nAlways create fresh vnode data objects in each render!", context);
      return createEmptyVNode();
    }
    if (isDef(data) && isDef(data.is)) {
      tag = data.is;
    }
    if (!tag) {
      return createEmptyVNode();
    }
    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
      {
        warn("Avoid using non-primitive value as key, use string/number value instead.", context);
      }
    }
    if (Array.isArray(children) && typeof children[0] === "function") {
      data = data || {};
      data.scopedSlots = {default: children[0]};
      children.length = 0;
    }
    if (normalizationType === ALWAYS_NORMALIZE) {
      children = normalizeChildren(children);
    } else if (normalizationType === SIMPLE_NORMALIZE) {
      children = simpleNormalizeChildren(children);
    }
    var vnode, ns;
    if (typeof tag === "string") {
      var Ctor;
      ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
      if (config.isReservedTag(tag)) {
        if (isDef(data) && isDef(data.nativeOn)) {
          warn("The .native modifier for v-on is only valid on components but it was used on <" + tag + ">.", context);
        }
        vnode = new VNode(config.parsePlatformTagName(tag), data, children, void 0, void 0, context);
      } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, "components", tag))) {
        vnode = createComponent(Ctor, data, context, children, tag);
      } else {
        vnode = new VNode(tag, data, children, void 0, void 0, context);
      }
    } else {
      vnode = createComponent(tag, data, context, children);
    }
    if (Array.isArray(vnode)) {
      return vnode;
    } else if (isDef(vnode)) {
      if (isDef(ns)) {
        applyNS(vnode, ns);
      }
      if (isDef(data)) {
        registerDeepBindings(data);
      }
      return vnode;
    } else {
      return createEmptyVNode();
    }
  }
  function applyNS(vnode, ns, force) {
    vnode.ns = ns;
    if (vnode.tag === "foreignObject") {
      ns = void 0;
      force = true;
    }
    if (isDef(vnode.children)) {
      for (var i = 0, l = vnode.children.length; i < l; i++) {
        var child = vnode.children[i];
        if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== "svg")) {
          applyNS(child, ns, force);
        }
      }
    }
  }
  function registerDeepBindings(data) {
    if (isObject(data.style)) {
      traverse(data.style);
    }
    if (isObject(data.class)) {
      traverse(data.class);
    }
  }
  function initRender(vm) {
    vm._vnode = null;
    vm._staticTrees = null;
    var options = vm.$options;
    var parentVnode = vm.$vnode = options._parentVnode;
    var renderContext = parentVnode && parentVnode.context;
    vm.$slots = resolveSlots(options._renderChildren, renderContext);
    vm.$scopedSlots = emptyObject;
    vm._c = function(a, b, c, d) {
      return createElement(vm, a, b, c, d, false);
    };
    vm.$createElement = function(a, b, c, d) {
      return createElement(vm, a, b, c, d, true);
    };
    var parentData = parentVnode && parentVnode.data;
    {
      defineReactive$$1(vm, "$attrs", parentData && parentData.attrs || emptyObject, function() {
        !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
      }, true);
      defineReactive$$1(vm, "$listeners", options._parentListeners || emptyObject, function() {
        !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
      }, true);
    }
  }
  var currentRenderingInstance = null;
  function renderMixin(Vue6) {
    installRenderHelpers(Vue6.prototype);
    Vue6.prototype.$nextTick = function(fn) {
      return nextTick(fn, this);
    };
    Vue6.prototype._render = function() {
      var vm = this;
      var ref2 = vm.$options;
      var render = ref2.render;
      var _parentVnode = ref2._parentVnode;
      if (_parentVnode) {
        vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
      }
      vm.$vnode = _parentVnode;
      var vnode;
      try {
        currentRenderingInstance = vm;
        vnode = render.call(vm._renderProxy, vm.$createElement);
      } catch (e) {
        handleError(e, vm, "render");
        if (vm.$options.renderError) {
          try {
            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
          } catch (e2) {
            handleError(e2, vm, "renderError");
            vnode = vm._vnode;
          }
        } else {
          vnode = vm._vnode;
        }
      } finally {
        currentRenderingInstance = null;
      }
      if (Array.isArray(vnode) && vnode.length === 1) {
        vnode = vnode[0];
      }
      if (!(vnode instanceof VNode)) {
        if (Array.isArray(vnode)) {
          warn("Multiple root nodes returned from render function. Render function should return a single root node.", vm);
        }
        vnode = createEmptyVNode();
      }
      vnode.parent = _parentVnode;
      return vnode;
    };
  }
  function ensureCtor(comp, base) {
    if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === "Module") {
      comp = comp.default;
    }
    return isObject(comp) ? base.extend(comp) : comp;
  }
  function createAsyncPlaceholder(factory, data, context, children, tag) {
    var node = createEmptyVNode();
    node.asyncFactory = factory;
    node.asyncMeta = {data, context, children, tag};
    return node;
  }
  function resolveAsyncComponent(factory, baseCtor) {
    if (isTrue(factory.error) && isDef(factory.errorComp)) {
      return factory.errorComp;
    }
    if (isDef(factory.resolved)) {
      return factory.resolved;
    }
    var owner = currentRenderingInstance;
    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
      factory.owners.push(owner);
    }
    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
      return factory.loadingComp;
    }
    if (owner && !isDef(factory.owners)) {
      var owners = factory.owners = [owner];
      var sync = true;
      var timerLoading = null;
      var timerTimeout = null;
      owner.$on("hook:destroyed", function() {
        return remove(owners, owner);
      });
      var forceRender = function(renderCompleted) {
        for (var i = 0, l = owners.length; i < l; i++) {
          owners[i].$forceUpdate();
        }
        if (renderCompleted) {
          owners.length = 0;
          if (timerLoading !== null) {
            clearTimeout(timerLoading);
            timerLoading = null;
          }
          if (timerTimeout !== null) {
            clearTimeout(timerTimeout);
            timerTimeout = null;
          }
        }
      };
      var resolve = once(function(res2) {
        factory.resolved = ensureCtor(res2, baseCtor);
        if (!sync) {
          forceRender(true);
        } else {
          owners.length = 0;
        }
      });
      var reject = once(function(reason) {
        warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ""));
        if (isDef(factory.errorComp)) {
          factory.error = true;
          forceRender(true);
        }
      });
      var res = factory(resolve, reject);
      if (isObject(res)) {
        if (isPromise(res)) {
          if (isUndef(factory.resolved)) {
            res.then(resolve, reject);
          }
        } else if (isPromise(res.component)) {
          res.component.then(resolve, reject);
          if (isDef(res.error)) {
            factory.errorComp = ensureCtor(res.error, baseCtor);
          }
          if (isDef(res.loading)) {
            factory.loadingComp = ensureCtor(res.loading, baseCtor);
            if (res.delay === 0) {
              factory.loading = true;
            } else {
              timerLoading = setTimeout(function() {
                timerLoading = null;
                if (isUndef(factory.resolved) && isUndef(factory.error)) {
                  factory.loading = true;
                  forceRender(false);
                }
              }, res.delay || 200);
            }
          }
          if (isDef(res.timeout)) {
            timerTimeout = setTimeout(function() {
              timerTimeout = null;
              if (isUndef(factory.resolved)) {
                reject("timeout (" + res.timeout + "ms)");
              }
            }, res.timeout);
          }
        }
      }
      sync = false;
      return factory.loading ? factory.loadingComp : factory.resolved;
    }
  }
  function isAsyncPlaceholder(node) {
    return node.isComment && node.asyncFactory;
  }
  function getFirstComponentChild(children) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        var c = children[i];
        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
          return c;
        }
      }
    }
  }
  function initEvents(vm) {
    vm._events = Object.create(null);
    vm._hasHookEvent = false;
    var listeners = vm.$options._parentListeners;
    if (listeners) {
      updateComponentListeners(vm, listeners);
    }
  }
  var target;
  function add(event, fn) {
    target.$on(event, fn);
  }
  function remove$1(event, fn) {
    target.$off(event, fn);
  }
  function createOnceHandler(event, fn) {
    var _target = target;
    return function onceHandler() {
      var res = fn.apply(null, arguments);
      if (res !== null) {
        _target.$off(event, onceHandler);
      }
    };
  }
  function updateComponentListeners(vm, listeners, oldListeners) {
    target = vm;
    updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
    target = void 0;
  }
  function eventsMixin(Vue6) {
    var hookRE = /^hook:/;
    Vue6.prototype.$on = function(event, fn) {
      var vm = this;
      if (Array.isArray(event)) {
        for (var i = 0, l = event.length; i < l; i++) {
          vm.$on(event[i], fn);
        }
      } else {
        (vm._events[event] || (vm._events[event] = [])).push(fn);
        if (hookRE.test(event)) {
          vm._hasHookEvent = true;
        }
      }
      return vm;
    };
    Vue6.prototype.$once = function(event, fn) {
      var vm = this;
      function on() {
        vm.$off(event, on);
        fn.apply(vm, arguments);
      }
      on.fn = fn;
      vm.$on(event, on);
      return vm;
    };
    Vue6.prototype.$off = function(event, fn) {
      var vm = this;
      if (!arguments.length) {
        vm._events = Object.create(null);
        return vm;
      }
      if (Array.isArray(event)) {
        for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
          vm.$off(event[i$1], fn);
        }
        return vm;
      }
      var cbs = vm._events[event];
      if (!cbs) {
        return vm;
      }
      if (!fn) {
        vm._events[event] = null;
        return vm;
      }
      var cb;
      var i = cbs.length;
      while (i--) {
        cb = cbs[i];
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i, 1);
          break;
        }
      }
      return vm;
    };
    Vue6.prototype.$emit = function(event) {
      var vm = this;
      {
        var lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
          tip('Event "' + lowerCaseEvent + '" is emitted in component ' + formatComponentName(vm) + ' but the handler is registered for "' + event + '". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "' + hyphenate(event) + '" instead of "' + event + '".');
        }
      }
      var cbs = vm._events[event];
      if (cbs) {
        cbs = cbs.length > 1 ? toArray(cbs) : cbs;
        var args = toArray(arguments, 1);
        var info = 'event handler for "' + event + '"';
        for (var i = 0, l = cbs.length; i < l; i++) {
          invokeWithErrorHandling(cbs[i], vm, args, vm, info);
        }
      }
      return vm;
    };
  }
  var activeInstance = null;
  var isUpdatingChildComponent = false;
  function setActiveInstance(vm) {
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    return function() {
      activeInstance = prevActiveInstance;
    };
  }
  function initLifecycle(vm) {
    var options = vm.$options;
    var parent = options.parent;
    if (parent && !options.abstract) {
      while (parent.$options.abstract && parent.$parent) {
        parent = parent.$parent;
      }
      parent.$children.push(vm);
    }
    vm.$parent = parent;
    vm.$root = parent ? parent.$root : vm;
    vm.$children = [];
    vm.$refs = {};
    vm._watcher = null;
    vm._inactive = null;
    vm._directInactive = false;
    vm._isMounted = false;
    vm._isDestroyed = false;
    vm._isBeingDestroyed = false;
  }
  function lifecycleMixin(Vue6) {
    Vue6.prototype._update = function(vnode, hydrating) {
      var vm = this;
      var prevEl = vm.$el;
      var prevVnode = vm._vnode;
      var restoreActiveInstance = setActiveInstance(vm);
      vm._vnode = vnode;
      if (!prevVnode) {
        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false);
      } else {
        vm.$el = vm.__patch__(prevVnode, vnode);
      }
      restoreActiveInstance();
      if (prevEl) {
        prevEl.__vue__ = null;
      }
      if (vm.$el) {
        vm.$el.__vue__ = vm;
      }
      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
        vm.$parent.$el = vm.$el;
      }
    };
    Vue6.prototype.$forceUpdate = function() {
      var vm = this;
      if (vm._watcher) {
        vm._watcher.update();
      }
    };
    Vue6.prototype.$destroy = function() {
      var vm = this;
      if (vm._isBeingDestroyed) {
        return;
      }
      callHook(vm, "beforeDestroy");
      vm._isBeingDestroyed = true;
      var parent = vm.$parent;
      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
        remove(parent.$children, vm);
      }
      if (vm._watcher) {
        vm._watcher.teardown();
      }
      var i = vm._watchers.length;
      while (i--) {
        vm._watchers[i].teardown();
      }
      if (vm._data.__ob__) {
        vm._data.__ob__.vmCount--;
      }
      vm._isDestroyed = true;
      vm.__patch__(vm._vnode, null);
      callHook(vm, "destroyed");
      vm.$off();
      if (vm.$el) {
        vm.$el.__vue__ = null;
      }
      if (vm.$vnode) {
        vm.$vnode.parent = null;
      }
    };
  }
  function mountComponent(vm, el, hydrating) {
    vm.$el = el;
    if (!vm.$options.render) {
      vm.$options.render = createEmptyVNode;
      {
        if (vm.$options.template && vm.$options.template.charAt(0) !== "#" || vm.$options.el || el) {
          warn("You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.", vm);
        } else {
          warn("Failed to mount component: template or render function not defined.", vm);
        }
      }
    }
    callHook(vm, "beforeMount");
    var updateComponent;
    if (config.performance && mark) {
      updateComponent = function() {
        var name2 = vm._name;
        var id = vm._uid;
        var startTag = "vue-perf-start:" + id;
        var endTag = "vue-perf-end:" + id;
        mark(startTag);
        var vnode = vm._render();
        mark(endTag);
        measure("vue " + name2 + " render", startTag, endTag);
        mark(startTag);
        vm._update(vnode, hydrating);
        mark(endTag);
        measure("vue " + name2 + " patch", startTag, endTag);
      };
    } else {
      updateComponent = function() {
        vm._update(vm._render(), hydrating);
      };
    }
    new Watcher(vm, updateComponent, noop, {
      before: function before() {
        if (vm._isMounted && !vm._isDestroyed) {
          callHook(vm, "beforeUpdate");
        }
      }
    }, true);
    hydrating = false;
    if (vm.$vnode == null) {
      vm._isMounted = true;
      callHook(vm, "mounted");
    }
    return vm;
  }
  function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
    {
      isUpdatingChildComponent = true;
    }
    var newScopedSlots = parentVnode.data.scopedSlots;
    var oldScopedSlots = vm.$scopedSlots;
    var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key);
    var needsForceUpdate = !!(renderChildren || vm.$options._renderChildren || hasDynamicScopedSlot);
    vm.$options._parentVnode = parentVnode;
    vm.$vnode = parentVnode;
    if (vm._vnode) {
      vm._vnode.parent = parentVnode;
    }
    vm.$options._renderChildren = renderChildren;
    vm.$attrs = parentVnode.data.attrs || emptyObject;
    vm.$listeners = listeners || emptyObject;
    if (propsData && vm.$options.props) {
      toggleObserving(false);
      var props2 = vm._props;
      var propKeys = vm.$options._propKeys || [];
      for (var i = 0; i < propKeys.length; i++) {
        var key = propKeys[i];
        var propOptions = vm.$options.props;
        props2[key] = validateProp(key, propOptions, propsData, vm);
      }
      toggleObserving(true);
      vm.$options.propsData = propsData;
    }
    listeners = listeners || emptyObject;
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
    if (needsForceUpdate) {
      vm.$slots = resolveSlots(renderChildren, parentVnode.context);
      vm.$forceUpdate();
    }
    {
      isUpdatingChildComponent = false;
    }
  }
  function isInInactiveTree(vm) {
    while (vm && (vm = vm.$parent)) {
      if (vm._inactive) {
        return true;
      }
    }
    return false;
  }
  function activateChildComponent(vm, direct) {
    if (direct) {
      vm._directInactive = false;
      if (isInInactiveTree(vm)) {
        return;
      }
    } else if (vm._directInactive) {
      return;
    }
    if (vm._inactive || vm._inactive === null) {
      vm._inactive = false;
      for (var i = 0; i < vm.$children.length; i++) {
        activateChildComponent(vm.$children[i]);
      }
      callHook(vm, "activated");
    }
  }
  function deactivateChildComponent(vm, direct) {
    if (direct) {
      vm._directInactive = true;
      if (isInInactiveTree(vm)) {
        return;
      }
    }
    if (!vm._inactive) {
      vm._inactive = true;
      for (var i = 0; i < vm.$children.length; i++) {
        deactivateChildComponent(vm.$children[i]);
      }
      callHook(vm, "deactivated");
    }
  }
  function callHook(vm, hook) {
    pushTarget();
    var handlers = vm.$options[hook];
    var info = hook + " hook";
    if (handlers) {
      for (var i = 0, j = handlers.length; i < j; i++) {
        invokeWithErrorHandling(handlers[i], vm, null, vm, info);
      }
    }
    if (vm._hasHookEvent) {
      vm.$emit("hook:" + hook);
    }
    popTarget();
  }
  var MAX_UPDATE_COUNT = 100;
  var queue = [];
  var activatedChildren = [];
  var has = {};
  var circular = {};
  var waiting = false;
  var flushing = false;
  var index = 0;
  function resetSchedulerState() {
    index = queue.length = activatedChildren.length = 0;
    has = {};
    {
      circular = {};
    }
    waiting = flushing = false;
  }
  var currentFlushTimestamp = 0;
  var getNow = Date.now;
  if (inBrowser && !isIE) {
    performance2 = window.performance;
    if (performance2 && typeof performance2.now === "function" && getNow() > document.createEvent("Event").timeStamp) {
      getNow = function() {
        return performance2.now();
      };
    }
  }
  var performance2;
  function flushSchedulerQueue() {
    currentFlushTimestamp = getNow();
    flushing = true;
    var watcher, id;
    queue.sort(function(a, b) {
      return a.id - b.id;
    });
    for (index = 0; index < queue.length; index++) {
      watcher = queue[index];
      if (watcher.before) {
        watcher.before();
      }
      id = watcher.id;
      has[id] = null;
      watcher.run();
      if (has[id] != null) {
        circular[id] = (circular[id] || 0) + 1;
        if (circular[id] > MAX_UPDATE_COUNT) {
          warn("You may have an infinite update loop " + (watcher.user ? 'in watcher with expression "' + watcher.expression + '"' : "in a component render function."), watcher.vm);
          break;
        }
      }
    }
    var activatedQueue = activatedChildren.slice();
    var updatedQueue = queue.slice();
    resetSchedulerState();
    callActivatedHooks(activatedQueue);
    callUpdatedHooks(updatedQueue);
    if (devtools && config.devtools) {
      devtools.emit("flush");
    }
  }
  function callUpdatedHooks(queue2) {
    var i = queue2.length;
    while (i--) {
      var watcher = queue2[i];
      var vm = watcher.vm;
      if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
        callHook(vm, "updated");
      }
    }
  }
  function queueActivatedComponent(vm) {
    vm._inactive = false;
    activatedChildren.push(vm);
  }
  function callActivatedHooks(queue2) {
    for (var i = 0; i < queue2.length; i++) {
      queue2[i]._inactive = true;
      activateChildComponent(queue2[i], true);
    }
  }
  function queueWatcher(watcher) {
    var id = watcher.id;
    if (has[id] == null) {
      has[id] = true;
      if (!flushing) {
        queue.push(watcher);
      } else {
        var i = queue.length - 1;
        while (i > index && queue[i].id > watcher.id) {
          i--;
        }
        queue.splice(i + 1, 0, watcher);
      }
      if (!waiting) {
        waiting = true;
        if (!config.async) {
          flushSchedulerQueue();
          return;
        }
        nextTick(flushSchedulerQueue);
      }
    }
  }
  var uid$2 = 0;
  var Watcher = function Watcher2(vm, expOrFn, cb, options, isRenderWatcher) {
    this.vm = vm;
    if (isRenderWatcher) {
      vm._watcher = this;
    }
    vm._watchers.push(this);
    if (options) {
      this.deep = !!options.deep;
      this.user = !!options.user;
      this.lazy = !!options.lazy;
      this.sync = !!options.sync;
      this.before = options.before;
    } else {
      this.deep = this.user = this.lazy = this.sync = false;
    }
    this.cb = cb;
    this.id = ++uid$2;
    this.active = true;
    this.dirty = this.lazy;
    this.deps = [];
    this.newDeps = [];
    this.depIds = new _Set();
    this.newDepIds = new _Set();
    this.expression = expOrFn.toString();
    if (typeof expOrFn === "function") {
      this.getter = expOrFn;
    } else {
      this.getter = parsePath(expOrFn);
      if (!this.getter) {
        this.getter = noop;
        warn('Failed watching path: "' + expOrFn + '" Watcher only accepts simple dot-delimited paths. For full control, use a function instead.', vm);
      }
    }
    this.value = this.lazy ? void 0 : this.get();
  };
  Watcher.prototype.get = function get() {
    pushTarget(this);
    var value;
    var vm = this.vm;
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
      if (this.user) {
        handleError(e, vm, 'getter for watcher "' + this.expression + '"');
      } else {
        throw e;
      }
    } finally {
      if (this.deep) {
        traverse(value);
      }
      popTarget();
      this.cleanupDeps();
    }
    return value;
  };
  Watcher.prototype.addDep = function addDep(dep) {
    var id = dep.id;
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id);
      this.newDeps.push(dep);
      if (!this.depIds.has(id)) {
        dep.addSub(this);
      }
    }
  };
  Watcher.prototype.cleanupDeps = function cleanupDeps() {
    var i = this.deps.length;
    while (i--) {
      var dep = this.deps[i];
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this);
      }
    }
    var tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
  };
  Watcher.prototype.update = function update() {
    if (this.lazy) {
      this.dirty = true;
    } else if (this.sync) {
      this.run();
    } else {
      queueWatcher(this);
    }
  };
  Watcher.prototype.run = function run() {
    if (this.active) {
      var value = this.get();
      if (value !== this.value || isObject(value) || this.deep) {
        var oldValue = this.value;
        this.value = value;
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue);
          } catch (e) {
            handleError(e, this.vm, 'callback for watcher "' + this.expression + '"');
          }
        } else {
          this.cb.call(this.vm, value, oldValue);
        }
      }
    }
  };
  Watcher.prototype.evaluate = function evaluate() {
    this.value = this.get();
    this.dirty = false;
  };
  Watcher.prototype.depend = function depend() {
    var i = this.deps.length;
    while (i--) {
      this.deps[i].depend();
    }
  };
  Watcher.prototype.teardown = function teardown() {
    if (this.active) {
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this);
      }
      var i = this.deps.length;
      while (i--) {
        this.deps[i].removeSub(this);
      }
      this.active = false;
    }
  };
  var sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop,
    set: noop
  };
  function proxy(target2, sourceKey, key) {
    sharedPropertyDefinition.get = function proxyGetter() {
      return this[sourceKey][key];
    };
    sharedPropertyDefinition.set = function proxySetter(val) {
      this[sourceKey][key] = val;
    };
    Object.defineProperty(target2, key, sharedPropertyDefinition);
  }
  function initState(vm) {
    vm._watchers = [];
    var opts2 = vm.$options;
    if (opts2.props) {
      initProps(vm, opts2.props);
    }
    if (opts2.methods) {
      initMethods(vm, opts2.methods);
    }
    if (opts2.data) {
      initData(vm);
    } else {
      observe(vm._data = {}, true);
    }
    if (opts2.computed) {
      initComputed(vm, opts2.computed);
    }
    if (opts2.watch && opts2.watch !== nativeWatch) {
      initWatch(vm, opts2.watch);
    }
  }
  function initProps(vm, propsOptions) {
    var propsData = vm.$options.propsData || {};
    var props2 = vm._props = {};
    var keys = vm.$options._propKeys = [];
    var isRoot = !vm.$parent;
    if (!isRoot) {
      toggleObserving(false);
    }
    var loop = function(key2) {
      keys.push(key2);
      var value = validateProp(key2, propsOptions, propsData, vm);
      {
        var hyphenatedKey = hyphenate(key2);
        if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
          warn('"' + hyphenatedKey + '" is a reserved attribute and cannot be used as component prop.', vm);
        }
        defineReactive$$1(props2, key2, value, function() {
          if (!isRoot && !isUpdatingChildComponent) {
            warn(`Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. Prop being mutated: "` + key2 + '"', vm);
          }
        });
      }
      if (!(key2 in vm)) {
        proxy(vm, "_props", key2);
      }
    };
    for (var key in propsOptions)
      loop(key);
    toggleObserving(true);
  }
  function initData(vm) {
    var data = vm.$options.data;
    data = vm._data = typeof data === "function" ? getData(data, vm) : data || {};
    if (!isPlainObject(data)) {
      data = {};
      warn("data functions should return an object:\nhttps://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function", vm);
    }
    var keys = Object.keys(data);
    var props2 = vm.$options.props;
    var methods = vm.$options.methods;
    var i = keys.length;
    while (i--) {
      var key = keys[i];
      {
        if (methods && hasOwn(methods, key)) {
          warn('Method "' + key + '" has already been defined as a data property.', vm);
        }
      }
      if (props2 && hasOwn(props2, key)) {
        warn('The data property "' + key + '" is already declared as a prop. Use prop default value instead.', vm);
      } else if (!isReserved(key)) {
        proxy(vm, "_data", key);
      }
    }
    observe(data, true);
  }
  function getData(data, vm) {
    pushTarget();
    try {
      return data.call(vm, vm);
    } catch (e) {
      handleError(e, vm, "data()");
      return {};
    } finally {
      popTarget();
    }
  }
  var computedWatcherOptions = {lazy: true};
  function initComputed(vm, computed) {
    var watchers = vm._computedWatchers = Object.create(null);
    var isSSR = isServerRendering();
    for (var key in computed) {
      var userDef = computed[key];
      var getter = typeof userDef === "function" ? userDef : userDef.get;
      if (getter == null) {
        warn('Getter is missing for computed property "' + key + '".', vm);
      }
      if (!isSSR) {
        watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
      }
      if (!(key in vm)) {
        defineComputed(vm, key, userDef);
      } else {
        if (key in vm.$data) {
          warn('The computed property "' + key + '" is already defined in data.', vm);
        } else if (vm.$options.props && key in vm.$options.props) {
          warn('The computed property "' + key + '" is already defined as a prop.', vm);
        }
      }
    }
  }
  function defineComputed(target2, key, userDef) {
    var shouldCache = !isServerRendering();
    if (typeof userDef === "function") {
      sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
      sharedPropertyDefinition.set = noop;
    } else {
      sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;
      sharedPropertyDefinition.set = userDef.set || noop;
    }
    if (sharedPropertyDefinition.set === noop) {
      sharedPropertyDefinition.set = function() {
        warn('Computed property "' + key + '" was assigned to but it has no setter.', this);
      };
    }
    Object.defineProperty(target2, key, sharedPropertyDefinition);
  }
  function createComputedGetter(key) {
    return function computedGetter() {
      var watcher = this._computedWatchers && this._computedWatchers[key];
      if (watcher) {
        if (watcher.dirty) {
          watcher.evaluate();
        }
        if (Dep.target) {
          watcher.depend();
        }
        return watcher.value;
      }
    };
  }
  function createGetterInvoker(fn) {
    return function computedGetter() {
      return fn.call(this, this);
    };
  }
  function initMethods(vm, methods) {
    var props2 = vm.$options.props;
    for (var key in methods) {
      {
        if (typeof methods[key] !== "function") {
          warn('Method "' + key + '" has type "' + typeof methods[key] + '" in the component definition. Did you reference the function correctly?', vm);
        }
        if (props2 && hasOwn(props2, key)) {
          warn('Method "' + key + '" has already been defined as a prop.', vm);
        }
        if (key in vm && isReserved(key)) {
          warn('Method "' + key + '" conflicts with an existing Vue instance method. Avoid defining component methods that start with _ or $.');
        }
      }
      vm[key] = typeof methods[key] !== "function" ? noop : bind(methods[key], vm);
    }
  }
  function initWatch(vm, watch) {
    for (var key in watch) {
      var handler = watch[key];
      if (Array.isArray(handler)) {
        for (var i = 0; i < handler.length; i++) {
          createWatcher(vm, key, handler[i]);
        }
      } else {
        createWatcher(vm, key, handler);
      }
    }
  }
  function createWatcher(vm, expOrFn, handler, options) {
    if (isPlainObject(handler)) {
      options = handler;
      handler = handler.handler;
    }
    if (typeof handler === "string") {
      handler = vm[handler];
    }
    return vm.$watch(expOrFn, handler, options);
  }
  function stateMixin(Vue6) {
    var dataDef = {};
    dataDef.get = function() {
      return this._data;
    };
    var propsDef = {};
    propsDef.get = function() {
      return this._props;
    };
    {
      dataDef.set = function() {
        warn("Avoid replacing instance root $data. Use nested data properties instead.", this);
      };
      propsDef.set = function() {
        warn("$props is readonly.", this);
      };
    }
    Object.defineProperty(Vue6.prototype, "$data", dataDef);
    Object.defineProperty(Vue6.prototype, "$props", propsDef);
    Vue6.prototype.$set = set;
    Vue6.prototype.$delete = del;
    Vue6.prototype.$watch = function(expOrFn, cb, options) {
      var vm = this;
      if (isPlainObject(cb)) {
        return createWatcher(vm, expOrFn, cb, options);
      }
      options = options || {};
      options.user = true;
      var watcher = new Watcher(vm, expOrFn, cb, options);
      if (options.immediate) {
        try {
          cb.call(vm, watcher.value);
        } catch (error) {
          handleError(error, vm, 'callback for immediate watcher "' + watcher.expression + '"');
        }
      }
      return function unwatchFn() {
        watcher.teardown();
      };
    };
  }
  var uid$3 = 0;
  function initMixin(Vue6) {
    Vue6.prototype._init = function(options) {
      var vm = this;
      vm._uid = uid$3++;
      var startTag, endTag;
      if (config.performance && mark) {
        startTag = "vue-perf-start:" + vm._uid;
        endTag = "vue-perf-end:" + vm._uid;
        mark(startTag);
      }
      vm._isVue = true;
      if (options && options._isComponent) {
        initInternalComponent(vm, options);
      } else {
        vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
      }
      {
        initProxy(vm);
      }
      vm._self = vm;
      initLifecycle(vm);
      initEvents(vm);
      initRender(vm);
      callHook(vm, "beforeCreate");
      initInjections(vm);
      initState(vm);
      initProvide(vm);
      callHook(vm, "created");
      if (config.performance && mark) {
        vm._name = formatComponentName(vm, false);
        mark(endTag);
        measure("vue " + vm._name + " init", startTag, endTag);
      }
      if (vm.$options.el) {
        vm.$mount(vm.$options.el);
      }
    };
  }
  function initInternalComponent(vm, options) {
    var opts2 = vm.$options = Object.create(vm.constructor.options);
    var parentVnode = options._parentVnode;
    opts2.parent = options.parent;
    opts2._parentVnode = parentVnode;
    var vnodeComponentOptions = parentVnode.componentOptions;
    opts2.propsData = vnodeComponentOptions.propsData;
    opts2._parentListeners = vnodeComponentOptions.listeners;
    opts2._renderChildren = vnodeComponentOptions.children;
    opts2._componentTag = vnodeComponentOptions.tag;
    if (options.render) {
      opts2.render = options.render;
      opts2.staticRenderFns = options.staticRenderFns;
    }
  }
  function resolveConstructorOptions(Ctor) {
    var options = Ctor.options;
    if (Ctor.super) {
      var superOptions = resolveConstructorOptions(Ctor.super);
      var cachedSuperOptions = Ctor.superOptions;
      if (superOptions !== cachedSuperOptions) {
        Ctor.superOptions = superOptions;
        var modifiedOptions = resolveModifiedOptions(Ctor);
        if (modifiedOptions) {
          extend(Ctor.extendOptions, modifiedOptions);
        }
        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
        if (options.name) {
          options.components[options.name] = Ctor;
        }
      }
    }
    return options;
  }
  function resolveModifiedOptions(Ctor) {
    var modified;
    var latest = Ctor.options;
    var sealed = Ctor.sealedOptions;
    for (var key in latest) {
      if (latest[key] !== sealed[key]) {
        if (!modified) {
          modified = {};
        }
        modified[key] = latest[key];
      }
    }
    return modified;
  }
  function Vue5(options) {
    if (!(this instanceof Vue5)) {
      warn("Vue is a constructor and should be called with the `new` keyword");
    }
    this._init(options);
  }
  initMixin(Vue5);
  stateMixin(Vue5);
  eventsMixin(Vue5);
  lifecycleMixin(Vue5);
  renderMixin(Vue5);
  function initUse(Vue6) {
    Vue6.use = function(plugin) {
      var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
      if (installedPlugins.indexOf(plugin) > -1) {
        return this;
      }
      var args = toArray(arguments, 1);
      args.unshift(this);
      if (typeof plugin.install === "function") {
        plugin.install.apply(plugin, args);
      } else if (typeof plugin === "function") {
        plugin.apply(null, args);
      }
      installedPlugins.push(plugin);
      return this;
    };
  }
  function initMixin$1(Vue6) {
    Vue6.mixin = function(mixin) {
      this.options = mergeOptions(this.options, mixin);
      return this;
    };
  }
  function initExtend(Vue6) {
    Vue6.cid = 0;
    var cid = 1;
    Vue6.extend = function(extendOptions) {
      extendOptions = extendOptions || {};
      var Super = this;
      var SuperId = Super.cid;
      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
      if (cachedCtors[SuperId]) {
        return cachedCtors[SuperId];
      }
      var name2 = extendOptions.name || Super.options.name;
      if (name2) {
        validateComponentName(name2);
      }
      var Sub = function VueComponent(options) {
        this._init(options);
      };
      Sub.prototype = Object.create(Super.prototype);
      Sub.prototype.constructor = Sub;
      Sub.cid = cid++;
      Sub.options = mergeOptions(Super.options, extendOptions);
      Sub["super"] = Super;
      if (Sub.options.props) {
        initProps$1(Sub);
      }
      if (Sub.options.computed) {
        initComputed$1(Sub);
      }
      Sub.extend = Super.extend;
      Sub.mixin = Super.mixin;
      Sub.use = Super.use;
      ASSET_TYPES.forEach(function(type) {
        Sub[type] = Super[type];
      });
      if (name2) {
        Sub.options.components[name2] = Sub;
      }
      Sub.superOptions = Super.options;
      Sub.extendOptions = extendOptions;
      Sub.sealedOptions = extend({}, Sub.options);
      cachedCtors[SuperId] = Sub;
      return Sub;
    };
  }
  function initProps$1(Comp) {
    var props2 = Comp.options.props;
    for (var key in props2) {
      proxy(Comp.prototype, "_props", key);
    }
  }
  function initComputed$1(Comp) {
    var computed = Comp.options.computed;
    for (var key in computed) {
      defineComputed(Comp.prototype, key, computed[key]);
    }
  }
  function initAssetRegisters(Vue6) {
    ASSET_TYPES.forEach(function(type) {
      Vue6[type] = function(id, definition) {
        if (!definition) {
          return this.options[type + "s"][id];
        } else {
          if (type === "component") {
            validateComponentName(id);
          }
          if (type === "component" && isPlainObject(definition)) {
            definition.name = definition.name || id;
            definition = this.options._base.extend(definition);
          }
          if (type === "directive" && typeof definition === "function") {
            definition = {bind: definition, update: definition};
          }
          this.options[type + "s"][id] = definition;
          return definition;
        }
      };
    });
  }
  function getComponentName(opts2) {
    return opts2 && (opts2.Ctor.options.name || opts2.tag);
  }
  function matches(pattern, name2) {
    if (Array.isArray(pattern)) {
      return pattern.indexOf(name2) > -1;
    } else if (typeof pattern === "string") {
      return pattern.split(",").indexOf(name2) > -1;
    } else if (isRegExp(pattern)) {
      return pattern.test(name2);
    }
    return false;
  }
  function pruneCache(keepAliveInstance, filter) {
    var cache = keepAliveInstance.cache;
    var keys = keepAliveInstance.keys;
    var _vnode = keepAliveInstance._vnode;
    for (var key in cache) {
      var cachedNode = cache[key];
      if (cachedNode) {
        var name2 = getComponentName(cachedNode.componentOptions);
        if (name2 && !filter(name2)) {
          pruneCacheEntry(cache, key, keys, _vnode);
        }
      }
    }
  }
  function pruneCacheEntry(cache, key, keys, current) {
    var cached$$1 = cache[key];
    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
      cached$$1.componentInstance.$destroy();
    }
    cache[key] = null;
    remove(keys, key);
  }
  var patternTypes = [String, RegExp, Array];
  var KeepAlive = {
    name: "keep-alive",
    abstract: true,
    props: {
      include: patternTypes,
      exclude: patternTypes,
      max: [String, Number]
    },
    created: function created() {
      this.cache = Object.create(null);
      this.keys = [];
    },
    destroyed: function destroyed() {
      for (var key in this.cache) {
        pruneCacheEntry(this.cache, key, this.keys);
      }
    },
    mounted: function mounted() {
      var this$1 = this;
      this.$watch("include", function(val) {
        pruneCache(this$1, function(name2) {
          return matches(val, name2);
        });
      });
      this.$watch("exclude", function(val) {
        pruneCache(this$1, function(name2) {
          return !matches(val, name2);
        });
      });
    },
    render: function render() {
      var slot = this.$slots.default;
      var vnode = getFirstComponentChild(slot);
      var componentOptions = vnode && vnode.componentOptions;
      if (componentOptions) {
        var name2 = getComponentName(componentOptions);
        var ref2 = this;
        var include = ref2.include;
        var exclude = ref2.exclude;
        if (include && (!name2 || !matches(include, name2)) || exclude && name2 && matches(exclude, name2)) {
          return vnode;
        }
        var ref$1 = this;
        var cache = ref$1.cache;
        var keys = ref$1.keys;
        var key = vnode.key == null ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : "") : vnode.key;
        if (cache[key]) {
          vnode.componentInstance = cache[key].componentInstance;
          remove(keys, key);
          keys.push(key);
        } else {
          cache[key] = vnode;
          keys.push(key);
          if (this.max && keys.length > parseInt(this.max)) {
            pruneCacheEntry(cache, keys[0], keys, this._vnode);
          }
        }
        vnode.data.keepAlive = true;
      }
      return vnode || slot && slot[0];
    }
  };
  var builtInComponents = {
    KeepAlive
  };
  function initGlobalAPI(Vue6) {
    var configDef = {};
    configDef.get = function() {
      return config;
    };
    {
      configDef.set = function() {
        warn("Do not replace the Vue.config object, set individual fields instead.");
      };
    }
    Object.defineProperty(Vue6, "config", configDef);
    Vue6.util = {
      warn,
      extend,
      mergeOptions,
      defineReactive: defineReactive$$1
    };
    Vue6.set = set;
    Vue6.delete = del;
    Vue6.nextTick = nextTick;
    Vue6.observable = function(obj) {
      observe(obj);
      return obj;
    };
    Vue6.options = Object.create(null);
    ASSET_TYPES.forEach(function(type) {
      Vue6.options[type + "s"] = Object.create(null);
    });
    Vue6.options._base = Vue6;
    extend(Vue6.options.components, builtInComponents);
    initUse(Vue6);
    initMixin$1(Vue6);
    initExtend(Vue6);
    initAssetRegisters(Vue6);
  }
  initGlobalAPI(Vue5);
  Object.defineProperty(Vue5.prototype, "$isServer", {
    get: isServerRendering
  });
  Object.defineProperty(Vue5.prototype, "$ssrContext", {
    get: function get() {
      return this.$vnode && this.$vnode.ssrContext;
    }
  });
  Object.defineProperty(Vue5, "FunctionalRenderContext", {
    value: FunctionalRenderContext
  });
  Vue5.version = "2.6.12";
  var isReservedAttr = makeMap("style,class");
  var acceptValue = makeMap("input,textarea,option,select,progress");
  var mustUseProp = function(tag, type, attr) {
    return attr === "value" && acceptValue(tag) && type !== "button" || attr === "selected" && tag === "option" || attr === "checked" && tag === "input" || attr === "muted" && tag === "video";
  };
  var isEnumeratedAttr = makeMap("contenteditable,draggable,spellcheck");
  var isValidContentEditableValue = makeMap("events,caret,typing,plaintext-only");
  var convertEnumeratedValue = function(key, value) {
    return isFalsyAttrValue(value) || value === "false" ? "false" : key === "contenteditable" && isValidContentEditableValue(value) ? value : "true";
  };
  var isBooleanAttr = makeMap("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible");
  var xlinkNS = "http://www.w3.org/1999/xlink";
  var isXlink = function(name2) {
    return name2.charAt(5) === ":" && name2.slice(0, 5) === "xlink";
  };
  var getXlinkProp = function(name2) {
    return isXlink(name2) ? name2.slice(6, name2.length) : "";
  };
  var isFalsyAttrValue = function(val) {
    return val == null || val === false;
  };
  function genClassForVnode(vnode) {
    var data = vnode.data;
    var parentNode2 = vnode;
    var childNode = vnode;
    while (isDef(childNode.componentInstance)) {
      childNode = childNode.componentInstance._vnode;
      if (childNode && childNode.data) {
        data = mergeClassData(childNode.data, data);
      }
    }
    while (isDef(parentNode2 = parentNode2.parent)) {
      if (parentNode2 && parentNode2.data) {
        data = mergeClassData(data, parentNode2.data);
      }
    }
    return renderClass(data.staticClass, data.class);
  }
  function mergeClassData(child, parent) {
    return {
      staticClass: concat(child.staticClass, parent.staticClass),
      class: isDef(child.class) ? [child.class, parent.class] : parent.class
    };
  }
  function renderClass(staticClass, dynamicClass) {
    if (isDef(staticClass) || isDef(dynamicClass)) {
      return concat(staticClass, stringifyClass(dynamicClass));
    }
    return "";
  }
  function concat(a, b) {
    return a ? b ? a + " " + b : a : b || "";
  }
  function stringifyClass(value) {
    if (Array.isArray(value)) {
      return stringifyArray(value);
    }
    if (isObject(value)) {
      return stringifyObject(value);
    }
    if (typeof value === "string") {
      return value;
    }
    return "";
  }
  function stringifyArray(value) {
    var res = "";
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
      if (isDef(stringified = stringifyClass(value[i])) && stringified !== "") {
        if (res) {
          res += " ";
        }
        res += stringified;
      }
    }
    return res;
  }
  function stringifyObject(value) {
    var res = "";
    for (var key in value) {
      if (value[key]) {
        if (res) {
          res += " ";
        }
        res += key;
      }
    }
    return res;
  }
  var namespaceMap = {
    svg: "http://www.w3.org/2000/svg",
    math: "http://www.w3.org/1998/Math/MathML"
  };
  var isHTMLTag = makeMap("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot");
  var isSVG = makeMap("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", true);
  var isReservedTag = function(tag) {
    return isHTMLTag(tag) || isSVG(tag);
  };
  function getTagNamespace(tag) {
    if (isSVG(tag)) {
      return "svg";
    }
    if (tag === "math") {
      return "math";
    }
  }
  var unknownElementCache = Object.create(null);
  function isUnknownElement(tag) {
    if (!inBrowser) {
      return true;
    }
    if (isReservedTag(tag)) {
      return false;
    }
    tag = tag.toLowerCase();
    if (unknownElementCache[tag] != null) {
      return unknownElementCache[tag];
    }
    var el = document.createElement(tag);
    if (tag.indexOf("-") > -1) {
      return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
    } else {
      return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
    }
  }
  var isTextInputType = makeMap("text,number,password,search,email,tel,url");
  function query(el) {
    if (typeof el === "string") {
      var selected = document.querySelector(el);
      if (!selected) {
        warn("Cannot find element: " + el);
        return document.createElement("div");
      }
      return selected;
    } else {
      return el;
    }
  }
  function createElement$1(tagName2, vnode) {
    var elm = document.createElement(tagName2);
    if (tagName2 !== "select") {
      return elm;
    }
    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== void 0) {
      elm.setAttribute("multiple", "multiple");
    }
    return elm;
  }
  function createElementNS(namespace, tagName2) {
    return document.createElementNS(namespaceMap[namespace], tagName2);
  }
  function createTextNode(text) {
    return document.createTextNode(text);
  }
  function createComment(text) {
    return document.createComment(text);
  }
  function insertBefore(parentNode2, newNode, referenceNode) {
    parentNode2.insertBefore(newNode, referenceNode);
  }
  function removeChild(node, child) {
    node.removeChild(child);
  }
  function appendChild(node, child) {
    node.appendChild(child);
  }
  function parentNode(node) {
    return node.parentNode;
  }
  function nextSibling(node) {
    return node.nextSibling;
  }
  function tagName(node) {
    return node.tagName;
  }
  function setTextContent(node, text) {
    node.textContent = text;
  }
  function setStyleScope(node, scopeId) {
    node.setAttribute(scopeId, "");
  }
  var nodeOps = /* @__PURE__ */ Object.freeze({
    createElement: createElement$1,
    createElementNS,
    createTextNode,
    createComment,
    insertBefore,
    removeChild,
    appendChild,
    parentNode,
    nextSibling,
    tagName,
    setTextContent,
    setStyleScope
  });
  var ref = {
    create: function create(_, vnode) {
      registerRef(vnode);
    },
    update: function update(oldVnode, vnode) {
      if (oldVnode.data.ref !== vnode.data.ref) {
        registerRef(oldVnode, true);
        registerRef(vnode);
      }
    },
    destroy: function destroy(vnode) {
      registerRef(vnode, true);
    }
  };
  function registerRef(vnode, isRemoval) {
    var key = vnode.data.ref;
    if (!isDef(key)) {
      return;
    }
    var vm = vnode.context;
    var ref2 = vnode.componentInstance || vnode.elm;
    var refs = vm.$refs;
    if (isRemoval) {
      if (Array.isArray(refs[key])) {
        remove(refs[key], ref2);
      } else if (refs[key] === ref2) {
        refs[key] = void 0;
      }
    } else {
      if (vnode.data.refInFor) {
        if (!Array.isArray(refs[key])) {
          refs[key] = [ref2];
        } else if (refs[key].indexOf(ref2) < 0) {
          refs[key].push(ref2);
        }
      } else {
        refs[key] = ref2;
      }
    }
  }
  var emptyNode = new VNode("", {}, []);
  var hooks = ["create", "activate", "update", "remove", "destroy"];
  function sameVnode(a, b) {
    return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
  }
  function sameInputType(a, b) {
    if (a.tag !== "input") {
      return true;
    }
    var i;
    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
  }
  function createKeyToOldIdx(children, beginIdx, endIdx) {
    var i, key;
    var map = {};
    for (i = beginIdx; i <= endIdx; ++i) {
      key = children[i].key;
      if (isDef(key)) {
        map[key] = i;
      }
    }
    return map;
  }
  function createPatchFunction(backend) {
    var i, j;
    var cbs = {};
    var modules2 = backend.modules;
    var nodeOps2 = backend.nodeOps;
    for (i = 0; i < hooks.length; ++i) {
      cbs[hooks[i]] = [];
      for (j = 0; j < modules2.length; ++j) {
        if (isDef(modules2[j][hooks[i]])) {
          cbs[hooks[i]].push(modules2[j][hooks[i]]);
        }
      }
    }
    function emptyNodeAt(elm) {
      return new VNode(nodeOps2.tagName(elm).toLowerCase(), {}, [], void 0, elm);
    }
    function createRmCb(childElm, listeners) {
      function remove$$1() {
        if (--remove$$1.listeners === 0) {
          removeNode(childElm);
        }
      }
      remove$$1.listeners = listeners;
      return remove$$1;
    }
    function removeNode(el) {
      var parent = nodeOps2.parentNode(el);
      if (isDef(parent)) {
        nodeOps2.removeChild(parent, el);
      }
    }
    function isUnknownElement$$1(vnode, inVPre) {
      return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function(ignore) {
        return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
      })) && config.isUnknownElement(vnode.tag);
    }
    var creatingElmInVPre = 0;
    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index2) {
      if (isDef(vnode.elm) && isDef(ownerArray)) {
        vnode = ownerArray[index2] = cloneVNode(vnode);
      }
      vnode.isRootInsert = !nested;
      if (createComponent2(vnode, insertedVnodeQueue, parentElm, refElm)) {
        return;
      }
      var data = vnode.data;
      var children = vnode.children;
      var tag = vnode.tag;
      if (isDef(tag)) {
        {
          if (data && data.pre) {
            creatingElmInVPre++;
          }
          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
            warn("Unknown custom element: <" + tag + '> - did you register the component correctly? For recursive components, make sure to provide the "name" option.', vnode.context);
          }
        }
        vnode.elm = vnode.ns ? nodeOps2.createElementNS(vnode.ns, tag) : nodeOps2.createElement(tag, vnode);
        setScope(vnode);
        {
          createChildren(vnode, children, insertedVnodeQueue);
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
          }
          insert(parentElm, vnode.elm, refElm);
        }
        if (data && data.pre) {
          creatingElmInVPre--;
        }
      } else if (isTrue(vnode.isComment)) {
        vnode.elm = nodeOps2.createComment(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      } else {
        vnode.elm = nodeOps2.createTextNode(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      }
    }
    function createComponent2(vnode, insertedVnodeQueue, parentElm, refElm) {
      var i2 = vnode.data;
      if (isDef(i2)) {
        var isReactivated = isDef(vnode.componentInstance) && i2.keepAlive;
        if (isDef(i2 = i2.hook) && isDef(i2 = i2.init)) {
          i2(vnode, false);
        }
        if (isDef(vnode.componentInstance)) {
          initComponent(vnode, insertedVnodeQueue);
          insert(parentElm, vnode.elm, refElm);
          if (isTrue(isReactivated)) {
            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
          }
          return true;
        }
      }
    }
    function initComponent(vnode, insertedVnodeQueue) {
      if (isDef(vnode.data.pendingInsert)) {
        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
        vnode.data.pendingInsert = null;
      }
      vnode.elm = vnode.componentInstance.$el;
      if (isPatchable(vnode)) {
        invokeCreateHooks(vnode, insertedVnodeQueue);
        setScope(vnode);
      } else {
        registerRef(vnode);
        insertedVnodeQueue.push(vnode);
      }
    }
    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
      var i2;
      var innerNode = vnode;
      while (innerNode.componentInstance) {
        innerNode = innerNode.componentInstance._vnode;
        if (isDef(i2 = innerNode.data) && isDef(i2 = i2.transition)) {
          for (i2 = 0; i2 < cbs.activate.length; ++i2) {
            cbs.activate[i2](emptyNode, innerNode);
          }
          insertedVnodeQueue.push(innerNode);
          break;
        }
      }
      insert(parentElm, vnode.elm, refElm);
    }
    function insert(parent, elm, ref$$1) {
      if (isDef(parent)) {
        if (isDef(ref$$1)) {
          if (nodeOps2.parentNode(ref$$1) === parent) {
            nodeOps2.insertBefore(parent, elm, ref$$1);
          }
        } else {
          nodeOps2.appendChild(parent, elm);
        }
      }
    }
    function createChildren(vnode, children, insertedVnodeQueue) {
      if (Array.isArray(children)) {
        {
          checkDuplicateKeys(children);
        }
        for (var i2 = 0; i2 < children.length; ++i2) {
          createElm(children[i2], insertedVnodeQueue, vnode.elm, null, true, children, i2);
        }
      } else if (isPrimitive(vnode.text)) {
        nodeOps2.appendChild(vnode.elm, nodeOps2.createTextNode(String(vnode.text)));
      }
    }
    function isPatchable(vnode) {
      while (vnode.componentInstance) {
        vnode = vnode.componentInstance._vnode;
      }
      return isDef(vnode.tag);
    }
    function invokeCreateHooks(vnode, insertedVnodeQueue) {
      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
        cbs.create[i$1](emptyNode, vnode);
      }
      i = vnode.data.hook;
      if (isDef(i)) {
        if (isDef(i.create)) {
          i.create(emptyNode, vnode);
        }
        if (isDef(i.insert)) {
          insertedVnodeQueue.push(vnode);
        }
      }
    }
    function setScope(vnode) {
      var i2;
      if (isDef(i2 = vnode.fnScopeId)) {
        nodeOps2.setStyleScope(vnode.elm, i2);
      } else {
        var ancestor = vnode;
        while (ancestor) {
          if (isDef(i2 = ancestor.context) && isDef(i2 = i2.$options._scopeId)) {
            nodeOps2.setStyleScope(vnode.elm, i2);
          }
          ancestor = ancestor.parent;
        }
      }
      if (isDef(i2 = activeInstance) && i2 !== vnode.context && i2 !== vnode.fnContext && isDef(i2 = i2.$options._scopeId)) {
        nodeOps2.setStyleScope(vnode.elm, i2);
      }
    }
    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
      for (; startIdx <= endIdx; ++startIdx) {
        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
      }
    }
    function invokeDestroyHook(vnode) {
      var i2, j2;
      var data = vnode.data;
      if (isDef(data)) {
        if (isDef(i2 = data.hook) && isDef(i2 = i2.destroy)) {
          i2(vnode);
        }
        for (i2 = 0; i2 < cbs.destroy.length; ++i2) {
          cbs.destroy[i2](vnode);
        }
      }
      if (isDef(i2 = vnode.children)) {
        for (j2 = 0; j2 < vnode.children.length; ++j2) {
          invokeDestroyHook(vnode.children[j2]);
        }
      }
    }
    function removeVnodes(vnodes, startIdx, endIdx) {
      for (; startIdx <= endIdx; ++startIdx) {
        var ch = vnodes[startIdx];
        if (isDef(ch)) {
          if (isDef(ch.tag)) {
            removeAndInvokeRemoveHook(ch);
            invokeDestroyHook(ch);
          } else {
            removeNode(ch.elm);
          }
        }
      }
    }
    function removeAndInvokeRemoveHook(vnode, rm) {
      if (isDef(rm) || isDef(vnode.data)) {
        var i2;
        var listeners = cbs.remove.length + 1;
        if (isDef(rm)) {
          rm.listeners += listeners;
        } else {
          rm = createRmCb(vnode.elm, listeners);
        }
        if (isDef(i2 = vnode.componentInstance) && isDef(i2 = i2._vnode) && isDef(i2.data)) {
          removeAndInvokeRemoveHook(i2, rm);
        }
        for (i2 = 0; i2 < cbs.remove.length; ++i2) {
          cbs.remove[i2](vnode, rm);
        }
        if (isDef(i2 = vnode.data.hook) && isDef(i2 = i2.remove)) {
          i2(vnode, rm);
        } else {
          rm();
        }
      } else {
        removeNode(vnode.elm);
      }
    }
    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
      var oldStartIdx = 0;
      var newStartIdx = 0;
      var oldEndIdx = oldCh.length - 1;
      var oldStartVnode = oldCh[0];
      var oldEndVnode = oldCh[oldEndIdx];
      var newEndIdx = newCh.length - 1;
      var newStartVnode = newCh[0];
      var newEndVnode = newCh[newEndIdx];
      var oldKeyToIdx, idxInOld, vnodeToMove, refElm;
      var canMove = !removeOnly;
      {
        checkDuplicateKeys(newCh);
      }
      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (isUndef(oldStartVnode)) {
          oldStartVnode = oldCh[++oldStartIdx];
        } else if (isUndef(oldEndVnode)) {
          oldEndVnode = oldCh[--oldEndIdx];
        } else if (sameVnode(oldStartVnode, newStartVnode)) {
          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
          oldStartVnode = oldCh[++oldStartIdx];
          newStartVnode = newCh[++newStartIdx];
        } else if (sameVnode(oldEndVnode, newEndVnode)) {
          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
          oldEndVnode = oldCh[--oldEndIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldStartVnode, newEndVnode)) {
          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
          canMove && nodeOps2.insertBefore(parentElm, oldStartVnode.elm, nodeOps2.nextSibling(oldEndVnode.elm));
          oldStartVnode = oldCh[++oldStartIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldEndVnode, newStartVnode)) {
          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
          canMove && nodeOps2.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
          oldEndVnode = oldCh[--oldEndIdx];
          newStartVnode = newCh[++newStartIdx];
        } else {
          if (isUndef(oldKeyToIdx)) {
            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
          }
          idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
          if (isUndef(idxInOld)) {
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          } else {
            vnodeToMove = oldCh[idxInOld];
            if (sameVnode(vnodeToMove, newStartVnode)) {
              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
              oldCh[idxInOld] = void 0;
              canMove && nodeOps2.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
            } else {
              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
            }
          }
          newStartVnode = newCh[++newStartIdx];
        }
      }
      if (oldStartIdx > oldEndIdx) {
        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
      } else if (newStartIdx > newEndIdx) {
        removeVnodes(oldCh, oldStartIdx, oldEndIdx);
      }
    }
    function checkDuplicateKeys(children) {
      var seenKeys = {};
      for (var i2 = 0; i2 < children.length; i2++) {
        var vnode = children[i2];
        var key = vnode.key;
        if (isDef(key)) {
          if (seenKeys[key]) {
            warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
          } else {
            seenKeys[key] = true;
          }
        }
      }
    }
    function findIdxInOld(node, oldCh, start, end) {
      for (var i2 = start; i2 < end; i2++) {
        var c = oldCh[i2];
        if (isDef(c) && sameVnode(node, c)) {
          return i2;
        }
      }
    }
    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index2, removeOnly) {
      if (oldVnode === vnode) {
        return;
      }
      if (isDef(vnode.elm) && isDef(ownerArray)) {
        vnode = ownerArray[index2] = cloneVNode(vnode);
      }
      var elm = vnode.elm = oldVnode.elm;
      if (isTrue(oldVnode.isAsyncPlaceholder)) {
        if (isDef(vnode.asyncFactory.resolved)) {
          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
        } else {
          vnode.isAsyncPlaceholder = true;
        }
        return;
      }
      if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
        vnode.componentInstance = oldVnode.componentInstance;
        return;
      }
      var i2;
      var data = vnode.data;
      if (isDef(data) && isDef(i2 = data.hook) && isDef(i2 = i2.prepatch)) {
        i2(oldVnode, vnode);
      }
      var oldCh = oldVnode.children;
      var ch = vnode.children;
      if (isDef(data) && isPatchable(vnode)) {
        for (i2 = 0; i2 < cbs.update.length; ++i2) {
          cbs.update[i2](oldVnode, vnode);
        }
        if (isDef(i2 = data.hook) && isDef(i2 = i2.update)) {
          i2(oldVnode, vnode);
        }
      }
      if (isUndef(vnode.text)) {
        if (isDef(oldCh) && isDef(ch)) {
          if (oldCh !== ch) {
            updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
          }
        } else if (isDef(ch)) {
          {
            checkDuplicateKeys(ch);
          }
          if (isDef(oldVnode.text)) {
            nodeOps2.setTextContent(elm, "");
          }
          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
        } else if (isDef(oldCh)) {
          removeVnodes(oldCh, 0, oldCh.length - 1);
        } else if (isDef(oldVnode.text)) {
          nodeOps2.setTextContent(elm, "");
        }
      } else if (oldVnode.text !== vnode.text) {
        nodeOps2.setTextContent(elm, vnode.text);
      }
      if (isDef(data)) {
        if (isDef(i2 = data.hook) && isDef(i2 = i2.postpatch)) {
          i2(oldVnode, vnode);
        }
      }
    }
    function invokeInsertHook(vnode, queue2, initial) {
      if (isTrue(initial) && isDef(vnode.parent)) {
        vnode.parent.data.pendingInsert = queue2;
      } else {
        for (var i2 = 0; i2 < queue2.length; ++i2) {
          queue2[i2].data.hook.insert(queue2[i2]);
        }
      }
    }
    var hydrationBailed = false;
    var isRenderedModule = makeMap("attrs,class,staticClass,staticStyle,key");
    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
      var i2;
      var tag = vnode.tag;
      var data = vnode.data;
      var children = vnode.children;
      inVPre = inVPre || data && data.pre;
      vnode.elm = elm;
      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
        vnode.isAsyncPlaceholder = true;
        return true;
      }
      {
        if (!assertNodeMatch(elm, vnode, inVPre)) {
          return false;
        }
      }
      if (isDef(data)) {
        if (isDef(i2 = data.hook) && isDef(i2 = i2.init)) {
          i2(vnode, true);
        }
        if (isDef(i2 = vnode.componentInstance)) {
          initComponent(vnode, insertedVnodeQueue);
          return true;
        }
      }
      if (isDef(tag)) {
        if (isDef(children)) {
          if (!elm.hasChildNodes()) {
            createChildren(vnode, children, insertedVnodeQueue);
          } else {
            if (isDef(i2 = data) && isDef(i2 = i2.domProps) && isDef(i2 = i2.innerHTML)) {
              if (i2 !== elm.innerHTML) {
                if (typeof console !== "undefined" && !hydrationBailed) {
                  hydrationBailed = true;
                  console.warn("Parent: ", elm);
                  console.warn("server innerHTML: ", i2);
                  console.warn("client innerHTML: ", elm.innerHTML);
                }
                return false;
              }
            } else {
              var childrenMatch = true;
              var childNode = elm.firstChild;
              for (var i$1 = 0; i$1 < children.length; i$1++) {
                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                  childrenMatch = false;
                  break;
                }
                childNode = childNode.nextSibling;
              }
              if (!childrenMatch || childNode) {
                if (typeof console !== "undefined" && !hydrationBailed) {
                  hydrationBailed = true;
                  console.warn("Parent: ", elm);
                  console.warn("Mismatching childNodes vs. VNodes: ", elm.childNodes, children);
                }
                return false;
              }
            }
          }
        }
        if (isDef(data)) {
          var fullInvoke = false;
          for (var key in data) {
            if (!isRenderedModule(key)) {
              fullInvoke = true;
              invokeCreateHooks(vnode, insertedVnodeQueue);
              break;
            }
          }
          if (!fullInvoke && data["class"]) {
            traverse(data["class"]);
          }
        }
      } else if (elm.data !== vnode.text) {
        elm.data = vnode.text;
      }
      return true;
    }
    function assertNodeMatch(node, vnode, inVPre) {
      if (isDef(vnode.tag)) {
        return vnode.tag.indexOf("vue-component") === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
      } else {
        return node.nodeType === (vnode.isComment ? 8 : 3);
      }
    }
    return function patch2(oldVnode, vnode, hydrating, removeOnly) {
      if (isUndef(vnode)) {
        if (isDef(oldVnode)) {
          invokeDestroyHook(oldVnode);
        }
        return;
      }
      var isInitialPatch = false;
      var insertedVnodeQueue = [];
      if (isUndef(oldVnode)) {
        isInitialPatch = true;
        createElm(vnode, insertedVnodeQueue);
      } else {
        var isRealElement = isDef(oldVnode.nodeType);
        if (!isRealElement && sameVnode(oldVnode, vnode)) {
          patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
        } else {
          if (isRealElement) {
            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
              oldVnode.removeAttribute(SSR_ATTR);
              hydrating = true;
            }
            if (isTrue(hydrating)) {
              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                invokeInsertHook(vnode, insertedVnodeQueue, true);
                return oldVnode;
              } else {
                warn("The client-side rendered virtual DOM tree is not matching server-rendered content. This is likely caused by incorrect HTML markup, for example nesting block-level elements inside <p>, or missing <tbody>. Bailing hydration and performing full client-side render.");
              }
            }
            oldVnode = emptyNodeAt(oldVnode);
          }
          var oldElm = oldVnode.elm;
          var parentElm = nodeOps2.parentNode(oldElm);
          createElm(vnode, insertedVnodeQueue, oldElm._leaveCb ? null : parentElm, nodeOps2.nextSibling(oldElm));
          if (isDef(vnode.parent)) {
            var ancestor = vnode.parent;
            var patchable = isPatchable(vnode);
            while (ancestor) {
              for (var i2 = 0; i2 < cbs.destroy.length; ++i2) {
                cbs.destroy[i2](ancestor);
              }
              ancestor.elm = vnode.elm;
              if (patchable) {
                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                  cbs.create[i$1](emptyNode, ancestor);
                }
                var insert2 = ancestor.data.hook.insert;
                if (insert2.merged) {
                  for (var i$2 = 1; i$2 < insert2.fns.length; i$2++) {
                    insert2.fns[i$2]();
                  }
                }
              } else {
                registerRef(ancestor);
              }
              ancestor = ancestor.parent;
            }
          }
          if (isDef(parentElm)) {
            removeVnodes([oldVnode], 0, 0);
          } else if (isDef(oldVnode.tag)) {
            invokeDestroyHook(oldVnode);
          }
        }
      }
      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
      return vnode.elm;
    };
  }
  var directives = {
    create: updateDirectives,
    update: updateDirectives,
    destroy: function unbindDirectives(vnode) {
      updateDirectives(vnode, emptyNode);
    }
  };
  function updateDirectives(oldVnode, vnode) {
    if (oldVnode.data.directives || vnode.data.directives) {
      _update(oldVnode, vnode);
    }
  }
  function _update(oldVnode, vnode) {
    var isCreate = oldVnode === emptyNode;
    var isDestroy = vnode === emptyNode;
    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
    var dirsWithInsert = [];
    var dirsWithPostpatch = [];
    var key, oldDir, dir;
    for (key in newDirs) {
      oldDir = oldDirs[key];
      dir = newDirs[key];
      if (!oldDir) {
        callHook$1(dir, "bind", vnode, oldVnode);
        if (dir.def && dir.def.inserted) {
          dirsWithInsert.push(dir);
        }
      } else {
        dir.oldValue = oldDir.value;
        dir.oldArg = oldDir.arg;
        callHook$1(dir, "update", vnode, oldVnode);
        if (dir.def && dir.def.componentUpdated) {
          dirsWithPostpatch.push(dir);
        }
      }
    }
    if (dirsWithInsert.length) {
      var callInsert = function() {
        for (var i = 0; i < dirsWithInsert.length; i++) {
          callHook$1(dirsWithInsert[i], "inserted", vnode, oldVnode);
        }
      };
      if (isCreate) {
        mergeVNodeHook(vnode, "insert", callInsert);
      } else {
        callInsert();
      }
    }
    if (dirsWithPostpatch.length) {
      mergeVNodeHook(vnode, "postpatch", function() {
        for (var i = 0; i < dirsWithPostpatch.length; i++) {
          callHook$1(dirsWithPostpatch[i], "componentUpdated", vnode, oldVnode);
        }
      });
    }
    if (!isCreate) {
      for (key in oldDirs) {
        if (!newDirs[key]) {
          callHook$1(oldDirs[key], "unbind", oldVnode, oldVnode, isDestroy);
        }
      }
    }
  }
  var emptyModifiers = Object.create(null);
  function normalizeDirectives$1(dirs, vm) {
    var res = Object.create(null);
    if (!dirs) {
      return res;
    }
    var i, dir;
    for (i = 0; i < dirs.length; i++) {
      dir = dirs[i];
      if (!dir.modifiers) {
        dir.modifiers = emptyModifiers;
      }
      res[getRawDirName(dir)] = dir;
      dir.def = resolveAsset(vm.$options, "directives", dir.name, true);
    }
    return res;
  }
  function getRawDirName(dir) {
    return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join(".");
  }
  function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
    var fn = dir.def && dir.def[hook];
    if (fn) {
      try {
        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
      } catch (e) {
        handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
      }
    }
  }
  var baseModules = [
    ref,
    directives
  ];
  function updateAttrs(oldVnode, vnode) {
    var opts2 = vnode.componentOptions;
    if (isDef(opts2) && opts2.Ctor.options.inheritAttrs === false) {
      return;
    }
    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
      return;
    }
    var key, cur, old;
    var elm = vnode.elm;
    var oldAttrs = oldVnode.data.attrs || {};
    var attrs2 = vnode.data.attrs || {};
    if (isDef(attrs2.__ob__)) {
      attrs2 = vnode.data.attrs = extend({}, attrs2);
    }
    for (key in attrs2) {
      cur = attrs2[key];
      old = oldAttrs[key];
      if (old !== cur) {
        setAttr(elm, key, cur);
      }
    }
    if ((isIE || isEdge) && attrs2.value !== oldAttrs.value) {
      setAttr(elm, "value", attrs2.value);
    }
    for (key in oldAttrs) {
      if (isUndef(attrs2[key])) {
        if (isXlink(key)) {
          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
        } else if (!isEnumeratedAttr(key)) {
          elm.removeAttribute(key);
        }
      }
    }
  }
  function setAttr(el, key, value) {
    if (el.tagName.indexOf("-") > -1) {
      baseSetAttr(el, key, value);
    } else if (isBooleanAttr(key)) {
      if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
      } else {
        value = key === "allowfullscreen" && el.tagName === "EMBED" ? "true" : key;
        el.setAttribute(key, value);
      }
    } else if (isEnumeratedAttr(key)) {
      el.setAttribute(key, convertEnumeratedValue(key, value));
    } else if (isXlink(key)) {
      if (isFalsyAttrValue(value)) {
        el.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      baseSetAttr(el, key, value);
    }
  }
  function baseSetAttr(el, key, value) {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      if (isIE && !isIE9 && el.tagName === "TEXTAREA" && key === "placeholder" && value !== "" && !el.__ieph) {
        var blocker = function(e) {
          e.stopImmediatePropagation();
          el.removeEventListener("input", blocker);
        };
        el.addEventListener("input", blocker);
        el.__ieph = true;
      }
      el.setAttribute(key, value);
    }
  }
  var attrs = {
    create: updateAttrs,
    update: updateAttrs
  };
  function updateClass(oldVnode, vnode) {
    var el = vnode.elm;
    var data = vnode.data;
    var oldData = oldVnode.data;
    if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
      return;
    }
    var cls = genClassForVnode(vnode);
    var transitionClass = el._transitionClasses;
    if (isDef(transitionClass)) {
      cls = concat(cls, stringifyClass(transitionClass));
    }
    if (cls !== el._prevClass) {
      el.setAttribute("class", cls);
      el._prevClass = cls;
    }
  }
  var klass = {
    create: updateClass,
    update: updateClass
  };
  var RANGE_TOKEN = "__r";
  var CHECKBOX_RADIO_TOKEN = "__c";
  function normalizeEvents(on) {
    if (isDef(on[RANGE_TOKEN])) {
      var event = isIE ? "change" : "input";
      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
      delete on[RANGE_TOKEN];
    }
    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
      delete on[CHECKBOX_RADIO_TOKEN];
    }
  }
  var target$1;
  function createOnceHandler$1(event, handler, capture) {
    var _target = target$1;
    return function onceHandler() {
      var res = handler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, onceHandler, capture, _target);
      }
    };
  }
  var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);
  function add$1(name2, handler, capture, passive) {
    if (useMicrotaskFix) {
      var attachedTimestamp = currentFlushTimestamp;
      var original = handler;
      handler = original._wrapper = function(e) {
        if (e.target === e.currentTarget || e.timeStamp >= attachedTimestamp || e.timeStamp <= 0 || e.target.ownerDocument !== document) {
          return original.apply(this, arguments);
        }
      };
    }
    target$1.addEventListener(name2, handler, supportsPassive ? {capture, passive} : capture);
  }
  function remove$2(name2, handler, capture, _target) {
    (_target || target$1).removeEventListener(name2, handler._wrapper || handler, capture);
  }
  function updateDOMListeners(oldVnode, vnode) {
    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
      return;
    }
    var on = vnode.data.on || {};
    var oldOn = oldVnode.data.on || {};
    target$1 = vnode.elm;
    normalizeEvents(on);
    updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
    target$1 = void 0;
  }
  var events = {
    create: updateDOMListeners,
    update: updateDOMListeners
  };
  var svgContainer;
  function updateDOMProps(oldVnode, vnode) {
    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
      return;
    }
    var key, cur;
    var elm = vnode.elm;
    var oldProps = oldVnode.data.domProps || {};
    var props2 = vnode.data.domProps || {};
    if (isDef(props2.__ob__)) {
      props2 = vnode.data.domProps = extend({}, props2);
    }
    for (key in oldProps) {
      if (!(key in props2)) {
        elm[key] = "";
      }
    }
    for (key in props2) {
      cur = props2[key];
      if (key === "textContent" || key === "innerHTML") {
        if (vnode.children) {
          vnode.children.length = 0;
        }
        if (cur === oldProps[key]) {
          continue;
        }
        if (elm.childNodes.length === 1) {
          elm.removeChild(elm.childNodes[0]);
        }
      }
      if (key === "value" && elm.tagName !== "PROGRESS") {
        elm._value = cur;
        var strCur = isUndef(cur) ? "" : String(cur);
        if (shouldUpdateValue(elm, strCur)) {
          elm.value = strCur;
        }
      } else if (key === "innerHTML" && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
        svgContainer = svgContainer || document.createElement("div");
        svgContainer.innerHTML = "<svg>" + cur + "</svg>";
        var svg = svgContainer.firstChild;
        while (elm.firstChild) {
          elm.removeChild(elm.firstChild);
        }
        while (svg.firstChild) {
          elm.appendChild(svg.firstChild);
        }
      } else if (cur !== oldProps[key]) {
        try {
          elm[key] = cur;
        } catch (e) {
        }
      }
    }
  }
  function shouldUpdateValue(elm, checkVal) {
    return !elm.composing && (elm.tagName === "OPTION" || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
  }
  function isNotInFocusAndDirty(elm, checkVal) {
    var notInFocus = true;
    try {
      notInFocus = document.activeElement !== elm;
    } catch (e) {
    }
    return notInFocus && elm.value !== checkVal;
  }
  function isDirtyWithModifiers(elm, newVal) {
    var value = elm.value;
    var modifiers = elm._vModifiers;
    if (isDef(modifiers)) {
      if (modifiers.number) {
        return toNumber(value) !== toNumber(newVal);
      }
      if (modifiers.trim) {
        return value.trim() !== newVal.trim();
      }
    }
    return value !== newVal;
  }
  var domProps = {
    create: updateDOMProps,
    update: updateDOMProps
  };
  var parseStyleText = cached(function(cssText) {
    var res = {};
    var listDelimiter = /;(?![^(]*\))/g;
    var propertyDelimiter = /:(.+)/;
    cssText.split(listDelimiter).forEach(function(item) {
      if (item) {
        var tmp = item.split(propertyDelimiter);
        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return res;
  });
  function normalizeStyleData(data) {
    var style2 = normalizeStyleBinding(data.style);
    return data.staticStyle ? extend(data.staticStyle, style2) : style2;
  }
  function normalizeStyleBinding(bindingStyle) {
    if (Array.isArray(bindingStyle)) {
      return toObject(bindingStyle);
    }
    if (typeof bindingStyle === "string") {
      return parseStyleText(bindingStyle);
    }
    return bindingStyle;
  }
  function getStyle(vnode, checkChild) {
    var res = {};
    var styleData;
    if (checkChild) {
      var childNode = vnode;
      while (childNode.componentInstance) {
        childNode = childNode.componentInstance._vnode;
        if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
          extend(res, styleData);
        }
      }
    }
    if (styleData = normalizeStyleData(vnode.data)) {
      extend(res, styleData);
    }
    var parentNode2 = vnode;
    while (parentNode2 = parentNode2.parent) {
      if (parentNode2.data && (styleData = normalizeStyleData(parentNode2.data))) {
        extend(res, styleData);
      }
    }
    return res;
  }
  var cssVarRE = /^--/;
  var importantRE = /\s*!important$/;
  var setProp = function(el, name2, val) {
    if (cssVarRE.test(name2)) {
      el.style.setProperty(name2, val);
    } else if (importantRE.test(val)) {
      el.style.setProperty(hyphenate(name2), val.replace(importantRE, ""), "important");
    } else {
      var normalizedName = normalize(name2);
      if (Array.isArray(val)) {
        for (var i = 0, len = val.length; i < len; i++) {
          el.style[normalizedName] = val[i];
        }
      } else {
        el.style[normalizedName] = val;
      }
    }
  };
  var vendorNames = ["Webkit", "Moz", "ms"];
  var emptyStyle;
  var normalize = cached(function(prop) {
    emptyStyle = emptyStyle || document.createElement("div").style;
    prop = camelize(prop);
    if (prop !== "filter" && prop in emptyStyle) {
      return prop;
    }
    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
    for (var i = 0; i < vendorNames.length; i++) {
      var name2 = vendorNames[i] + capName;
      if (name2 in emptyStyle) {
        return name2;
      }
    }
  });
  function updateStyle(oldVnode, vnode) {
    var data = vnode.data;
    var oldData = oldVnode.data;
    if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
      return;
    }
    var cur, name2;
    var el = vnode.elm;
    var oldStaticStyle = oldData.staticStyle;
    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};
    var oldStyle = oldStaticStyle || oldStyleBinding;
    var style2 = normalizeStyleBinding(vnode.data.style) || {};
    vnode.data.normalizedStyle = isDef(style2.__ob__) ? extend({}, style2) : style2;
    var newStyle = getStyle(vnode, true);
    for (name2 in oldStyle) {
      if (isUndef(newStyle[name2])) {
        setProp(el, name2, "");
      }
    }
    for (name2 in newStyle) {
      cur = newStyle[name2];
      if (cur !== oldStyle[name2]) {
        setProp(el, name2, cur == null ? "" : cur);
      }
    }
  }
  var style = {
    create: updateStyle,
    update: updateStyle
  };
  var whitespaceRE = /\s+/;
  function addClass(el, cls) {
    if (!cls || !(cls = cls.trim())) {
      return;
    }
    if (el.classList) {
      if (cls.indexOf(" ") > -1) {
        cls.split(whitespaceRE).forEach(function(c) {
          return el.classList.add(c);
        });
      } else {
        el.classList.add(cls);
      }
    } else {
      var cur = " " + (el.getAttribute("class") || "") + " ";
      if (cur.indexOf(" " + cls + " ") < 0) {
        el.setAttribute("class", (cur + cls).trim());
      }
    }
  }
  function removeClass(el, cls) {
    if (!cls || !(cls = cls.trim())) {
      return;
    }
    if (el.classList) {
      if (cls.indexOf(" ") > -1) {
        cls.split(whitespaceRE).forEach(function(c) {
          return el.classList.remove(c);
        });
      } else {
        el.classList.remove(cls);
      }
      if (!el.classList.length) {
        el.removeAttribute("class");
      }
    } else {
      var cur = " " + (el.getAttribute("class") || "") + " ";
      var tar = " " + cls + " ";
      while (cur.indexOf(tar) >= 0) {
        cur = cur.replace(tar, " ");
      }
      cur = cur.trim();
      if (cur) {
        el.setAttribute("class", cur);
      } else {
        el.removeAttribute("class");
      }
    }
  }
  function resolveTransition(def$$1) {
    if (!def$$1) {
      return;
    }
    if (typeof def$$1 === "object") {
      var res = {};
      if (def$$1.css !== false) {
        extend(res, autoCssTransition(def$$1.name || "v"));
      }
      extend(res, def$$1);
      return res;
    } else if (typeof def$$1 === "string") {
      return autoCssTransition(def$$1);
    }
  }
  var autoCssTransition = cached(function(name2) {
    return {
      enterClass: name2 + "-enter",
      enterToClass: name2 + "-enter-to",
      enterActiveClass: name2 + "-enter-active",
      leaveClass: name2 + "-leave",
      leaveToClass: name2 + "-leave-to",
      leaveActiveClass: name2 + "-leave-active"
    };
  });
  var hasTransition = inBrowser && !isIE9;
  var TRANSITION = "transition";
  var ANIMATION = "animation";
  var transitionProp = "transition";
  var transitionEndEvent = "transitionend";
  var animationProp = "animation";
  var animationEndEvent = "animationend";
  if (hasTransition) {
    if (window.ontransitionend === void 0 && window.onwebkittransitionend !== void 0) {
      transitionProp = "WebkitTransition";
      transitionEndEvent = "webkitTransitionEnd";
    }
    if (window.onanimationend === void 0 && window.onwebkitanimationend !== void 0) {
      animationProp = "WebkitAnimation";
      animationEndEvent = "webkitAnimationEnd";
    }
  }
  var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : function(fn) {
    return fn();
  };
  function nextFrame(fn) {
    raf(function() {
      raf(fn);
    });
  }
  function addTransitionClass(el, cls) {
    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
    if (transitionClasses.indexOf(cls) < 0) {
      transitionClasses.push(cls);
      addClass(el, cls);
    }
  }
  function removeTransitionClass(el, cls) {
    if (el._transitionClasses) {
      remove(el._transitionClasses, cls);
    }
    removeClass(el, cls);
  }
  function whenTransitionEnds(el, expectedType, cb) {
    var ref2 = getTransitionInfo(el, expectedType);
    var type = ref2.type;
    var timeout = ref2.timeout;
    var propCount = ref2.propCount;
    if (!type) {
      return cb();
    }
    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
    var ended = 0;
    var end = function() {
      el.removeEventListener(event, onEnd);
      cb();
    };
    var onEnd = function(e) {
      if (e.target === el) {
        if (++ended >= propCount) {
          end();
        }
      }
    };
    setTimeout(function() {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(event, onEnd);
  }
  var transformRE = /\b(transform|all)(,|$)/;
  function getTransitionInfo(el, expectedType) {
    var styles = window.getComputedStyle(el);
    var transitionDelays = (styles[transitionProp + "Delay"] || "").split(", ");
    var transitionDurations = (styles[transitionProp + "Duration"] || "").split(", ");
    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    var animationDelays = (styles[animationProp + "Delay"] || "").split(", ");
    var animationDurations = (styles[animationProp + "Duration"] || "").split(", ");
    var animationTimeout = getTimeout(animationDelays, animationDurations);
    var type;
    var timeout = 0;
    var propCount = 0;
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + "Property"]);
    return {
      type,
      timeout,
      propCount,
      hasTransform
    };
  }
  function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }
    return Math.max.apply(null, durations.map(function(d, i) {
      return toMs(d) + toMs(delays[i]);
    }));
  }
  function toMs(s) {
    return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function enter(vnode, toggleDisplay) {
    var el = vnode.elm;
    if (isDef(el._leaveCb)) {
      el._leaveCb.cancelled = true;
      el._leaveCb();
    }
    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data)) {
      return;
    }
    if (isDef(el._enterCb) || el.nodeType !== 1) {
      return;
    }
    var css = data.css;
    var type = data.type;
    var enterClass = data.enterClass;
    var enterToClass = data.enterToClass;
    var enterActiveClass = data.enterActiveClass;
    var appearClass = data.appearClass;
    var appearToClass = data.appearToClass;
    var appearActiveClass = data.appearActiveClass;
    var beforeEnter = data.beforeEnter;
    var enter2 = data.enter;
    var afterEnter = data.afterEnter;
    var enterCancelled = data.enterCancelled;
    var beforeAppear = data.beforeAppear;
    var appear = data.appear;
    var afterAppear = data.afterAppear;
    var appearCancelled = data.appearCancelled;
    var duration = data.duration;
    var context = activeInstance;
    var transitionNode = activeInstance.$vnode;
    while (transitionNode && transitionNode.parent) {
      context = transitionNode.context;
      transitionNode = transitionNode.parent;
    }
    var isAppear = !context._isMounted || !vnode.isRootInsert;
    if (isAppear && !appear && appear !== "") {
      return;
    }
    var startClass = isAppear && appearClass ? appearClass : enterClass;
    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
    var enterHook = isAppear ? typeof appear === "function" ? appear : enter2 : enter2;
    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
    var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);
    if (explicitEnterDuration != null) {
      checkDuration(explicitEnterDuration, "enter", vnode);
    }
    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(enterHook);
    var cb = el._enterCb = once(function() {
      if (expectsCSS) {
        removeTransitionClass(el, toClass);
        removeTransitionClass(el, activeClass);
      }
      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, startClass);
        }
        enterCancelledHook && enterCancelledHook(el);
      } else {
        afterEnterHook && afterEnterHook(el);
      }
      el._enterCb = null;
    });
    if (!vnode.data.show) {
      mergeVNodeHook(vnode, "insert", function() {
        var parent = el.parentNode;
        var pendingNode = parent && parent._pending && parent._pending[vnode.key];
        if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
          pendingNode.elm._leaveCb();
        }
        enterHook && enterHook(el, cb);
      });
    }
    beforeEnterHook && beforeEnterHook(el);
    if (expectsCSS) {
      addTransitionClass(el, startClass);
      addTransitionClass(el, activeClass);
      nextFrame(function() {
        removeTransitionClass(el, startClass);
        if (!cb.cancelled) {
          addTransitionClass(el, toClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitEnterDuration)) {
              setTimeout(cb, explicitEnterDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }
    if (vnode.data.show) {
      toggleDisplay && toggleDisplay();
      enterHook && enterHook(el, cb);
    }
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
  function leave(vnode, rm) {
    var el = vnode.elm;
    if (isDef(el._enterCb)) {
      el._enterCb.cancelled = true;
      el._enterCb();
    }
    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data) || el.nodeType !== 1) {
      return rm();
    }
    if (isDef(el._leaveCb)) {
      return;
    }
    var css = data.css;
    var type = data.type;
    var leaveClass = data.leaveClass;
    var leaveToClass = data.leaveToClass;
    var leaveActiveClass = data.leaveActiveClass;
    var beforeLeave = data.beforeLeave;
    var leave2 = data.leave;
    var afterLeave = data.afterLeave;
    var leaveCancelled = data.leaveCancelled;
    var delayLeave = data.delayLeave;
    var duration = data.duration;
    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(leave2);
    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);
    if (isDef(explicitLeaveDuration)) {
      checkDuration(explicitLeaveDuration, "leave", vnode);
    }
    var cb = el._leaveCb = once(function() {
      if (el.parentNode && el.parentNode._pending) {
        el.parentNode._pending[vnode.key] = null;
      }
      if (expectsCSS) {
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
      }
      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, leaveClass);
        }
        leaveCancelled && leaveCancelled(el);
      } else {
        rm();
        afterLeave && afterLeave(el);
      }
      el._leaveCb = null;
    });
    if (delayLeave) {
      delayLeave(performLeave);
    } else {
      performLeave();
    }
    function performLeave() {
      if (cb.cancelled) {
        return;
      }
      if (!vnode.data.show && el.parentNode) {
        (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
      }
      beforeLeave && beforeLeave(el);
      if (expectsCSS) {
        addTransitionClass(el, leaveClass);
        addTransitionClass(el, leaveActiveClass);
        nextFrame(function() {
          removeTransitionClass(el, leaveClass);
          if (!cb.cancelled) {
            addTransitionClass(el, leaveToClass);
            if (!userWantsControl) {
              if (isValidDuration(explicitLeaveDuration)) {
                setTimeout(cb, explicitLeaveDuration);
              } else {
                whenTransitionEnds(el, type, cb);
              }
            }
          }
        });
      }
      leave2 && leave2(el, cb);
      if (!expectsCSS && !userWantsControl) {
        cb();
      }
    }
  }
  function checkDuration(val, name2, vnode) {
    if (typeof val !== "number") {
      warn("<transition> explicit " + name2 + " duration is not a valid number - got " + JSON.stringify(val) + ".", vnode.context);
    } else if (isNaN(val)) {
      warn("<transition> explicit " + name2 + " duration is NaN - the duration expression might be incorrect.", vnode.context);
    }
  }
  function isValidDuration(val) {
    return typeof val === "number" && !isNaN(val);
  }
  function getHookArgumentsLength(fn) {
    if (isUndef(fn)) {
      return false;
    }
    var invokerFns = fn.fns;
    if (isDef(invokerFns)) {
      return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
    } else {
      return (fn._length || fn.length) > 1;
    }
  }
  function _enter(_, vnode) {
    if (vnode.data.show !== true) {
      enter(vnode);
    }
  }
  var transition = inBrowser ? {
    create: _enter,
    activate: _enter,
    remove: function remove$$1(vnode, rm) {
      if (vnode.data.show !== true) {
        leave(vnode, rm);
      } else {
        rm();
      }
    }
  } : {};
  var platformModules = [
    attrs,
    klass,
    events,
    domProps,
    style,
    transition
  ];
  var modules = platformModules.concat(baseModules);
  var patch = createPatchFunction({nodeOps, modules});
  if (isIE9) {
    document.addEventListener("selectionchange", function() {
      var el = document.activeElement;
      if (el && el.vmodel) {
        trigger(el, "input");
      }
    });
  }
  var directive = {
    inserted: function inserted(el, binding, vnode, oldVnode) {
      if (vnode.tag === "select") {
        if (oldVnode.elm && !oldVnode.elm._vOptions) {
          mergeVNodeHook(vnode, "postpatch", function() {
            directive.componentUpdated(el, binding, vnode);
          });
        } else {
          setSelected(el, binding, vnode.context);
        }
        el._vOptions = [].map.call(el.options, getValue);
      } else if (vnode.tag === "textarea" || isTextInputType(el.type)) {
        el._vModifiers = binding.modifiers;
        if (!binding.modifiers.lazy) {
          el.addEventListener("compositionstart", onCompositionStart);
          el.addEventListener("compositionend", onCompositionEnd);
          el.addEventListener("change", onCompositionEnd);
          if (isIE9) {
            el.vmodel = true;
          }
        }
      }
    },
    componentUpdated: function componentUpdated(el, binding, vnode) {
      if (vnode.tag === "select") {
        setSelected(el, binding, vnode.context);
        var prevOptions = el._vOptions;
        var curOptions = el._vOptions = [].map.call(el.options, getValue);
        if (curOptions.some(function(o, i) {
          return !looseEqual(o, prevOptions[i]);
        })) {
          var needReset = el.multiple ? binding.value.some(function(v) {
            return hasNoMatchingOption(v, curOptions);
          }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
          if (needReset) {
            trigger(el, "change");
          }
        }
      }
    }
  };
  function setSelected(el, binding, vm) {
    actuallySetSelected(el, binding, vm);
    if (isIE || isEdge) {
      setTimeout(function() {
        actuallySetSelected(el, binding, vm);
      }, 0);
    }
  }
  function actuallySetSelected(el, binding, vm) {
    var value = binding.value;
    var isMultiple = el.multiple;
    if (isMultiple && !Array.isArray(value)) {
      warn('<select multiple v-model="' + binding.expression + '"> expects an Array value for its binding, but got ' + Object.prototype.toString.call(value).slice(8, -1), vm);
      return;
    }
    var selected, option;
    for (var i = 0, l = el.options.length; i < l; i++) {
      option = el.options[i];
      if (isMultiple) {
        selected = looseIndexOf(value, getValue(option)) > -1;
        if (option.selected !== selected) {
          option.selected = selected;
        }
      } else {
        if (looseEqual(getValue(option), value)) {
          if (el.selectedIndex !== i) {
            el.selectedIndex = i;
          }
          return;
        }
      }
    }
    if (!isMultiple) {
      el.selectedIndex = -1;
    }
  }
  function hasNoMatchingOption(value, options) {
    return options.every(function(o) {
      return !looseEqual(o, value);
    });
  }
  function getValue(option) {
    return "_value" in option ? option._value : option.value;
  }
  function onCompositionStart(e) {
    e.target.composing = true;
  }
  function onCompositionEnd(e) {
    if (!e.target.composing) {
      return;
    }
    e.target.composing = false;
    trigger(e.target, "input");
  }
  function trigger(el, type) {
    var e = document.createEvent("HTMLEvents");
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
  }
  function locateNode(vnode) {
    return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
  }
  var show = {
    bind: function bind2(el, ref2, vnode) {
      var value = ref2.value;
      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      var originalDisplay = el.__vOriginalDisplay = el.style.display === "none" ? "" : el.style.display;
      if (value && transition$$1) {
        vnode.data.show = true;
        enter(vnode, function() {
          el.style.display = originalDisplay;
        });
      } else {
        el.style.display = value ? originalDisplay : "none";
      }
    },
    update: function update(el, ref2, vnode) {
      var value = ref2.value;
      var oldValue = ref2.oldValue;
      if (!value === !oldValue) {
        return;
      }
      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      if (transition$$1) {
        vnode.data.show = true;
        if (value) {
          enter(vnode, function() {
            el.style.display = el.__vOriginalDisplay;
          });
        } else {
          leave(vnode, function() {
            el.style.display = "none";
          });
        }
      } else {
        el.style.display = value ? el.__vOriginalDisplay : "none";
      }
    },
    unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
      if (!isDestroy) {
        el.style.display = el.__vOriginalDisplay;
      }
    }
  };
  var platformDirectives = {
    model: directive,
    show
  };
  var transitionProps = {
    name: String,
    appear: Boolean,
    css: Boolean,
    mode: String,
    type: String,
    enterClass: String,
    leaveClass: String,
    enterToClass: String,
    leaveToClass: String,
    enterActiveClass: String,
    leaveActiveClass: String,
    appearClass: String,
    appearActiveClass: String,
    appearToClass: String,
    duration: [Number, String, Object]
  };
  function getRealChild(vnode) {
    var compOptions = vnode && vnode.componentOptions;
    if (compOptions && compOptions.Ctor.options.abstract) {
      return getRealChild(getFirstComponentChild(compOptions.children));
    } else {
      return vnode;
    }
  }
  function extractTransitionData(comp) {
    var data = {};
    var options = comp.$options;
    for (var key in options.propsData) {
      data[key] = comp[key];
    }
    var listeners = options._parentListeners;
    for (var key$1 in listeners) {
      data[camelize(key$1)] = listeners[key$1];
    }
    return data;
  }
  function placeholder(h, rawChild) {
    if (/\d-keep-alive$/.test(rawChild.tag)) {
      return h("keep-alive", {
        props: rawChild.componentOptions.propsData
      });
    }
  }
  function hasParentTransition(vnode) {
    while (vnode = vnode.parent) {
      if (vnode.data.transition) {
        return true;
      }
    }
  }
  function isSameChild(child, oldChild) {
    return oldChild.key === child.key && oldChild.tag === child.tag;
  }
  var isNotTextNode = function(c) {
    return c.tag || isAsyncPlaceholder(c);
  };
  var isVShowDirective = function(d) {
    return d.name === "show";
  };
  var Transition = {
    name: "transition",
    props: transitionProps,
    abstract: true,
    render: function render(h) {
      var this$1 = this;
      var children = this.$slots.default;
      if (!children) {
        return;
      }
      children = children.filter(isNotTextNode);
      if (!children.length) {
        return;
      }
      if (children.length > 1) {
        warn("<transition> can only be used on a single element. Use <transition-group> for lists.", this.$parent);
      }
      var mode = this.mode;
      if (mode && mode !== "in-out" && mode !== "out-in") {
        warn("invalid <transition> mode: " + mode, this.$parent);
      }
      var rawChild = children[0];
      if (hasParentTransition(this.$vnode)) {
        return rawChild;
      }
      var child = getRealChild(rawChild);
      if (!child) {
        return rawChild;
      }
      if (this._leaving) {
        return placeholder(h, rawChild);
      }
      var id = "__transition-" + this._uid + "-";
      child.key = child.key == null ? child.isComment ? id + "comment" : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
      var oldRawChild = this._vnode;
      var oldChild = getRealChild(oldRawChild);
      if (child.data.directives && child.data.directives.some(isVShowDirective)) {
        child.data.show = true;
      }
      if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
        var oldData = oldChild.data.transition = extend({}, data);
        if (mode === "out-in") {
          this._leaving = true;
          mergeVNodeHook(oldData, "afterLeave", function() {
            this$1._leaving = false;
            this$1.$forceUpdate();
          });
          return placeholder(h, rawChild);
        } else if (mode === "in-out") {
          if (isAsyncPlaceholder(child)) {
            return oldRawChild;
          }
          var delayedLeave;
          var performLeave = function() {
            delayedLeave();
          };
          mergeVNodeHook(data, "afterEnter", performLeave);
          mergeVNodeHook(data, "enterCancelled", performLeave);
          mergeVNodeHook(oldData, "delayLeave", function(leave2) {
            delayedLeave = leave2;
          });
        }
      }
      return rawChild;
    }
  };
  var props = extend({
    tag: String,
    moveClass: String
  }, transitionProps);
  delete props.mode;
  var TransitionGroup = {
    props,
    beforeMount: function beforeMount() {
      var this$1 = this;
      var update = this._update;
      this._update = function(vnode, hydrating) {
        var restoreActiveInstance = setActiveInstance(this$1);
        this$1.__patch__(this$1._vnode, this$1.kept, false, true);
        this$1._vnode = this$1.kept;
        restoreActiveInstance();
        update.call(this$1, vnode, hydrating);
      };
    },
    render: function render(h) {
      var tag = this.tag || this.$vnode.data.tag || "span";
      var map = Object.create(null);
      var prevChildren = this.prevChildren = this.children;
      var rawChildren = this.$slots.default || [];
      var children = this.children = [];
      var transitionData = extractTransitionData(this);
      for (var i = 0; i < rawChildren.length; i++) {
        var c = rawChildren[i];
        if (c.tag) {
          if (c.key != null && String(c.key).indexOf("__vlist") !== 0) {
            children.push(c);
            map[c.key] = c;
            (c.data || (c.data = {})).transition = transitionData;
          } else {
            var opts2 = c.componentOptions;
            var name2 = opts2 ? opts2.Ctor.options.name || opts2.tag || "" : c.tag;
            warn("<transition-group> children must be keyed: <" + name2 + ">");
          }
        }
      }
      if (prevChildren) {
        var kept = [];
        var removed = [];
        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
          var c$1 = prevChildren[i$1];
          c$1.data.transition = transitionData;
          c$1.data.pos = c$1.elm.getBoundingClientRect();
          if (map[c$1.key]) {
            kept.push(c$1);
          } else {
            removed.push(c$1);
          }
        }
        this.kept = h(tag, null, kept);
        this.removed = removed;
      }
      return h(tag, null, children);
    },
    updated: function updated() {
      var children = this.prevChildren;
      var moveClass = this.moveClass || (this.name || "v") + "-move";
      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
        return;
      }
      children.forEach(callPendingCbs);
      children.forEach(recordPosition);
      children.forEach(applyTranslation);
      this._reflow = document.body.offsetHeight;
      children.forEach(function(c) {
        if (c.data.moved) {
          var el = c.elm;
          var s = el.style;
          addTransitionClass(el, moveClass);
          s.transform = s.WebkitTransform = s.transitionDuration = "";
          el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
            if (e && e.target !== el) {
              return;
            }
            if (!e || /transform$/.test(e.propertyName)) {
              el.removeEventListener(transitionEndEvent, cb);
              el._moveCb = null;
              removeTransitionClass(el, moveClass);
            }
          });
        }
      });
    },
    methods: {
      hasMove: function hasMove(el, moveClass) {
        if (!hasTransition) {
          return false;
        }
        if (this._hasMove) {
          return this._hasMove;
        }
        var clone = el.cloneNode();
        if (el._transitionClasses) {
          el._transitionClasses.forEach(function(cls) {
            removeClass(clone, cls);
          });
        }
        addClass(clone, moveClass);
        clone.style.display = "none";
        this.$el.appendChild(clone);
        var info = getTransitionInfo(clone);
        this.$el.removeChild(clone);
        return this._hasMove = info.hasTransform;
      }
    }
  };
  function callPendingCbs(c) {
    if (c.elm._moveCb) {
      c.elm._moveCb();
    }
    if (c.elm._enterCb) {
      c.elm._enterCb();
    }
  }
  function recordPosition(c) {
    c.data.newPos = c.elm.getBoundingClientRect();
  }
  function applyTranslation(c) {
    var oldPos = c.data.pos;
    var newPos = c.data.newPos;
    var dx = oldPos.left - newPos.left;
    var dy = oldPos.top - newPos.top;
    if (dx || dy) {
      c.data.moved = true;
      var s = c.elm.style;
      s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
      s.transitionDuration = "0s";
    }
  }
  var platformComponents = {
    Transition,
    TransitionGroup
  };
  Vue5.config.mustUseProp = mustUseProp;
  Vue5.config.isReservedTag = isReservedTag;
  Vue5.config.isReservedAttr = isReservedAttr;
  Vue5.config.getTagNamespace = getTagNamespace;
  Vue5.config.isUnknownElement = isUnknownElement;
  extend(Vue5.options.directives, platformDirectives);
  extend(Vue5.options.components, platformComponents);
  Vue5.prototype.__patch__ = inBrowser ? patch : noop;
  Vue5.prototype.$mount = function(el, hydrating) {
    el = el && inBrowser ? query(el) : void 0;
    return mountComponent(this, el, hydrating);
  };
  if (inBrowser) {
    setTimeout(function() {
      if (config.devtools) {
        if (devtools) {
          devtools.emit("init", Vue5);
        } else {
          console[console.info ? "info" : "log"]("Download the Vue Devtools extension for a better development experience:\nhttps://github.com/vuejs/vue-devtools");
        }
      }
      if (config.productionTip !== false && typeof console !== "undefined") {
        console[console.info ? "info" : "log"]("You are running Vue in development mode.\nMake sure to turn on production mode when deploying for production.\nSee more tips at https://vuejs.org/guide/deployment.html");
      }
    }, 0);
  }
  module2.exports = Vue5;
});

// node_modules/vue/dist/vue.runtime.common.js
var require_vue_runtime_common = __commonJS((exports2, module2) => {
  if (process.env.NODE_ENV === "production") {
    module2.exports = require_vue_runtime_common_prod();
  } else {
    module2.exports = require_vue_runtime_common_dev();
  }
});

// ../logger/dist/bundle.js
var require_bundle3 = __commonJS((exports2) => {
  var __defProp2 = Object.defineProperty;
  var __markAsModule2 = (target) => __defProp2(target, "__esModule", {value: true});
  var __export2 = (target, all) => {
    for (var name22 in all)
      __defProp2(target, name22, {get: all[name22], enumerable: true});
  };
  __markAsModule2(exports2);
  __export2(exports2, {
    createLogger: () => createLogger,
    versionTag: () => versionTag2
  });
  var name2 = "@explorelearning/logger";
  var version2 = "1.10.15";
  var description2 = "Fancy logging in the browser console";
  var main2 = "dist/bundle.js";
  var types2 = "dist/types/index.d.ts";
  var files2 = [
    "/dist"
  ];
  var scripts2 = {
    build: "node ../../helpers/build.js",
    "build:types": "npx tsc",
    test: "npx jest"
  };
  var repository2 = {
    type: "git",
    url: "git+https://github.com/ExploreLearning/el-web.git"
  };
  var author2 = "Brian McMillen <brian.mcmillen@explorelearning.com>";
  var license2 = "ISC";
  var bugs2 = {
    url: "https://github.com/ExploreLearning/el-web/issues"
  };
  var homepage2 = "https://github.com/ExploreLearning/el-web#readme";
  var package_default2 = {
    name: name2,
    version: version2,
    description: description2,
    main: main2,
    types: types2,
    files: files2,
    scripts: scripts2,
    repository: repository2,
    author: author2,
    license: license2,
    bugs: bugs2,
    homepage: homepage2
  };
  function log(...params) {
    if (localStorage.getItem("debug") === "true")
      console.info(...params);
  }
  if (!window.ELLogger) {
    window.ELLogger = {
      versionTagMap: {}
    };
    window.addEventListener("load", () => {
      const {versionTagMap} = window.ELLogger;
      Object.keys(versionTagMap).forEach((name22) => {
        logVersionTag({name: name22, version: versionTagMap[name22]});
      });
    });
  }
  versionTag2(package_default2);
  function logVersionTag({name: name22, version: version22}) {
    log(`%c${name22}%cv${version22}`, "color: #fbf1c7; background: #458588; padding: 2px 4px; border-radius: 3px 0 0 3px;", "color: #fbf1c7; background: #d65d0e; padding: 2px 4px; border-radius: 0 3px 3px 0");
  }
  function versionTag2({name: name22, version: version22}) {
    window.ELLogger.versionTagMap[name22] = version22;
  }
  function createLogger(name22) {
    return (...params) => {
      log(`${name22}:
`, ...params);
    };
  }
});

// src/index.ts
__markAsModule(exports);
__export(exports, {
  default: () => src_default
});

// src/models/Entity.ts
var Entity = class {
  constructor({id, options}) {
    const created = options.created || {};
    const modified = options.modified || {};
    this.id = id;
    this.created = {
      userId: created.loginId,
      timestamp: created.timestamp
    };
    this.modified = {
      userId: modified.loginId,
      timestamp: modified.timestamp
    };
  }
};
var Entity_default = Entity;

// src/models/Class.ts
var Class = class extends Entity_default {
  constructor(options) {
    super({id: options.id, options});
    this.name = options.name;
    this.ownerID = options.ownerId;
    this.studentIDs = options.studentIds || [];
    this.teacherIDs = options.teacherIds || [];
    this.unprintedMilestoneCount = options.unprintedMilestoneCount || 0;
    this.alerts = options.alerts || [];
  }
  get classID() {
    return this.id;
  }
  set classID(value) {
    this.id = value;
  }
  hasStudent(studentID) {
    return this.studentIDs.includes(studentID);
  }
  addStudent(studentID) {
    if (!this.hasStudent(studentID)) {
      this.studentIDs.push(studentID);
    }
  }
  removeStudent(studentID) {
    if (this.hasStudent(studentID)) {
      this.studentIDs.splice(this.studentIDs.indexOf(studentID), 1);
    }
  }
  hasTeacher(teacherID) {
    return this.teacherIDs.includes(teacherID);
  }
  addTeacher(teacherID) {
    if (!this.hasTeacher(teacherID)) {
      this.teacherIDs.push(teacherID);
    }
  }
  removeTeacher(teacherID) {
    if (this.hasTeacher(teacherID)) {
      this.teacherIDs.splice(this.teacherIDs.indexOf(teacherID), 1);
    }
  }
};
var Class_default = Class;

// src/utils/Lookup.ts
var Lookup = {
  disadv: {
    0: "Not Provided",
    1: "Yes",
    2: "No"
  },
  engProf: {
    0: "Not Provided",
    1: "Yes",
    2: "No"
  },
  ethnicity: {
    0: "Race not provided",
    11: "Hispanic / Latino",
    12: "American Indian / Alaska Native",
    13: "Asian",
    14: "Black / African American",
    15: "Native Hawaiian / Pacific Islander",
    16: "White",
    17: "Two or more races"
  },
  gender: {
    0: "Not Provided",
    1: "Female",
    2: "Male"
  },
  grade: {
    0: "Not Provided",
    1: "Kindergarten",
    2: "Grade 1",
    3: "Grade 2",
    4: "Grade 3",
    5: "Grade 4",
    6: "Grade 5",
    7: "Grade 6",
    8: "Grade 7",
    9: "Grade 8",
    10: "Grade 9",
    11: "Grade 10",
    12: "Grade 11",
    13: "Grade 12"
  },
  institutionType: {
    1: "Super District",
    2: "District",
    3: "Sub District",
    4: "Public School",
    5: "Private School",
    6: "State Department",
    7: "County Center",
    8: "Regional Center",
    9: "Home"
  },
  language: {
    1: "English",
    2: "Spanish",
    3: "French"
  },
  licenseType: {
    1: "Site",
    2: "Teacher",
    3: "Trial",
    4: "Complimentary",
    5: "Pilot",
    6: "Employee Free Trial",
    7: "Employee Seed Program",
    8: "Grant",
    9: "Home"
  },
  product: {
    1: "reflex",
    2: "frax",
    3: "gizmos",
    4: "science4us"
  },
  role: {
    1: "Home User",
    2: "Student",
    3: "Teacher",
    4: "Parent",
    5: "Administrator",
    50: "EL Administrator",
    51: "EL Report Viewer",
    100: "OFT Administrator",
    101: "OFT Viewer"
  },
  special: {
    0: "Not Provided",
    1: "Yes",
    2: "No"
  },
  title: {
    1: "Mr.",
    2: "Ms.",
    3: "Mrs.",
    4: "Miss",
    5: "Dr.",
    6: "Sr."
  },
  inverse: {
    disadv: {
      "Not Provided": 0,
      Yes: 1,
      No: 2
    },
    engProf: {
      "Not Provided": 0,
      Yes: 1,
      No: 2
    },
    ethnicity: {
      "Race not provided": 0,
      "Hispanic / Latino": 11,
      "American Indian / Alaska Native": 12,
      Asian: 13,
      "Black / African American": 14,
      "Native Hawaiian / Pacific Islander": 15,
      White: 16,
      "Two or more races": 17
    },
    gender: {
      "Not Provided": 0,
      Female: 1,
      Male: 2
    },
    grade: {
      "Not Provided": 0,
      Kindergarten: 1,
      "Grade 1": 2,
      "Grade 2": 3,
      "Grade 3": 4,
      "Grade 4": 5,
      "Grade 5": 6,
      "Grade 6": 7,
      "Grade 7": 8,
      "Grade 8": 9,
      "Grade 9": 10,
      "Grade 10": 11,
      "Grade 11": 12,
      "Grade 12": 13
    },
    institutionType: {
      "Super District": 1,
      District: 2,
      "Sub District": 3,
      "Public School": 4,
      "Private School": 5,
      "State Department": 6,
      "County Center": 7,
      "Regional Center": 8,
      Home: 9
    },
    language: {
      English: 1,
      Spanish: 2,
      French: 3
    },
    licenseType: {
      Site: 1,
      Teacher: 2,
      Trial: 3,
      Complimentary: 4,
      Pilot: 5,
      "Employee Free Trial": 6,
      "Employee Seed Program": 7,
      Grant: 8,
      Home: 9
    },
    product: {
      reflex: 1,
      frax: 2,
      gizmos: 3,
      science4us: 4,
      s4u: 4
    },
    role: {
      "Home User": 1,
      Student: 2,
      Teacher: 3,
      Parent: 4,
      Administrator: 5,
      "EL Administrator": 50,
      "EL Report Viewer": 51,
      "OFT Administrator": 100,
      "OFT Viewer": 101
    },
    special: {
      "Not Provided": 0,
      Yes: 1,
      No: 2
    },
    title: {
      "Mr.": 1,
      "Ms.": 2,
      "Mrs.": 3,
      Miss: 4,
      "Dr.": 5,
      "Sr.": 6
    }
  }
};
var Lookup_default = Lookup;

// src/models/User.ts
var User = class extends Entity_default {
  constructor(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    const id = options.id;
    super({id, options});
    if (options.userID != null) {
      this.userID = options.userID;
    } else {
      this.sisID = (_b = (_a = options.sisID) != null ? _a : options.sisUserId) != null ? _b : options.sisUserID;
    }
    this.username = options.username;
    this.email = options.email;
    this.languageID = (_d = (_c = options.languageID) != null ? _c : options.langID) != null ? _d : options.languageId;
    const roleId = (_e = options.roleId) != null ? _e : options.roleID;
    if (roleId) {
      this.roleID = roleId;
    } else {
      this.role = options.role;
    }
    this.titleID = (_f = options.titleID) != null ? _f : options.titleId;
    this.firstName = (_g = options.firstName) != null ? _g : options.firstname;
    this.middleName = (_i = (_h = options.middleName) != null ? _h : options.middlename) != null ? _i : "";
    this.lastName = (_j = options.lastName) != null ? _j : options.lastname;
    this.isValidEmail = options.isValidEmail;
    this.isSubscribedToEmails = options.isSubscribedToEmails;
    this.isDeleted = options.isDeleted;
  }
  get name() {
    return `${this.lastName}, ${this.firstName}`;
  }
  get userID() {
    return this.sisID;
  }
  set userID(value) {
    this.sisID = value;
  }
  get role() {
    return Lookup_default.role[this.roleID + ""];
  }
  set role(value) {
    this.roleID = Lookup_default.inverse.role[value];
  }
  get title() {
    return Lookup_default.title[this.titleID + ""];
  }
  set title(value) {
    this.titleID = Lookup_default.inverse.title[value];
  }
  get isAdmin() {
    return this.roleID > 4;
  }
};
var User_default = User;

// src/models/Profile.ts
var Profile = class extends User_default {
  constructor(options) {
    super(options);
    this.endDate = options.endDate;
  }
};
var Profile_default = Profile;

// src/models/Student.ts
var Student = class extends User_default {
  constructor(options) {
    super(options);
    var _a, _b, _c;
    this.gradeChangedOn = options.gradeChangedOn;
    if (options.language != null) {
    } else {
      this.languageID = options.languageId;
    }
    this.password = options.passwordClear || options.password;
    this.engProfID = options.limitedEnglishProficiencyID || options.engProfId;
    this.genderID = options.genderId;
    this.ethnicityID = options.ethnicityId;
    this.disadvID = (_a = options.disadvId) != null ? _a : options.ecoDisadvantagedID;
    this.specialEdID = (_b = options.specialEdId) != null ? _b : options.specialEdStatusID;
    this.usage = options.usage;
    this.schoolID = options.schoolID;
    if (options.grade != null) {
    } else {
      this.gradeID = (_c = options.gradeId) != null ? _c : options.gradeLevelID;
    }
    this.licenses = options.licenses || [];
    this.matchingLicenses = options.matchingLicenses || [];
  }
  get language() {
    return Lookup_default.language[this.languageID];
  }
  set language(value) {
    this.languageID = Lookup_default.inverse.language[value];
  }
  get engProf() {
    return Lookup_default.engProf[this.engProfID] || "Not Provided";
  }
  set engProf(value) {
    this.engProfID = Lookup_default.inverse.engProf[value];
  }
  get gender() {
    return Lookup_default.gender[this.genderID] || "Not Provided";
  }
  set gender(value) {
    this.genderID = Lookup_default.inverse.gender[value];
  }
  get ethnicity() {
    return Lookup_default.ethnicity[this.ethnicityID] || "Not Provided";
  }
  set ethnicity(value) {
    this.ethnicityID = Lookup_default.inverse.ethnicity[value];
  }
  get disadv() {
    return Lookup_default.disadv[this.disadvID] || "Not Provided";
  }
  set disadv(value) {
    this.disadvID = Lookup_default.inverse.disadv[value];
  }
  get special() {
    return Lookup_default.special[this.specialEdID] || "Not Provided";
  }
  set special(value) {
    this.specialEdID = Lookup_default.inverse.special[value];
  }
  get grade() {
    return Lookup_default.grade[this.gradeID];
  }
  set grade(value) {
    this.gradeID = Lookup_default.inverse.grade[value];
  }
};
var Student_default = Student;

// src/models/index.ts
var models_default = {Class: Class_default, Entity: Entity_default, Profile: Profile_default, Student: Student_default, User: User_default};

// src/state/app.ts
var import_platform_rest_api = __toModule(require("@explorelearning/platform-rest-api"));
var import_el_authenticator = __toModule(require_bundle2());
var app_default = ({rootNamespace, apis: apis2, endpoints}) => ({
  namespaced: true,
  state: {
    tenantID: null,
    subscriptionID: null,
    sourceID: null,
    roleID: null,
    jti: null,
    claims: {}
  },
  mutations: {
    INIT_API(_, {auth}) {
      apis2.platform = new import_platform_rest_api.default({auth});
    },
    SET_APP_INFO(state, payload) {
      for (const key in payload) {
        state[key] = payload[key];
      }
    },
    SET_SUBSCRIPTIONS(state, subscriptions) {
      state.subscriptions = subscriptions;
    },
    SET_INSTITUTIONS(state, institutions) {
      state.institutions = institutions;
    }
  },
  actions: {
    initApp(_0) {
      return __async(this, arguments, function* ({dispatch}, {logout = true} = {}) {
        const {auth} = yield dispatch("initApi", {logout});
        try {
          yield dispatch(`${rootNamespace}/profile/fetchProfile`, null, {root: true});
        } catch (e) {
          console.error("@explorelearning/platform-data: failed to fetch profile", e);
        }
        return {auth};
      });
    },
    initApi(_0) {
      return __async(this, arguments, function* ({commit}, {logout = true} = {}) {
        const auth = new import_el_authenticator.default(endpoints);
        auth.setLogoutForwardURL(process.env.VUE_APP_ROOT_PATH);
        yield auth.authenticate({logout});
        commit("INIT_API", {auth});
        const claims = auth.getClaims();
        const {tenID: tenantID, roleID, jti} = claims;
        commit("SET_APP_INFO", {tenantID, roleID, jti, claims});
        if (claims.roleID >= 100)
          auth.turnOffRefresh();
        return {auth};
      });
    },
    login(_0, _1) {
      return __async(this, arguments, function* ({dispatch}, {username, password, url}) {
        yield new import_platform_rest_api.default().login({username, password, url});
        yield dispatch("initApi");
      });
    },
    logout(_0) {
      return __async(this, arguments, function* ({dispatch}) {
        yield apis2.platform.logout();
        yield dispatch(`${rootNamespace}/employee/clearAllData`, null, {root: true});
      });
    },
    fetchModel(_0, _1) {
      return __async(this, arguments, function* ({dispatch, commit}, params) {
        var _a;
        const model = yield (_a = apis2.platform) == null ? void 0 : _a.fetchModel(params);
        if (!model)
          return;
        dispatch(`${rootNamespace}/teachers/setTeachers`, model.users.teachers, {root: true});
        dispatch(`${rootNamespace}/students/setStudents`, model.users.students, {root: true});
        dispatch(`${rootNamespace}/classes/setClasses`, model.classes, {root: true});
        commit("SET_SUBSCRIPTIONS", model.subscriptions);
        commit("SET_INSTITUTIONS", model.institutions);
        return model;
      });
    },
    fetchStudentModel() {
      return apis2.platform.fetchStudentModel();
    },
    addStudentsToProduct(_0, _1) {
      return __async(this, arguments, function* ({state}, {studentIds, productId}) {
        const {subscriptions, institutions} = state;
        const sub = subscriptions.find((s) => s.productId === productId);
        if (!sub)
          return;
        const calls = institutions.map(({id: institutionId}) => {
          return apis2.platform.addStudentsToProduct({
            institutionId,
            studentIds,
            productId,
            subscriptionId: sub.id,
            tenantId: sub.tenantId
          });
        });
        return Promise.all(calls);
      });
    },
    searchLoginsBySubscription({state: {tenantID}}, {subscriptionId}) {
      return apis2.platform.searchLoginsBySubscription({
        type: "TenantID",
        value: tenantID,
        subscriptionId
      });
    }
  },
  getters: {
    subscriptions: (s) => s.subscriptions,
    institutions: (s) => s.institutions
  }
});

// src/state/classes.ts
var import_vue = __toModule(require_vue_runtime_common());
var import_utils = __toModule(require_bundle());
var classes_default = ({apis: apis2}) => ({
  namespaced: true,
  state: {
    classes: {}
  },
  mutations: {
    SET_CLASSES(state, classes) {
      state.classes = classes;
    },
    CREATE_CLASS(state, data) {
      const _class = new Class_default(data);
      import_vue.default.set(state.classes, _class.id, _class);
      state.classes = __assign({}, state.classes);
    },
    DELETE_CLASS(state, classID) {
      delete state.classes[classID];
      state.classes = __assign({}, state.classes);
    },
    UPDATE_CLASS(state, {data, classID}) {
      const _class = import_utils.copy(state.classes[classID]);
      if (!_class)
        return;
      for (const prop in data) {
        if (_class[prop] !== void 0) {
          _class[prop] = data[prop];
        } else {
          import_vue.default.set(_class, prop, data[prop]);
        }
      }
      import_vue.default.set(state.classes, classID, _class);
    }
  },
  actions: {
    setClasses({commit}, classes) {
      const _classes = classes.reduce((acc, c) => {
        const _class = new Class_default(c);
        acc[_class.id] = _class;
        return acc;
      }, {});
      commit("SET_CLASSES", _classes);
    }
  },
  getters: {
    classes(state) {
      return __assign({}, state.classes);
    },
    classList(state) {
      return Object.values(state.classes);
    }
  }
});

// src/state/employee.ts
var import_vue2 = __toModule(require_vue_runtime_common());
var employee_default = ({apis: apis2}) => {
  return {
    namespaced: true,
    state: {
      userData: {}
    },
    mutations: {
      CLEAR_USER_DATA(state) {
        state.userData = {};
      },
      SET_USER_DATA(state, {id, data}) {
        import_vue2.default.set(state.userData, id, data);
      }
    },
    actions: {
      loadUserDataById(_0, _1) {
        return __async(this, arguments, function* ({state, commit}, {id, force = false}) {
          if (force || !state.userData[id]) {
            const {data} = yield apis2.platform.api(`login/${id}/csa`);
            commit("SET_USER_DATA", {id, data: data == null ? void 0 : data.LoginCSA});
          }
        });
      },
      clearAllData({commit}) {
        commit("CLEAR_USER_DATA");
      }
    },
    getters: {
      userDataMap: (s) => s.userData
    }
  };
};

// src/state/profile.ts
var profile_default = ({apis: apis2}) => ({
  namespaced: true,
  state: {
    profile: {}
  },
  mutations: {
    SET_PROFILE(state, profile) {
      state.profile = profile;
    }
  },
  actions: {
    fetchProfile(_0) {
      return __async(this, arguments, function* ({commit}) {
        const profile = yield apis2.platform.fetchProfile();
        commit("SET_PROFILE", new User_default(profile));
      });
    }
  },
  getters: {
    isHomeUser(state) {
      return state.profile.roleID === 1;
    },
    isStudent(state) {
      return state.profile.roleID === 2;
    },
    isTeacher(state) {
      return state.profile.roleID === 3;
    },
    isParent(state) {
      return state.profile.roleID === 4;
    },
    isAdmin(state) {
      return state.profile.roleID > 4;
    },
    isEmployee(state) {
      return state.profile.roleID >= 100;
    },
    isDeveloper(state) {
      return state.profile.roleID === 100;
    },
    profile(state) {
      return state.profile;
    }
  }
});

// src/state/students.ts
var import_vue3 = __toModule(require_vue_runtime_common());
var students_default = () => ({
  namespaced: true,
  state: {
    students: {},
    studentsChangeID: 0
  },
  mutations: {
    CLEAR_STUDENTS(state) {
      state.students = {};
      state.studentsChangeID++;
    },
    ADD_STUDENTS(state, students) {
      (students || []).forEach((s) => {
        const student = new Student_default(s);
        state.students[student.id] = student;
      });
      state.studentsChangeID++;
    },
    UPDATE_STUDENTS(state, students) {
      (students || []).forEach((s) => {
        const _student = state.students[s.id];
        if (_student) {
          for (const prop in s) {
            if (_student[prop] !== void 0) {
              _student[prop] = s[prop];
            } else {
              import_vue3.default.set(_student, prop, s[prop]);
            }
          }
          state.students[s.id] = _student;
        }
      });
      state.students = __assign({}, state.students);
      state.studentsChangeID++;
    },
    DELETE_STUDENTS(state, studentIDs) {
      (studentIDs || []).forEach((id) => import_vue3.default.delete(state.students, id));
      state.studentsChangeID++;
    }
  },
  actions: {
    setStudents({commit}, students) {
      commit("CLEAR_STUDENTS");
      commit("ADD_STUDENTS", (students || []).filter((s) => !s.isDeleted));
    }
  },
  getters: {
    students: (state) => state.students,
    studentList: (state) => Object.values(state.students || {}),
    studentsChangeID: (state) => state.studentsChangeID
  }
});

// src/state/teachers.ts
var import_vue4 = __toModule(require_vue_runtime_common());
var teachers_default = () => ({
  namespaced: true,
  state: {
    teachers: {}
  },
  mutations: {
    SET_TEACHERS(state, teachers) {
      state.teachers = teachers;
    },
    DELETE_TEACHERS(state, teacherIDs) {
      teacherIDs.forEach((id) => import_vue4.default.delete(state.teachers, id));
    }
  },
  actions: {
    setTeachers({commit}, teachers) {
      const teacherMap = teachers.reduce((acc, teacher) => {
        acc[teacher.id] = new User_default(teacher);
        return acc;
      }, {});
      commit("SET_TEACHERS", teacherMap);
    }
  },
  getters: {
    teachers: (state) => state.teachers,
    teacherList: (state) => Object.values(state.teachers)
  }
});

// src/state/index.ts
var apis = {
  platform: null
};
var State2 = class {
  constructor({namespace = "platform", endpoints = {}} = {}) {
    this.namespace = namespace;
    this.endpoints = endpoints;
  }
  getApi() {
    return apis.platform;
  }
  register(store) {
    this.store = store;
    const {namespace, endpoints} = this;
    const {modules} = State2;
    store.registerModule(namespace, {
      namespaced: true,
      modules: Object.keys(modules).reduce((acc, key) => {
        const mod = modules[key]({rootNamespace: namespace, apis, endpoints});
        return __assign(__assign({}, acc), {[key]: mod});
      }, {})
    });
  }
  onAuthenticated(callback) {
    const {namespace, store} = this;
    if (this.removeOnAuthenticated)
      this.removeOnAuthenticated();
    this.removeOnAuthenticated = store.subscribe(({type}) => {
      var _a;
      if (type === `${namespace}/app/INIT_API`) {
        const auth = (_a = this.getApi()) == null ? void 0 : _a.getAuth();
        if (auth)
          callback(auth);
      }
    });
  }
};
var State = State2;
State.modules = {
  app: app_default,
  classes: classes_default,
  employee: employee_default,
  profile: profile_default,
  students: students_default,
  teachers: teachers_default
};
var state_default = State;

// src/index.ts
var import_logger = __toModule(require_bundle3());

// package.json
var name = "@explorelearning/platform-data";
var version = "1.10.19";
var description = "data models, id maps, and vuex plugin to represent, access, and store Platform data";
var main = "dist/bundle.js";
var types = "dist/types/index.d.ts";
var files = [
  "/dist"
];
var scripts = {
  build: "node ../../helpers/build.js --external=@explorelearning/platform-rest-api",
  "build:types": "npx tsc",
  test: "npx jest"
};
var repository = {
  type: "git",
  url: "git+https://github.com/ExploreLearning/el-web.git"
};
var author = "Brian McMillen <brian.mcmillen@explorelearning.com>";
var license = "ISC";
var bugs = {
  url: "https://github.com/ExploreLearning/el-web/issues"
};
var homepage = "https://github.com/ExploreLearning/el-web#readme";
var peerDependencies = {
  "@explorelearning/el-authenticator": "^1.10.6",
  "@explorelearning/logger": "^1.10.7",
  "@explorelearning/platform-rest-api": "^1.10.6",
  "@explorelearning/urls": "^1.10.4",
  "@explorelearning/utils": "^1.10.4",
  vue: "^2.6.12"
};
var devDependencies = {
  "@explorelearning/el-authenticator": "^1.10.19",
  "@explorelearning/logger": "^1.10.15",
  "@explorelearning/platform-rest-api": "^1.10.19",
  "@explorelearning/urls": "^1.10.15",
  "@explorelearning/utils": "^1.10.16",
  vue: "^2.6.12"
};
var gitHead = "e474bc856a8276bbc47c73a2a2ee69523319148e";
var package_default = {
  name,
  version,
  description,
  main,
  types,
  files,
  scripts,
  repository,
  author,
  license,
  bugs,
  homepage,
  peerDependencies,
  devDependencies,
  gitHead
};

// src/index.ts
import_logger.versionTag(package_default);
var src_default = {Models: models_default, State: state_default, Lookup: Lookup_default};
